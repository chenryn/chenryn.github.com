<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>三斗室</title>
    <meta name="author" content="陈子">
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/pygments/default.css" rel="stylesheet" type="text/css">
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">三斗室</a>
          <ul class="nav">
      	<li><a href="/tags.html">Tags</a></li>
      	<li><a href="/archive.html">Archive</a></li>
      	<li><a href="/categories.html">Categories</a></li>
      	<li><a href="/pages.html">Pages</a></li>
            <li><link title="RSS 2.0" type="application/rss+xml" href="http://chenlinux.com/feed.xml" rel="alternate" /><a href="http://chenlinux.com/feed.xml" target="_blank">RSS订阅</a></li>
            <li><a href="/projects.html">学习记录</a></li>
          </ul>
          <ul class="nav pull-right"><li><a href="/about.html">有关我</a></li></ul>
        </div>
      </div>
    </div>
    <div class="container">
    <div class="row">
      <div class="span7">
<div class="row">
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/07/19/anyevent-fork-http-load-runner-demo" title="用AnyEvent和ForkManager写一个http协议的压测工具" rel="bookmark">用AnyEvent和ForkManager写一个http协议的压测工具</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-07-19 00:00:00 +0800">19 Jul 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#testing-ref" title="testing" rel="category tag">testing</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>话不多说，先上第一版的代码：</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="nn">Time::</span><span class="n">HiRes</span> <span class="sx">qw/time/</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">AnyEvent::</span><span class="n">HTTP</span><span class="p">;</span>
<span class="k">use</span> <span class="n">AnyEvent</span><span class="p">;</span>
<span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">%code</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$count</span> <span class="o">=</span> <span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">my</span> <span class="nv">$url</span> <span class="o">=</span> <span class="s">&quot;https://10.10.10.10/&quot;</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$begin</span> <span class="o">=</span> <span class="nb">time</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@coro</span> <span class="o">=</span> <span class="nb">map</span> <span class="p">{</span>
    <span class="n">async</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$cv</span> <span class="o">=</span> <span class="nn">AnyEvent::</span><span class="n">condvar</span><span class="p">;</span>
        <span class="nv">$cv</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$header_time</span><span class="p">;</span>
        <span class="n">http_request</span> <span class="n">GET</span> <span class="o">=&gt;</span> <span class="s">&quot;$url&quot;</span><span class="p">,</span>
            <span class="k">sub </span><span class="p">{</span>
                <span class="k">my</span> <span class="p">(</span><span class="nb">undef</span><span class="p">,</span> <span class="nv">$hdr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
                <span class="nv">$code</span><span class="p">{</span><span class="nv">$hdr</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;Status&#39;</span><span class="p">}}</span><span class="o">++</span><span class="p">;</span>
                <span class="nv">$cv</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">;</span>
        <span class="nv">$cv</span><span class="o">-&gt;</span><span class="nb">recv</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">(</span><span class="mi">1</span> <span class="o">..</span> <span class="nv">$count</span><span class="p">);</span>
<span class="nv">$_</span><span class="o">-&gt;</span><span class="nb">join</span> <span class="k">for</span> <span class="nv">@coro</span><span class="p">;</span>
<span class="k">print</span> <span class="nv">$cpus</span><span class="o">*</span><span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="nb">time</span><span class="o">-</span><span class="nv">$begin</span><span class="p">);</span>
</code></pre></div>
<p>上面这段脚本，作用是在每个进程中运行事件驱动的协程，以达到尽可能大的并发请求。</p>
<p>初步的测试，在单核Coro的情况下可以每秒发送1000+的https请求。</p>
<p>注意：如果使用的是AnyEvent::HTTP::LWP::UserAgent模块，虽然POD里写它用的其实就是AnyEvent::HTTP的代码套LWP的API格式，但实际只能用到30%的CPU，单核情况下的qps也就不到350的样子。</p>
<p>注意：本例测试的是HTTPS，AnyEvent::HTTP在TLS模式(即https请求)下，无法开启persistent连接。如果是普通http请求，开启persistent参数的qps应该会更高！</p>
<p>然后上第二版的代码，改用了EV循环，性能比Coro协程提高了大概5%的样子。使用了fork多进程，并且绑定到不同的CPU核上。</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="n">autodie</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Parallel::</span><span class="n">ForkManager</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Time::</span><span class="n">HiRes</span> <span class="sx">qw/time/</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Sys::</span><span class="n">CpuAffinity</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">AnyEvent::</span><span class="n">HTTP</span><span class="p">;</span>
<span class="k">use</span> <span class="n">AE</span><span class="p">;</span>
<span class="k">use</span> <span class="n">EV</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$cpus</span> <span class="o">=</span> <span class="nn">Sys::CpuAffinity::</span><span class="n">getNumCpus</span><span class="p">();</span>
<span class="k">my</span> <span class="nv">$pm</span> <span class="o">=</span> <span class="k">new</span> <span class="nn">Parallel::</span><span class="n">ForkManager</span><span class="p">(</span><span class="nv">$cpus</span><span class="p">,</span> <span class="s">&quot;/tmp/&quot;</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">@urls</span> <span class="o">=</span> <span class="sx">qw(https://10.11.19.35/ https://10.11.21.121/)</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$res</span><span class="p">;</span>
<span class="nv">$pm</span><span class="o">-&gt;</span><span class="n">run_on_finish</span><span class="p">(</span> <span class="k">sub </span><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="nv">$_</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="nv">$res</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;code&#39;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;code&#39;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="k">for</span> <span class="nb">keys</span> <span class="nv">%</span><span class="p">{</span><span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;code&#39;</span><span class="p">}};</span>
    <span class="nv">$res</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;size&#39;</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;size&#39;</span><span class="p">};</span>
    <span class="nv">$res</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">};</span>
<span class="p">});</span>
<span class="k">my</span> <span class="nv">$begin</span> <span class="o">=</span> <span class="nb">time</span><span class="p">;</span>
<span class="k">foreach</span> <span class="k">my</span> <span class="nv">$cpu</span> <span class="p">(</span><span class="mi">1</span> <span class="o">..</span> <span class="nv">$cpus</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$pid</span> <span class="o">=</span> <span class="nv">$pm</span><span class="o">-&gt;</span><span class="n">start</span> <span class="ow">and</span> <span class="k">next</span><span class="p">;</span>
    <span class="nn">Sys::CpuAffinity::</span><span class="n">setAffinity</span><span class="p">(</span><span class="vg">$$</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nv">$cpu</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="n">ae_get</span><span class="p">(</span><span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">\</span><span class="nv">@urls</span><span class="p">);</span>
    <span class="nv">$pm</span><span class="o">-&gt;</span><span class="n">finish</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nv">$data</span><span class="p">);</span>
<span class="p">}</span>
<span class="nv">$pm</span><span class="o">-&gt;</span><span class="n">wait_all_children</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$use</span> <span class="o">=</span> <span class="nb">time</span> <span class="o">-</span> <span class="nv">$begin</span><span class="p">;</span>
<span class="nb">printf</span> <span class="s">&quot;%d fetches, %d max processes, in %.03f seconds\n&quot;</span><span class="p">,</span> <span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nv">$cpus</span><span class="p">,</span> <span class="nv">$cpus</span><span class="p">,</span> <span class="nv">$use</span><span class="p">;</span>
<span class="nb">printf</span> <span class="s">&quot;%.03f fetches/sec, %.03f bytes/sec\n&quot;</span><span class="p">,</span> <span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nv">$cpus</span> <span class="sr">/ $use, $res-&gt;{&#39;size&#39;} /</span> <span class="nv">$res</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">};</span>
<span class="nb">printf</span> <span class="s">&quot;HTTP response codes:\n&quot;</span><span class="p">;</span>
<span class="nb">printf</span> <span class="s">&quot;       %d - %d\n&quot;</span><span class="p">,</span> <span class="nv">$_</span><span class="p">,</span> <span class="nv">$res</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;code&#39;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="nv">$_</span><span class="p">}</span> <span class="k">for</span> <span class="nb">sort</span> <span class="nb">keys</span> <span class="nv">%</span><span class="p">{</span><span class="nv">$res</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;code&#39;</span><span class="p">}};</span>
<span class="k">sub </span><span class="nf">ae_get</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$count</span><span class="p">,</span> <span class="nv">$urls</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$data</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$tmptime</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$cv</span> <span class="o">=</span> <span class="nn">AE::</span><span class="n">cv</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="mi">1</span> <span class="o">..</span> <span class="nv">$count</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$hdr_time</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$url</span> <span class="o">=</span> <span class="nv">$urls</span><span class="o">-&gt;</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">rand</span><span class="p">(</span><span class="nv">$#</span><span class="p">{</span><span class="nv">$urls</span><span class="p">}</span><span class="o">+</span><span class="mi">1</span><span class="p">))];</span>
        <span class="nv">$cv</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">;</span>
        <span class="n">http_request</span>
            <span class="n">GET</span>       <span class="o">=&gt;</span> <span class="s">&quot;$url&quot;</span><span class="p">,</span> 
            <span class="n">on_header</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
                <span class="nv">$hdr_time</span> <span class="o">=</span> <span class="nb">time</span><span class="p">;</span>
            <span class="p">},</span>
            <span class="k">sub </span><span class="p">{</span>
                <span class="k">my</span> <span class="p">(</span><span class="nb">undef</span><span class="p">,</span> <span class="nv">$hdr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
                <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;code&#39;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="nv">$hdr</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;Status&#39;</span><span class="p">}}</span><span class="o">++</span><span class="p">;</span>
                <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;size&#39;</span><span class="p">}</span> <span class="o">+=</span> <span class="nv">$hdr</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;content-length&#39;</span><span class="p">};</span>
                <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;time&#39;</span><span class="p">}</span> <span class="o">+=</span> <span class="p">(</span> <span class="nb">time</span> <span class="o">-</span> <span class="nv">$hdr_time</span> <span class="p">);</span>
                <span class="nv">$cv</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">;</span>
    <span class="p">}</span> 
    <span class="nv">$cv</span><span class="o">-&gt;</span><span class="nb">recv</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>增加了简单的统计功能，包括每秒请求数、平均下载速度，状态码汇总等。因为不好计算header的长度，所以只计算body部分的下载速度。
增加了url列表功能，每次请求会随机的抽取其中的一个url。</p>
      <a href="/2012/07/19/anyevent-fork-http-load-runner-demo" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/07/07/intro-ipc-locker" title="IPC::Locker模块介绍" rel="bookmark">IPC::Locker模块介绍</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-07-07 00:00:00 +0800">07 Jul 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>当你需要给一个集群的某项服务做简单的排他性管理的时候，强力推荐Veripool公司的一系列模块：IPC::Locker、Schedule::Load。</p>
<p>今天先说IPC::Locker模块。部署很简单，直接在集群所有节点上运行cpanm IPC::Locker即可。该模块依赖几个都是perl的核心模块比如IO::Socket::INET、IO::Poll和POSIX。所以理论上你也可以把代码打个包分发。</p>
<p>随包分发的还有几个现成的脚本程序lockerd、lockersh、pidstat、pidstatd和pidwatch。</p>
<p>后面三个关注的remote设备上的pid是否存在等，但是相信一般情况下，我们不会自己来通过pid管理集群，所以在使用上只要理解lockerd和lockersh其实也是用pidstatd来解决pid问题的就够了。</p>
<p>其实代码很简单，看看就明白，无非就是lockerd用的IPC::Locker::Server是启动了一个IO::Socket::INET做tcp server，主要维护几个东西，一个是@{$self-&gt;{lock}}列表，一个是@{$self-&gt;{host}}列表，一个是$self-&gt;{locked}的Bool值。</p>
<p>而lockersh用的IPC::Locker则是连接上lockerd的端口，检查$self-&gt;{locked}状态，如果没locked就发送LOCK请求，然后fork一个进行exec你定义的shell命令，执行完成后，unlock发送UNLOCK请求给lockerd。</p>
<p>做个简单实验：</p>
<ol>
  <li>在serverA上运行lockerd &amp;     </li>
  <li>在serverB上运行lockersh &ndash;dhost serverA &ndash;lock test_task &lsquo;while true;do echo &ldquo;OK&rdquo;;done&rsquo;</li>
  <li>在serverC上运行lockersh &ndash;dhost serverA &ndash;lock test_task &lsquo;while true;do echo &ldquo;OK&rdquo;;done&rsquo;</li>
  <li>在serverD上运行lockersh &ndash;dhost serverA &ndash;lock other_task &lsquo;while true;do echo &ldquo;OK&rdquo;;done&rsquo;</li>
</ol>
<p>观察一下，结果是在serverB和serverD上同时在执行echo &ldquo;OK&rdquo;。而serverC被lock住了。继续：</p>
<ol>
  <li>在serverB的session上按下Ctrl+C终止程序，然后再次运行上述命令</li>
  <li>在serverC的session上按下Ctrl+C终止程序</li>
</ol>
<p>观察一下，结果是停止B时C的即开始，停止C的后B的继续。这些都不影响serverD的运行。</p>
<ol>
  <li>终止serverD的程序，改为运行lockersh &ndash;dhost serverA &ndash;lock test_task &lsquo;while true;do echo &ldquo;OK&rdquo;;done&rsquo;</li>
</ol>
<p>观察一下，发现B、C、D是按照lockersh的执行次序解锁的。因为hostlist是一个列表，在server上是用for循环的。</p>
<p>注意：必须要先运行lockerd并且保证不中途退出。经过测试，如果lockerd中途退出再重新运行的话，因为locklist是保存在内存里会丢失的。结果就会出现之前的lockersh还在执行(他已经获得了lock，在unlock之前不会再和server通信的)，之后再启动的新lockersh会在新lockerd上又获得一次lock的情况……</p>
<p>后一个Schedule::Load则可以根据集群设备的loadavg，top等，决定在哪台设备上运行job。还没测试。之后再记录。</p>
<p>补充：贴一个脚本，仿照lockersh改写的squid集群重启及报警控制：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl -w</span>
<span class="k">use</span> <span class="n">FindBin</span><span class="p">;</span>
<span class="k">use</span> <span class="n">lib</span> <span class="s">&quot;$FindBin::Bin/../lib&quot;</span><span class="p">;</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="n">autodie</span><span class="p">;</span>
<span class="k">use</span> <span class="n">vars</span> <span class="sx">qw ($Debug);</span>
<span class="sx">use </span><span class="n">Furl</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IO::</span><span class="n">File</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Getopt::</span><span class="n">Long</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IPC::</span><span class="n">Locker</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IPC::</span><span class="n">PidStat</span><span class="p">;</span>
<span class="c1">#======================================================================</span>
<span class="k">my</span> <span class="nv">$pscount</span> <span class="o">=</span> <span class="sb">`ps aux|grep -v grep|grep $0|wc -l`</span><span class="p">;</span>
<span class="k">print</span> <span class="s">&quot;Already run, waiting for lock now&quot;</span> <span class="ow">and</span> <span class="nb">exit</span> <span class="k">unless</span> <span class="nv">$pscount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">#======================================================================</span>
<span class="k">my</span> <span class="nv">%server_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">lock</span><span class="o">=&gt;[]</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$cluserv</span><span class="p">;</span>
<span class="nv">$Debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nn">Getopt::Long::</span><span class="n">config</span> <span class="p">(</span><span class="s">&quot;require_order&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">GetOptions</span> <span class="p">(</span>
                  <span class="s">&quot;dhost=s&quot;</span>     <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span><span class="nb">shift</span><span class="p">;</span> <span class="nv">$server_params</span><span class="p">{</span><span class="n">host</span><span class="p">}</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;},</span>
                  <span class="s">&quot;cluster=s&quot;</span>   <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span><span class="nb">shift</span><span class="p">;</span> <span class="nb">push</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$server_params</span><span class="p">{</span><span class="n">lock</span><span class="p">}},</span> <span class="nb">split</span><span class="p">(</span><span class="s">&#39;:&#39;</span><span class="p">,</span><span class="nb">shift</span><span class="p">);},</span>
                  <span class="s">&quot;port=i&quot;</span>      <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span><span class="nb">shift</span><span class="p">;</span> <span class="nv">$server_params</span><span class="p">{</span><span class="n">port</span><span class="p">}</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;},</span>
                  <span class="s">&quot;timeout=i&quot;</span>   <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span><span class="nb">shift</span><span class="p">;</span> <span class="nv">$server_params</span><span class="p">{</span><span class="n">timeout</span><span class="p">}</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;},</span>
                  <span class="s">&quot;verbose!&quot;</span>    <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span><span class="nb">shift</span><span class="p">;</span> <span class="nv">$server_params</span><span class="p">{</span><span class="n">verbose</span><span class="p">}</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;},</span>
                  <span class="s">&quot;debug&quot;</span>       <span class="o">=&gt;</span> <span class="o">\&amp;</span><span class="n">debug</span><span class="p">,</span>
                  <span class="s">&quot;service=s&quot;</span>   <span class="o">=&gt;</span> <span class="o">\</span><span class="nv">$cluserv</span><span class="p">,</span>
                  <span class="p">))</span> <span class="p">{</span>
    <span class="nb">die</span> <span class="s">&quot;%Error: Bad usage, see lockersh --help\n&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="nv">$#</span><span class="p">{</span><span class="nv">$server_params</span><span class="p">{</span><span class="n">lock</span><span class="p">}}</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;%Error: --cluster not specified; see lockersh --help\n&quot;</span><span class="p">;</span>
<span class="c1"># Fork once to start parent process</span>
<span class="k">my</span> <span class="nv">$foreground_pid</span> <span class="o">=</span> <span class="vg">$$</span><span class="p">;</span>  <span class="c1"># Unlike most forks, the job goes in the parent</span>
<span class="c1"># Do this while we still have STDERR.</span>
<span class="k">my</span> <span class="nv">$lock</span>  <span class="o">=</span> <span class="k">new</span> <span class="nn">IPC::</span><span class="n">Locker</span> <span class="p">(</span><span class="n">verbose</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">timeout</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">autounlock</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">destroy_unlock</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">,</span>
                             <span class="nv">%server_params</span><span class="p">,</span>
                             <span class="p">);</span>
<span class="nv">$lock</span> <span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;%Error: Did not connect to lockerd,&quot;</span><span class="p">;</span>
<span class="nv">$lock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="k">my</span> <span class="nv">$pid</span> <span class="o">=</span> <span class="nb">fork</span><span class="p">())</span> <span class="p">{</span>  <span class="c1"># Parent process, foreground job</span>
    <span class="k">print</span> <span class="s">&quot;\tForeground: $cluserv\n&quot;</span> <span class="k">if</span> <span class="nv">$Debug</span><span class="p">;</span>
    <span class="c1"># The child forks again quickly.  Sometimes, SIG_CHLD leaks to us and</span>
    <span class="c1"># wrecks the exec&#39;d command, so wait for it now.</span>
    <span class="k">my</span> <span class="nv">$rv</span> <span class="o">=</span> <span class="nb">waitpid</span><span class="p">(</span><span class="nv">$pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$rv</span> <span class="o">!=</span> <span class="nv">$pid</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">die</span> <span class="s">&quot;%Error: waitpid() returned $rv: $!&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">elsif</span> <span class="p">(</span><span class="vg">$?</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">die</span> <span class="s">&quot;%Error: Child process died with status $?,&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">print</span> <span class="s">&quot;Exec in $$\n&quot;</span> <span class="k">if</span> <span class="nv">$Debug</span><span class="p">;</span>
    <span class="o">&amp;</span><span class="n">service</span><span class="p">(</span><span class="nv">$cluserv</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">#else, rest is for child process.</span>
<span class="c1"># Disassociate from controlling terminal</span>
<span class="nn">POSIX::</span><span class="n">setsid</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;%Error: Can&#39;t start a new session: $!&quot;</span><span class="p">;</span>
<span class="c1"># Change working directory</span>
<span class="nb">chdir</span> <span class="s">&quot;/&quot;</span><span class="p">;</span>
<span class="nb">open</span><span class="p">(</span><span class="bp">STDIN</span><span class="p">,</span>  <span class="s">&quot;+&gt;/dev/null&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;%Error: Can&#39;t re-open STDIN: $!&quot;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$Debug</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">open</span><span class="p">(</span><span class="bp">STDOUT</span><span class="p">,</span> <span class="s">&quot;+&gt;&amp;STDIN&quot;</span><span class="p">);</span>
    <span class="nb">open</span><span class="p">(</span><span class="bp">STDERR</span><span class="p">,</span> <span class="s">&quot;+&gt;&amp;STDIN&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1"># Prevent possibility of acquiring a controlling terminal</span>
<span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="nb">fork</span><span class="p">();</span>
<span class="c1"># Wait for child to complete.  We can&#39;t waitpid, as we&#39;re not the parent</span>
<span class="k">while</span> <span class="p">(</span><span class="nn">IPC::PidStat::</span><span class="n">local_pid_exists</span><span class="p">(</span><span class="nv">$foreground_pid</span><span class="p">))</span> <span class="p">{</span> <span class="nb">sleep</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">print</span> <span class="s">&quot;Parent $foreground_pid completed\n&quot;</span> <span class="k">if</span> <span class="nv">$Debug</span><span class="p">;</span>
<span class="c1"># Unlock</span>
<span class="nv">$lock</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">;</span> <span class="nv">$lock</span><span class="o">=</span><span class="nb">undef</span><span class="p">;</span>
<span class="k">print</span> <span class="s">&quot;Child exiting\n&quot;</span> <span class="k">if</span> <span class="nv">$Debug</span><span class="p">;</span>
<span class="k">sub </span><span class="nf">debug</span> <span class="p">{</span>
    <span class="nv">$Debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nv">$</span><span class="nn">IPC::Locker::</span><span class="nv">Debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">sub </span><span class="nf">service</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$cluserv</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="nb">die</span> <span class="s">&quot;Only support squid now!&quot;</span> <span class="k">unless</span> <span class="nv">$cluserv</span> <span class="ow">eq</span> <span class="s">&quot;squid&quot;</span><span class="p">;</span>
    <span class="nb">die</span> <span class="s">&quot;Reload failed. Check squid.conf!&quot;</span> <span class="k">if</span> <span class="nb">eval</span> <span class="s">&quot;${cluserv}_reload&quot;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$hit_rate</span> <span class="o">=</span> <span class="nb">eval</span> <span class="s">&quot;${cluserv}_check&quot;</span><span class="p">;</span>
        <span class="n">notify</span> <span class="s">&quot;HIT Ratio: ${hit_rate}% now.\n&quot;</span><span class="p">;</span>
        <span class="nb">exit</span> <span class="k">if</span> <span class="nv">$hit_rate</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">;</span>
        <span class="nb">sleep</span> <span class="mi">300</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="k">sub </span><span class="nf">squid_check</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$hit_rate</span><span class="p">;</span>
    <span class="k">print</span> <span class="s">&quot;Run squid_check&quot;</span> <span class="k">if</span> <span class="nv">$Debug</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$squid_port</span> <span class="o">=</span> <span class="sb">`awk &#39;/^http_port/{print $2}&#39; /etc/squid/squid.conf`</span><span class="p">;</span>
    <span class="nb">open</span> <span class="k">my</span> <span class="nv">$fh</span><span class="p">,</span> <span class="s">&quot;squidclient -p ${squid_port} mgr:info |&quot;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="sr">&lt;$fh&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">next</span> <span class="k">unless</span> <span class="sr">/^\s+Request Hit Ratios:\s+5min:\s*(-?\d+\.\d)%,/</span><span class="p">;</span>
        <span class="k">print</span> <span class="s">&quot;regex $1&quot;</span> <span class="k">if</span> <span class="nv">$Debug</span><span class="p">;</span>
        <span class="nv">$hit_rate</span> <span class="o">=</span> <span class="nv">$1</span><span class="p">;</span>
        <span class="k">last</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">close</span> <span class="nv">$fh</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$hit_rate</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">sub </span><span class="nf">squid_reload</span> <span class="p">{</span>
    <span class="k">print</span> <span class="s">&quot;Reload squid daemon. Do not reload within 10 mins of squid start&quot;</span> <span class="k">if</span> <span class="nv">$Debug</span><span class="p">;</span>
    <span class="nb">system</span><span class="p">(</span><span class="s">&quot;squid&quot;</span><span class="p">,</span> <span class="s">&quot;-k&quot;</span><span class="p">,</span> <span class="s">&quot;reconfigure&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="vg">$?</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">sub </span><span class="nf">notify</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$furl</span> <span class="o">=</span> <span class="n">Furl</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span><span class="n">agent</span> <span class="o">=&gt;</span> <span class="s">&quot;Clustrol/0.1&quot;</span><span class="p">);</span>
    <span class="nv">$furl</span><span class="o">-&gt;</span><span class="n">post</span><span class="p">(</span><span class="s">&quot;http://monitor.domain.com/eml/&quot;</span><span class="p">,</span>
        <span class="p">[</span> <span class="n">data</span> <span class="o">=&gt;</span> <span class="s">&quot;$_&quot;</span> <span class="p">],</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="cp">__END__</span>
</code></pre></div>
      <a href="/2012/07/07/intro-ipc-locker" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/07/02/anyevent-httpd-demo" title="AnyEvent::HTTPD和AnyEvent::HTTP使用实例" rel="bookmark">AnyEvent::HTTPD和AnyEvent::HTTP使用实例</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-07-02 00:00:00 +0800">02 Jul 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>很简单的一个实例，就是开一个端口接受url请求，然后向squid提交这个url的刷新。</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="nn">AnyEvent::</span><span class="n">HTTPD</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">AnyEvent::</span><span class="n">HTTP</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$httpd</span> <span class="o">=</span> <span class="nn">AnyEvent::</span><span class="n">HTTPD</span><span class="o">-&gt;</span><span class="k">new</span> <span class="p">(</span><span class="n">port</span> <span class="o">=&gt;</span> <span class="mi">9090</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$ip</span> <span class="o">=</span> <span class="s">&quot;127.0.0.1&quot;</span><span class="p">;</span>
<span class="nv">$httpd</span><span class="o">-&gt;</span><span class="n">reg_cb</span> <span class="p">(</span>
    <span class="s">&#39;/&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$httpd</span><span class="p">,</span> <span class="nv">$req</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$urlpath</span> <span class="o">=</span> <span class="nv">$req</span><span class="o">-&gt;</span><span class="n">url</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>
        <span class="n">http_request</span> <span class="n">PURGE</span> <span class="o">=&gt;</span> <span class="s">&quot;http://${ip}${urlpath}&quot;</span><span class="p">,</span> <span class="n">headers</span><span class="o">=&gt;</span> <span class="p">{</span> <span class="s">&quot;host&quot;</span><span class="o">=&gt;</span><span class="s">&quot;host.domain.com&quot;</span><span class="p">},</span> <span class="k">sub </span><span class="p">{</span>
            <span class="k">my</span> <span class="p">(</span><span class="nv">$body</span><span class="p">,</span> <span class="nv">$hdr</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
            <span class="nv">$req</span><span class="o">-&gt;</span><span class="n">respond</span><span class="p">([</span><span class="s">&quot;$hdr-&gt;{&#39;Status&#39;}&quot;</span><span class="p">,</span><span class="s">&quot;$hdr-&gt;{&#39;Reason&#39;}&quot;</span><span class="p">,{</span><span class="s">&#39;Content-Type&#39;</span> <span class="o">=&gt;</span> <span class="s">&#39;text/html&#39;</span><span class="p">}]);</span>
        <span class="p">};</span>
    <span class="p">},</span>
<span class="p">);</span>
<span class="nv">$httpd</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">;</span>
</code></pre></div>
<p>注意安装AnyEvent::HTTPD的时候，test需要Test::POD，但是Makefile.PL上没写，所以要先行安装。</p>
      <a href="/2012/07/02/anyevent-httpd-demo" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/06/29/coro-intro" title="【翻译】Coro::Intro文档" rel="bookmark">【翻译】Coro::Intro文档</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-06-29 00:00:00 +0800">29 Jun 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>
<ul>
	<li><a href="#coro简介">Coro简介</a></li>
	<li><a href="#什么是coro_">什么是Coro？</a></li>
	<li><a href="#协作线程">协作线程</a></li>
	<ul>
		<li><a href="#信号量和其他锁">信号量和其他锁</a></li>
		<li><a href="#频道">频道</a></li>
		<li><a href="#什么是我的_什么是我们的_">什么是我的，什么是我们的？</a></li>
		<li><a href="#调试">调试</a></li>
	</ul>
	<li><a href="#真实世界里的事件循环">真实世界里的事件循环</a></li>
	<ul>
		<li><a href="#真实世界里的文件操作">真实世界里的文件操作</a></li>
		<li><a href="#翻转控制____唤醒函数">翻转控制 —— 唤醒函数</a></li>
	</ul>
	<li><a href="#其他模块">其他模块</a></li>
	<li><a href="#作者">作者</a></li>
</ul>
<hr name="index" />
</div>
<!-- INDEX END -->
<p>
</p>
<h1><a name="coro简介">Coro简介</a></h1>
<p>这个教程准备给你介绍Coro模块家族的最主要的几个特性。</p>
<p>本文首先介绍一些基础概念，然后简单的概述一下Coro家族的情况。</p>
<p>
</p>
<hr />
<h1><a name="什么是coro_">什么是Coro？</a></h1>
<p>Coro最早是作为一个协程的简单实现的模块开始的。它允许你捕获当前的运行点并且跳到另一个点去，又随时可以再跳回来。作为一种非局部的跳转，和C语言里的<code>setjmp</code>/<code>longjmp</code>没什么不同。这就是<a href="/Coro/State.html">the Coro::State manpage</a>模块。</p>
<p>这有一个很天然的应用场合，就是在协作线程中内置一个调度器和结果集，这也是当前Coro最主要的应用场景。很多文档和论文把这些“协作线程(cooperative threads)”叫做“协程(coroutines)”或者更简单的就写成Coros。</p>
<p>一个线程非常像一个精简的Perl解释器或者说进程：跟完整版的Perl解释器不同的地方就是线程并没有自己的局部变量或者代码的名字空间——这些都是共享的。这就意味着当一个线程修改了某个变量(包括通过引用修改任何值)时，其他线程如果使用同样的变量或者值时会立刻发现这个改变。</p>
<p>协作的意思，就是这些线程在涉及到CPU使用的时候必须相互配合——只有一个线程可以真正拥有CPU，如果有别的线程要用，当前运行的这个就要让出。后来的线程可以显式的调用函数来完成这个工作，也可以隐式的等待资源释放(比如信号量或者IO请求的完成)。这种线程模型在脚本语言(比如python或者ruby)中非常流行，而且我们这个实现比其他语言里的线程要高效的多。</p>
<p>Perl本身在这方面用词非常模糊——线程“thread”或者“ithread”实际上在别的地方又被叫做进程“process”：这个所谓的Perl线程实际上是在用于windows上的UNIX进程仿真代码。这就是为什么我们说他是进程而不是真的线程的原因。最大的区别就是，在进程和ithread线程之间，变量不是共享的。</p>
<p>
</p>
<hr />
<h1><a name="协作线程">协作线程</a></h1>
<p>Coro模块带给大家协作线程。首先你要<code>use</code>它：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
</code></pre></div>
<p>然后要创建线程，你可以使用Coro模块自动导出的<code>async</code>函数：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">async</span> <span class="p">{</span><span class="k">print</span> <span class="s">&quot;hello\n&quot;</span><span class="p">;};</span>
</code></pre></div>
<p>async期望的第一个参数是一个代码块(间接的对象符号)。你也可以传递更多的变量，他们会在执行的时候作为<code>@_</code>数组传递到代码块里面。不过因为是闭包的原因，你可能只需要引用当前可见的任何词法变量都行。</p>
<p>上面那行就已经创建了一个线程，但是如果你保存这行代码到文件里运行，你会发现自己看不到任何输出。</p>
<p>原因就是：虽然你已经创建了线程，这个线程也已经准备好了执行(<code>async</code>会加入到一个所谓的<em>ready queue</em>里)，它却没有得到CPU时间来实际运行代码，因为main函数——实际也是一个一样的线程——一直霸占着CPU直到整个程序运行到结束。所以Coror的线程是协作的，main也要协作起来，要让出CPU来。</p>
<p>要显式的让出CPU，使用<code>cede</code>函数(在其他线程实现里经常被叫做<code>yield</code>)：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
    <span class="n">async</span> <span class="p">{</span>
       <span class="k">print</span> <span class="s">&quot;hello\n&quot;</span><span class="p">;</span>
   <span class="p">};</span>
    <span class="n">cede</span><span class="p">;</span>
</code></pre></div>
<p>运行上面的代码会打印出<code>hello</code>单词然后退出。</p>
<p>看起来不是很有趣，那让我们搞点稍微有趣的程序：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
    <span class="n">async</span> <span class="p">{</span>
        <span class="k">print</span> <span class="s">&quot;async 1\n&quot;</span><span class="p">;</span>
        <span class="n">cede</span><span class="p">;</span>
        <span class="k">print</span> <span class="s">&quot;async 2\n&quot;</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">print</span> <span class="s">&quot;main 1\n&quot;</span><span class="p">;</span>
    <span class="n">cede</span><span class="p">;</span>
    <span class="k">print</span> <span class="s">&quot;main 2\n&quot;</span><span class="p">;</span>
    <span class="n">cede</span><span class="p">;</span>
</code></pre></div>
<p>运行这个程序会打印出如下结果：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">main</span> <span class="mi">1</span>
    <span class="n">async</span> <span class="mi">1</span>
    <span class="n">main</span> <span class="mi">2</span>
    <span class="n">async</span> <span class="mi">2</span>
</code></pre></div>
<p>这个例子很好的说明了它的非局部的跳跃能力：main先打印了第一回，然后释放CPU给其他线程。嗯，确实有其他线程，于是运行并打印“async 1”，然后这个线程也释放掉CPU。这时候只剩下一个线程就是main了，main于是接着运行。</p>
<p>让我们注意这个例子的更多细节部分：<code>async</code>创建一个新线程。所有的新线程开始都处于暂停状态。要运行的话这些线程就需要被放进ready队列，这是<code>async</code>做的第二件事。每次一个线程让出CPU的时候，Coro就会运行一个所谓的调度器<em>scheduler</em>，调度器选择ready队列中的下一个线程，把它从队列里挪出来运行。</p>
<p><code>cede</code>也做两件事情：第一它把一个运行中的线程放进ready队列里；然后它跳转到调度器。这实际上就是让出CPU。不过最终确保了线程被再次运行。</p>
<p>事实上，<code>cede</code>可以这样实现：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">sub </span><span class="nf">my_cede</span> <span class="p">{</span>
        <span class="nv">$</span><span class="nn">Coro::</span><span class="nv">current</span><span class="o">-&gt;</span><span class="n">ready</span><span class="p">;</span>
        <span class="n">schedule</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>这里<code>$Coro::current</code>永远都是包含了当前正在运行的线程，而<code>Coro::schedule</code>则是调度器的调用方法。</p>
<p>那如果不把当前线程放进ready队列里就先调用<code>schedule</code>的效果会怎样呢？很简单，调度器就自动找ready队列里下一个队列。而当前队列因为没放进ready队列里，就会一直沉睡直到有别的因素唤醒它。</p>
<p>下面这个例子，把当前线程记录在一个变量里，创建新线程，这样main线程就沉睡过去了。</p>
<p>然后新创建的线程使用rand来决定是否唤醒main线程，用的是之前变量的<code>ready</code>方法。</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$wakeme</span> <span class="o">=</span> <span class="nv">$</span><span class="nn">Coro::</span><span class="nv">current</span><span class="p">;</span>
    <span class="n">async</span> <span class="p">{</span>
        <span class="nv">$wakeme</span><span class="o">-&gt;</span><span class="n">ready</span> <span class="k">if</span> <span class="mf">0.5</span> <span class="o">&gt;</span> <span class="nb">rand</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">schedule</span><span class="p">;</span>
</code></pre></div>
<p>现在，你运行这个程序，可能会发生两种情况：<code>async</code>线程唤醒了main，程序正常退出；或者没有唤醒main，得到的是如下提示：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">FATAL:</span> <span class="n">deadlock</span> <span class="n">detected</span><span class="o">.</span>
          <span class="n">PID</span> <span class="n">SC</span>  <span class="n">RSS</span> <span class="n">USES</span> <span class="n">Description</span>              <span class="n">Where</span>
     <span class="mi">31976480</span> <span class="o">-</span><span class="n">C</span>  <span class="mi">19</span><span class="n">k</span>    <span class="mi">0</span> <span class="p">[</span><span class="nn">main::</span><span class="p">]</span>                 <span class="p">[</span><span class="n">program:9</span><span class="p">]</span>
     <span class="mi">32223768</span> <span class="n">UC</span>  <span class="mi">12</span><span class="n">k</span>    <span class="mi">1</span>                          <span class="p">[</span><span class="n">Coro</span><span class="o">.</span><span class="n">pm:691</span><span class="p">]</span>
     <span class="mi">32225088</span> <span class="o">--</span> <span class="mi">2068</span>    <span class="mi">1</span> <span class="p">[</span><span class="n">coro</span> <span class="n">manager</span><span class="p">]</span>           <span class="p">[</span><span class="n">Coro</span><span class="o">.</span><span class="n">pm:691</span><span class="p">]</span>
     <span class="mi">32225184</span> <span class="n">N</span><span class="o">-</span>  <span class="mi">216</span>    <span class="mi">0</span> <span class="p">[</span><span class="n">unblock_sub</span> <span class="n">scheduler</span><span class="p">]</span>  <span class="o">-</span>
</code></pre></div>
<p>为什么会这样？嗯，当<code>async</code>线程执行到代码块的最后的时候，他就终止了(通过调用<code>Coro::terminate</code>)，然后重新调用调度器。而之前<code>async</code>线程并没有唤醒main线程，ready队列里没有任何线程可用，程序无法继续了。所以当这里明明有线程<em>可以</em>运行(main)却没有<em>ready</em>，Coro最终得到了一个<em>死锁</em>信号——通常这时候你会看到一个所有线程的列表来帮你追踪问题。</p>
<p>然而现在有个非常重要的场景，<em>就是</em>事实上可能确实没有线程是ready的，但在一个事件驱动的程序里，程序依然可以前进。在这种程序里，某些线程肯尼个在等待一个外部事件，比如超时，比如通过socket到达的数据流。</p>
<p>这种场景下，死锁就不是很有用了。这下有个模块叫<a href="/Coro/AnyEvent.html">the Coro::AnyEvent manpage</a>用来集成线程到事件循环里。它配置Coro使得在这种情况下coro并不返回一个错误信息然后<code>die</code>掉，而是继续运行一个事件循环以期待收到哪个事件可以唤醒某些线程。</p>
<p>
</p>
<h2><a name="信号量和其他锁">信号量和其他锁</a></h2>
<p>仅仅依靠<code>ready</code>、<code>cede</code>和<code>schedule</code>来同步线程是非常困难的。尤其是如果同时有很多线程是ready状态的时候。Coro支持一些原语来帮助你更简单的同步线程。第一个就是<a href="/Coro/Semaphore.html">the Coro::Semaphore manpage</a>模块，它实现了信号量计数(二进制的信号量则是<a href="/Coro/Signal.html">the Coro::Signal manpage</a>模块，同样的还有<a href="/Coro/SemaphoreSet.html">the Coro::SemaphoreSet manpage</a>和<a href="/Coro/RWLock.html">the Coro::RWLock manpage</a>模块)。</p>
<p>信号量计数，某种意义上就是存储一个资源的计数。你可以通过调用<code>-&gt;down</code>方法来删除、分配、预留一个资源，这个方法会减去一个计数；同样调用<code>-&gt;add</code>方法可以添加或释放一个资源，这又增加一个计数。如果计数器值为<code>0</code>，<code>-&gt;down</code>方法就没法再减——也就是说被锁住了——线程就必须等待到计数器重新可用为止。</p>
<p>下面是例子：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$sem</span> <span class="o">=</span> <span class="k">new</span> <span class="nn">Coro::</span><span class="n">Semaphore</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">#初始化的信号是锁住的</span>
    <span class="n">async</span> <span class="p">{</span>
        <span class="k">print</span> <span class="s">&quot;unlocking semaphore\n&quot;</span><span class="p">;</span>
        <span class="nv">$sem</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">print</span> <span class="s">&quot;trying to lock semaphore\n&quot;</span><span class="p">;</span>
    <span class="nv">$sem</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">;</span>
    <span class="k">print</span> <span class="s">&quot;we got it!\n&quot;</span><span class="p">;</span>
</code></pre></div>
<p>这个程序创建一个<em>锁住</em>的信号(计数器为<code>0</code>)并且尝试锁住他(通过<code>down</code>方法减计数)。因为信号量已经耗尽，main线程会被阻塞住直到信号量恢复可用。</p>
<p>这样CPU就被转给了其他可读的线程，这里是用<code>async</code>创建的那个解锁信号量的线程(并且随即就终止了自己)。</p>
<p>既然信号量恢复了，main也就锁住他然后继续执行打印“we got it!”。</p>
<p>信号量计数最常用的地方是锁资源，或者说在使用和访问某个资源时排他。比如，假设有一个很耗内存的函数。你不想让多个线程同时调用这个函数，你可以这样写：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">my</span> <span class="nv">$lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nn">Coro::</span><span class="n">Semaphore</span><span class="p">;</span> <span class="c1">#初始化未锁，默认是1</span>
    <span class="k">sub </span><span class="nf">costly_function</span> <span class="p">{</span>
        <span class="nv">$lock</span><span class="o">-&gt;</span><span class="n">down</span><span class="p">;</span> <span class="c1">#引入锁</span>
        <span class="c1">#进行其他操作</span>
        <span class="nv">$lock</span><span class="o">-&gt;</span><span class="n">up</span><span class="p">;</span> <span class="c1">#解锁</span>
    <span class="p">}</span>
</code></pre></div>
<p>不管有多少线程调用<code>costly_function</code>，只有一个可以运行他的代码块，其他的都在<code>down</code>调用时阻塞。如果你想限定的并发执行是5个，那就创建信号量的时候指定初始值为<code>5</code>.</p>
<p>为什么提到“操作块”？再次强调，Coro的线程是协作的：<code>costly_function</code>不释放CPU，所有的线程都不会运行。如果函数一直不释放，就显得锁有点多余了，不过在和外面的世界打交道的时候，这种情况太罕见了。</p>
<p>现在想想如果代码在<code>down</code>后，<code>up</code>前就<code>die</code>掉了。这导致信号量保持在一个锁的状态，这应该不会是你想要的——所以如果可能失败的地方，都把调用用<code>eval {}</code>包起来。</p>
<p>所以通常你希望在不管是正常还是异常的时候都释放锁的话，这里有个guard方法可能比较有用：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">my</span> <span class="nv">$lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nn">Coro::</span><span class="n">Semaphore</span><span class="p">;</span> <span class="c1">#初始化时未锁定</span>
    <span class="k">sub </span><span class="nf">costly_function</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$guard</span> <span class="o">=</span> <span class="nv">$lock</span><span class="o">-&gt;</span><span class="n">guard</span><span class="p">;</span> <span class="c1"># 获取监视</span>
        <span class="o">...</span> <span class="c1"># 开始做需要阻塞的动作</span>
    <span class="p">}</span>
</code></pre></div>
<p>这个<code>guard</code>方法<code>down</code>掉信号量并返回一个所谓的guard对象。看起来这个对象除了有个引用外啥都不干，不过当所有的引用都完成，比如<code>costly_function</code>返回或抛出异常，它会自动的调用<code>up</code>恢复信号量，绝对不会忘掉滴。哪怕线程收到别的线程发来的<code>cancel</code>命令。</p>
<p>信号量和锁的介绍到此结束。除了<a href="/Coro/Semaphore.html">the Coro::Semaphore manpage</a>和<a href="/Coro/Signal.html">the Coro::Signal manpage</a>，还有读写锁的<a href="/Coro/RWLock.html">the Coro::RWLock manpage</a>和信号集<a href="/Coro/SemaphoreSet.html">the Coro::SemaphoreSet manpage</a>。他们都有自己的文档可查。</p>
<p>
</p>
<h2><a name="频道">频道</a></h2>
<p>信号量很不错，但通常你可能希望通过交换数据来进行通信。当然，你可以继续用锁、数组来通信，不过这里还有更有用的线程间通信抽象模块:<a href="/Coro/Channel.html">the Coro::Channel manpage</a>。频道是UNIX管道的Coro等价实现(也非常接近AmigaOS的消息端口)——你可以从一段放进去东西，然后从另一头读取出来。</p>
<p>下面是一个简单的例子，创建一个线程然后发送数字给它。然后这个线程计算这个数字的平方，通过另一个频道返回给main线程。</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$calculate</span> <span class="o">=</span> <span class="k">new</span> <span class="nn">Coro::</span><span class="n">Channel</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$result</span>    <span class="o">=</span> <span class="k">new</span> <span class="nn">Coro::</span><span class="n">Channel</span><span class="p">;</span>
    <span class="n">async</span> <span class="p">{</span>
      <span class="c1"># 无限循环</span>
        <span class="k">while</span> <span class="p">()</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">$num</span> <span class="o">=</span> <span class="nv">$calculate</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">;</span> <span class="c1">#获取数字</span>
            <span class="nv">$num</span> <span class="o">**=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">#计算平方</span>
            <span class="nv">$result</span><span class="o">-&gt;</span><span class="n">put</span> <span class="p">(</span><span class="nv">$num</span><span class="p">);</span> <span class="c1">#推进结果队列</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">77</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$calculate</span><span class="o">-&gt;</span><span class="n">put</span> <span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
        <span class="k">print</span> <span class="s">&quot;$_ ** 2 = &quot;</span><span class="p">,</span> <span class="nv">$result</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>得到结果是：</p>
<div class="highlight"><pre><code class="perl">    <span class="mi">1</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="mi">5</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">25</span>
    <span class="mi">10</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="mi">77</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">5929</span>
</code></pre></div>
<p>这里面<code>get</code>和<code>put</code>方法都会阻塞当前线程：<code>get</code>首先检查是否<em>有</em>数据可用，没有就阻塞到数据到达为止。<code>put</code>同样，在频道到“最大容量”的时候阻塞。你不可能存储超过这个特定值的项目，这个值可以再创建频道的时候设置。</p>
<p>在上面的例子中，<code>put</code>不会阻塞，因为频道的默认容量是很高的。所以for循环首先put数据到频道里，然后开始试图<code>get</code>结果。这时候因为async线程还没有put东西出来(第一次迭代的时候他还没运行)，result频道是空的，所以main线程在这里阻塞住了。</p>
<p>这时候唯一一个可运行的线程就是算平方的这个，于是它会被唤醒，<code>get</code>数据，然后计算平方，put到result频道，就此唤醒main线程，然后他继续运行，唤醒其他线程进入ready队列，就这样。</p>
<p>只有当async线程是从calculate频道<code>get</code>下一个数字的时候，他才会阻塞住(因为现在这个频道里没数据)然后main线程开始继续运行。依次类推。</p>
<p>这说明了Coro的一个总体原则：一个线程<em>只</em>在万不得已的时候才会阻塞。不管是Coro模块本身还是他的任一子模块，都是如此。因为他们在等待某些事件的发生。</p>
<p>不过小心了：当多个线程往<code>$calculate</code>放数据然后从<code>$result</code>里读出来的时候，他们可分不清楚谁是谁的。解决办法是用信号量，或者不单单发送数字，也发送自己专属的result频道。</p>
<p>
</p>
<h2><a name="什么是我的_什么是我们的_">什么是我的，什么是我们的？</a></h2>
<p>到底什么构成了线程？显然它包含有一个当前的执行点。不那么显然的，它还得有局部变量。是的，每个线程都要自己的一组局部变量。</p>
<p>想知道为什么这点是必须的么，看看下面这个例子吧：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
    <span class="k">sub </span><span class="nf">printit</span> <span class="p">{</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$string</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
        <span class="n">cede</span><span class="p">;</span>
        <span class="k">print</span> <span class="nv">$string</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">async</span> <span class="p">{</span> <span class="n">printit</span> <span class="s">&quot;Hello, &quot;</span> <span class="p">};</span>
    <span class="n">async</span> <span class="p">{</span> <span class="n">printit</span> <span class="s">&quot;World!\n&quot;</span> <span class="p">};</span>
    <span class="n">cede</span><span class="p">;</span> <span class="n">cede</span><span class="p">;</span>
</code></pre></div>
<p>上面的代码最终打印的是<code>Hello, World!\n</code>。如果<code>printit</code>没有自己每个线程独立的<code>$string</code>变量，那打印的结果应该是<code>World!\nWorld!\n</code>。这绝对不是你想要的，而且会给线程的使用造成极大的麻烦。</p>
<p>为了让事情变的更顺利些，有不少东西都是线程独立的：</p>
<dl>
<dt><strong><a name="________和正则表达式的捕获变量________1__2等等" class="item">$_，@_，$@和正则表达式的捕获变量，$&amp;，%+，$1，$2等等</a></strong></dt>
<dd>
<p><code>$_</code>用于局部变量，每个线程都是独立的(<code>$1</code>，<code>$2</code>之类的也一样)；</p>
<p><code>@_</code>包括了参数，类似词法变量，也必须是线程独立的；</p>
<p><code>$@</code>不那么必须，但是独立的话会很好用。</p>
</dd>
<dt><strong><a name="__和默认的输出文件句柄" class="item">$/和默认的输出文件句柄</a></strong></dt>
<dd>
<p>线程在做IO的时候经常是阻塞的，而<code>$/</code>就是在读取每行的时候起作用，如果它是个共享变量，事情会很不方便。
默认输出文件句柄(参见<code>select</code>)的情况比较复杂：有时候全局的好，有时候线程独立的好。不过看起来后面这种情况更多一些，所以还是线程独立的了。</p>
</dd>
<dt><strong><a name="_sig___die___和_sig___warn___" class="item">$SIG{__DIE__}和$SIG{__WARN__}</a></strong></dt>
<dd>
<p>如果这两不是线程独立的话，下面这种常见的构造就没法协程切换了。</p>
<div class="highlight"><pre><code class="perl">        <span class="nb">eval</span> <span class="p">{</span>
            <span class="nb">local</span> <span class="nv">$SIG</span><span class="p">{</span><span class="bp">__DIE__</span><span class="p">}</span> <span class="o">=</span> <span class="k">sub </span><span class="p">{</span> <span class="o">...</span> <span class="p">};</span>
            <span class="o">...</span>
        <span class="p">};</span>
</code></pre></div>
<p>既然异常处理是线程独立的，那么这些变量自然也需要如此了。</p>
</dd>
<dt><strong><a name="一些其他的深奥的玩意儿" class="item">一些其他的深奥的玩意儿</a></strong></dt>
<dd>
<p>比如说<code>$^H</code>变量就是线程独立的。很多类似这样额外的线程独立的东西不会直接被Perl访问，你通常不会注意到这些。</p>
</dd>
</dl>
<p>其他的东西都是线程间共享的。比如全局变量<code>$a</code>和<code>$b</code>。当你使用sort的时候，这两个变量变成特殊变量，然后如果你在排序的时候切换线程，或许结果会让你大吃一惊的。</p>
<p>另外一些<code>$!</code>，errno，<code>$.</code>，输入行号，<code>$,</code>，<code>$\</code>，<code>$"</code>和很多很多其他的特殊变量都是共享的。</p>
<p>虽然有些时候把他们局部化也不错，但一是他们用的不广泛，二是局部化的工作蛮困难的。</p>
<p>总之，如果未来发现哪个共享变量给Coro造成问题了，我们就可能把它改成线程独立的。</p>
<p>
</p>
<h2><a name="调试">调试</a></h2>
<p>有时候查出每个线程在做什么或者哪个线程出现在什么地方是蛮有用的。<a href="/Coro/Debug.html">the Coro::Debug manpage</a>模块就有这么一个方法，让你打印出一个和ps命令结果很像的列表——你可以在Coro检测到死锁前就查看。</p>
<p>使用方法如下：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="nn">Coro::</span><span class="n">Debug</span><span class="p">;</span>
    <span class="nn">Coro::Debug::</span><span class="n">command</span> <span class="s">&quot;ps&quot;</span><span class="p">;</span>
</code></pre></div>
<p>还记得上面求平方的例子吧？在<code>$calculate-&gt;get</code>后面运行ps方法，然后就会输出类似这样的结果：</p>
<pre>
        PID SC  RSS USES Description              Where
    8917312 -C  22k    0 [main::]                 [introscript:20]
    8964448 N-  152    0 [coro manager]           -
    8964520 N-  152    0 [unblock_sub scheduler]  -
    8591752 UC  152    1                          [introscript:12]
   11546944 N-  152    0 [EV idle process]        -
</pre>
<p>有趣的是后台运行的线程比我们想象中的要多。除掉这些额外的线程，main线程的pid是<code>8917312</code>，而<code>async</code>启动的线程的pid是<code>8591752.</code></p>
<p>后者也是唯一一个没有描述的线程，因为我们没有设置这个。设置方法就是<code>$Coro::current-&gt;{desc}</code>；</p>
<div class="highlight"><pre><code class="perl">    <span class="n">async</span> <span class="p">{</span>
        <span class="nv">$</span><span class="nn">Coro::</span><span class="nv">current</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">desc</span><span class="p">}</span> <span class="o">=</span> <span class="s">&quot;cruncher&quot;</span><span class="p">;</span>
        <span class="o">...</span>
    <span class="p">};</span>
</code></pre></div>
<p>在调试程序或者使用<a href="/Coro/Debug.html">the Coro::Debug manpage</a>的交互式shell的时候这个可能比较有用。</p>
<p>
</p>
<hr />
<h1><a name="真实世界里的事件循环">真实世界里的事件循环</a></h1>
<p>Coro强烈希望运行在一个事件驱动的程序里。事实上真实情况的Coro程序都是结合事件驱动技术或者多线程技术的。利用Coro也很方便就在这两个世界里做到很好的效果。</p>
<p>Coro可以通过<em>AnyEvent</em>模块(查看<a href="/Coro/AnyEvent.html">the Coro::AnyEvent manpage</a>的更多细节)自动集成到任何事件循环里，也可以接受<em>EV</em>和<em>Event</em>模块的特殊方法。</p>
<p>下面是一个简单的finger客户端，可以使用任何<em>AnyEvent</em>的事件循环：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">Coro::</span><span class="n">Socket</span><span class="p">;</span>
    <span class="k">sub </span><span class="nf">finger</span> <span class="p">{</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$user</span><span class="p">,</span> <span class="nv">$host</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="k">new</span> <span class="nn">Coro::</span><span class="n">Socket</span> <span class="n">PeerHost</span> <span class="o">=&gt;</span> <span class="nv">$host</span><span class="p">,</span> <span class="n">PeerPort</span> <span class="o">=&gt;</span> <span class="s">&quot;finger&quot;</span>
            <span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;$user\@$host: $!&quot;</span><span class="p">;</span>
        <span class="k">print</span> <span class="nv">$fh</span> <span class="s">&quot;$user\n&quot;</span><span class="p">;</span>
        <span class="k">print</span> <span class="s">&quot;$user\@$host: $_&quot;</span> <span class="k">while</span> <span class="o">&amp;</span><span class="ow">lt</span><span class="p">;</span><span class="nv">$fh</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">print</span> <span class="s">&quot;$user\@$host: done\n&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">#验证几个账号</span>
    <span class="k">for</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">async</span> <span class="p">{</span> <span class="n">finger</span> <span class="s">&quot;abc&quot;</span><span class="p">,</span> <span class="s">&quot;cornell.edu&quot;</span> <span class="p">}),</span>
        <span class="p">(</span><span class="n">async</span> <span class="p">{</span> <span class="n">finger</span> <span class="s">&quot;sebbo&quot;</span><span class="p">,</span> <span class="s">&quot;world.std.com&quot;</span> <span class="p">}),</span>
        <span class="p">(</span><span class="n">async</span> <span class="p">{</span> <span class="n">finger</span> <span class="s">&quot;trouble&quot;</span><span class="p">,</span> <span class="s">&quot;noc.dfn.de&quot;</span> <span class="p">}),</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="nv">$_</span><span class="o">-&gt;</span><span class="nb">join</span><span class="p">;</span> <span class="c1">#等待结果</span>
    <span class="p">}</span>
</code></pre></div>
<p>这里又有些新东西。首先是<a href="/Coro/Socket.html">the Coro::Socket manpage</a>。这个模块的工作方式和<a href="/IO/Socket/INET.html">the IO::Socket::INET manpage</a>一样，除了它是协程的。也就是说，<a href="/IO/Socket/INET.html">the IO::Socket::INET manpage</a>在等待网络的时候会阻塞整个进程——就是说说所有线程都被阻塞了，这显然是不可取的。</p>
<p>另一方面，<a href="/Coro/Socket.html">the Coro::Socket manpage</a>却知道在等待网络的时候让出CPU给其他线程。这使得并发执行变得可能了。</p>
<p>另一个新东西是<code>join</code>方法：在这个例子里我们想要的就是启动三个<code>async</code>线程然后完成工作后退出。这可以用信号量计数，但是直接同步等待他们<code>terminate</code>更简单一些，这正是<code>join</code>方法做的。</p>
<p>无所谓三个<code>async</code>是不是按照他们<code>join</code>的顺序结束的——当线程还在运行的时候，join单纯就是等待。如果线程终止，他就获取返回值。</p>
<p>如果你之前有事件驱动编程的经验，你会发现上面的程序不太遵循常规的模式，也就是开始一些工作，然后运行事件驱动比如<code>EV::loop</code>。</p>
<p>事实上，重要程序都遵从这个模式，使用Coro也一样，所以和EV一起时Coro程序看起来是这样的：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">EV</span><span class="p">;</span>
    <span class="k">use</span> <span class="n">Coro</span><span class="p">;</span>
    <span class="c1">#开始协程或者事件句柄</span>
    <span class="nn">EV::</span><span class="n">loop</span><span class="p">;</span> <span class="c1">#然后循环</span>
</code></pre></div>
<p>还有，为了调试，经常写成这样：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">EV</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">Coro::</span><span class="n">Debug</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$shell</span> <span class="o">=</span> <span class="n">new_unix_server</span> <span class="nn">Coro::</span><span class="n">Debug</span> <span class="s">&quot;/tmp/myshell&quot;</span><span class="p">;</span>
    <span class="nn">EV::</span><span class="n">loop</span><span class="p">;</span> <span class="c1">#循环</span>
</code></pre></div>
<p>这个程序在运行的同时会在UNIX套接字<em class="file">/tmp/myshell</em>上创建一个交互式shell。你可以用<em class="file">socat</em>程序访问它：</p>
<pre>
    # socat readline /tmp/myshell
    coro debug session. use help for more info
    &gt; ps
            PID SC  RSS USES Description              Where
      136672312 RC  19k 177k [main::]                 [myprog:28]
      136710424 -- 1268   48 [coro manager]           [Coro.pm:349]
    &gt; help
    ps [w|v]                show the list of all coroutines (wide, verbose)
    bt &lt;pid&gt;                show a full backtrace of coroutine &lt;pid&gt;
    eval &lt;pid&gt; &lt;perl&gt;       evaluate &lt;perl&gt; expression in context of &lt;pid&gt;
    trace &lt;pid&gt;             enable tracing for this coroutine
    untrace &lt;pid&gt;           disable tracing for this coroutine
    kill &lt;pid&gt; &lt;reason&gt;     throws the given &lt;reason&gt; string in &lt;pid&gt;
    cancel &lt;pid&gt;            cancels this coroutine
    ready &lt;pid&gt;             force &lt;pid&gt; into the ready queue
    &lt;anything else&gt;         evaluate as perl and print results
    &lt;anything else&gt; &amp;       same as above, but evaluate asynchronously
                            you can use (find_coro &lt;pid&gt;) in perl expressions
                            to find the coro with the given pid, e.g.
                            (find_coro 9768720)-&gt;ready
    loglevel &lt;int&gt;          enable logging for messages of level &lt;int&gt; and lower
    exit                    end this session</pre>
<p>好吧，微软用户可以使用<code>new_tcp_server</code>构造器。</p>
<p>
</p>
<h2><a name="真实世界里的文件操作">真实世界里的文件操作</a></h2>
<p>磁盘IO一般比网络IO快很多，但可能占用很长时间，这期间CPU本可以做其他的事情，现在却只能做一样。</p>
<p>幸运的是，CPAN上的<a href="/IO/AIO.html">the IO::AIO manpage</a>模块允许你把这些IO调用移到后台，而在前台做更有用的工作。这是基于事件/回调的，不过Coro很好的包装了它，叫做<a href="/Coro/AIO.html">the Coro::AIO manpage</a>模块，你可以在线程里很自然的使用它的函数：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">Fcntl</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">Coro::</span><span class="n">AIO</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$fh</span> <span class="o">=</span> <span class="n">aio_open</span> <span class="s">&quot;$filename~&quot;</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">,</span> <span class="mo">0600</span>
        <span class="ow">or</span> <span class="nb">die</span> <span class="s">&quot;$filename~: $!&quot;</span><span class="p">;</span>
    <span class="n">aio_write</span> <span class="nv">$fh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">$data</span><span class="p">),</span> <span class="nv">$data</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">aio_fsync</span> <span class="nv">$fh</span><span class="p">;</span>
    <span class="n">aio_close</span> <span class="nv">$fh</span><span class="p">;</span>
    <span class="n">aio_rename</span> <span class="s">&quot;$filename~&quot;</span><span class="p">,</span> <span class="s">&quot;$filename&quot;</span><span class="p">;</span>
</code></pre></div>
<p>上面创建一个新文件，写入数据，同步到磁盘，然后自动的改成新的副本。</p>
<p>
</p>
<h2><a name="翻转控制____唤醒函数">翻转控制 —— 唤醒函数</a></h2>
<p>最后我说说翻转控制。这个控制指谁通知谁，谁在程序的控制内。在这个程序中，main程序就在控制中，并且传递这个控制给他调用的所有函数：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">LWP</span><span class="p">;</span>
    <span class="c1">#转移控制给get</span>
    <span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="n">get</span> <span class="s">&quot;http://example.org/&quot;</span><span class="p">;</span>
    <span class="c1">#控制权返回给我们了</span>
    <span class="k">print</span> <span class="nv">$res</span><span class="p">;</span>
</code></pre></div>
<p>当你切换到事件驱动程序的时候，不再是“我调用它”，“他调用我”这样——而是标题所说的翻转控制：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="nn">AnyEvent::</span><span class="n">HTTP</span><span class="p">;</span>
    <span class="c1">#不用交出控制权太久，http_get立刻返回了</span>
    <span class="n">http_get</span> <span class="s">&quot;http://example.org/&quot;</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
        <span class="k">print</span> <span class="nv">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">};</span>
    <span class="c1">#我们继续拥有控制权并且可以做其他事情了</span>
</code></pre></div>
<p>基于事件的编程很好，不过有时间它只是更简单的码字罢了，因为不用回调可以写得很像线性的样式。Coro也提供了一些特殊的函数来减少敲键盘的功夫：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="nn">AnyEvent::</span><span class="n">HTTP</span><span class="p">;</span>
    <span class="c1">#不用交出控制权太久，http_get立刻返回了</span>
    <span class="n">http_get</span> <span class="s">&quot;http://example.org/&quot;</span><span class="p">,</span> <span class="nn">Coro::</span><span class="n">rouse_cb</span><span class="p">;</span>
    <span class="c1">#我们继续拥有控制权并且可以做其他事情了</span>
    <span class="c1">#相当于等待</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$res</span><span class="p">)</span> <span class="o">=</span> <span class="nn">Coro::</span><span class="n">rouse_wait</span><span class="p">;</span>
</code></pre></div>
<p><code>Coro::rouse_cb</code>创建并返回一个特殊的回调。你可以把它传递给任意希望有回调的函数。</p>
<p><code>Coro::rouse_wait</code>等待(阻塞当前线程)最近创建的回调被调用，然后返回传给它的所有数据。</p>
<p>这两个函数允许你<em>机械的</em>翻转控制，由绝大多数基于事件的库使用的"基于回调"的样式变成"阻塞式"的样子，绝对如你所愿。</p>
<p>范例很简单，原先这样写：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">some_func</span> <span class="o">...</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
        <span class="k">my</span> <span class="nv">@res</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
        <span class="o">...</span>
    <span class="p">};</span>
</code></pre></div>
<p>现在这样写：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">some_func</span> <span class="o">...</span><span class="p">,</span> <span class="nn">Coro::</span><span class="n">rouse_cb</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@res</span> <span class="o">=</span> <span class="nn">Coro::</span><span class="n">rouse_wait</span><span class="p">;</span>
    <span class="o">...</span>
</code></pre></div>
<p>基于回调的接口很丰富，而这个唤醒函数允许你用一种更方便的方式来使用它们。</p>
<p>
</p>
<hr />
<h1><a name="其他模块">其他模块</a></h1>
<p>这篇介绍里只是提到了很少的几个方法和模块。Coro有很多其他的函数(参见<em>Coro</em>的文档)和模块(在<em>Coro</em>文档的<code>SEE ALSO</code>区域)。</p>
<p>值得注意的有<a href="/Coro/LWP.html">the Coro::LWP manpage</a> (并发LWP请求，不过单纯论HTTP的话，<a href="/AnyEvent/HTTP.html">the AnyEvent::HTTP manpage</a>是更好的替代选择)，<a href="/Coro/BDB.html">the Coro::BDB manpage</a>，当你需要异步数据库的时候可用，<a href="/Coro/Handle.html">the Coro::Handle manpage</a>，当你需要在协程中使用文件句柄(通常访问<code>STDIN</code>和<code>STDOUT</code>)和<a href="/Coro/EV.html">the Coro::EV manpage</a>，优化的<em>EV</em>接口(<a href="/Coro/AnyEvent.html">the Coro::AnyEvent manpage</a>自动使用这个)。</p>
<p>有很多Coro相关的模块(参见i<a href="http://search.cpan.org/search?query=Coro&amp;mode=module">http://search.cpan.org/search</a>)可能对解决你的问题有帮助。而且因为Coro和AnyEvent结合的很好，你也很容易就可以适应现有的AnyEvent模块(参见<a href="http://search.cpan.org/search?query=AnyEvent&amp;mode=module">http://search.cpan.org/search</a>)。</p>
<p>
</p>
<hr />
<h1><a name="作者">作者</a></h1>
<pre>
    Marc Lehmann &lt;schmorp@schmorp.de&gt;
    <a href="http://home.schmorp.de/">http://home.schmorp.de/</a>
</pre>
      <a href="/2012/06/29/coro-intro" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/06/14/intro-stf" title="STF介绍" rel="bookmark">STF介绍</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-06-14 00:00:00 +0800">14 Jun 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>STF项目，全称&rdquo;<a href="http://en.wikipedia.org/wiki/Professional_wrestling_holds#STF">Stepover Toehold Facelock</a>&ldquo;，原因是项目发起人喜欢这个动作，我勒个去……当然作者也给它找了个靠谱一点的解释，叫STorage Farm。</p>
<p>目前主要是日本三大门户之一<a href="http://blog.livedoor.com/">livedoor</a>和<a href="http://tou.ch/">loctouch</a>在使用。livedoor称其图片集群规模在70TB，400,000,000个对象(1,300,000,000个复制份)，高峰流量带宽400Mbps。按照这个数据计算，大概图片的平均大小是50KB的样子。</p>
<p>perl系原先已经有一个非常著名的分布式文件系统，叫MogileFS，作者说STF与MogileFS的不同时说到：</p>
<ol>
  <li>
    <p>STF整个是基于HTTP的，而且是PSGI的。这里我理解MogileFS内部是HTTP的，但是fs对外的api是非http的。而且因为时间较早的原因，mogile内部的http服务器是Danga的socket基础的perlbal，现在perl世界都转向使用psgi了。</p>
  </li>
  <li>
    <p>代码简单。MogileFS有28000行代码，STF只有6000行。我觉得这里因为mogile全套除了metadata用了mysql之外，全都是perl实现。而STF中采用了Q4M、mysql、memcached、nginx/apache等多种外部组件，加上psgi本身也很省代码。</p>
  </li>
</ol>
<p>关于实际工作流程，作者坦言和MogileFS基本一样。</p>
<ol>
  <li>
    <p>dispatcher，类似mogile里的tracker，主要配置内容就是数据库连接。前端还有个proxy，要点是处理X-Reproxy-URL这个HTTP的header。STF中使用apache+mod_reproxy或者nginx，mogile中使用perlbal。</p>
  </li>
  <li>
    <p>job queue，STF中使用Q4M或者theSchwartz，mogile中使用gearmand。用来通知worker进行replica等。</p>
  </li>
  <li>
    <p>MySQL，存储除了文件实际内容以外的所有数据，这里STF和mogile一致。</p>
  </li>
  <li>
    <p>memcached，为了提高性能，给mysql做缓存的。这里mogile没有，不过很容易在调优时改造加入。</p>
  </li>
  <li>
    <p>admin interface，mogile是cli端的，STF是psgi的web端。</p>
  </li>
  <li>
    <p>worker，做数据的replica，delete等，从Q4M里取任务。这个STF和mogile类似。</p>
  </li>
  <li>
    <p>Storage，支持CRUD即GET/PUT/DELETE的HTTP服务器即可。mogile里是mogstored，STF里是storage.psgi。同样都要在admin interface里添加管理。</p>
  </li>
</ol>
<p>然后介绍一些概念：</p>
<ol>
  <li>
    <p>object，一个url对象，因为STF和mogile一样设计目的是小图片，所以一般来说不会有超过大小的分多块的文件(原文a piece of data)，mogile里cli专门针对大于64M的文件要指定&ndash;largefile一样。</p>
  </li>
  <li>
    <p>bucket，一个逻辑上的group。object必须存在于bucket里。这里stf和mogile有些类似又别扭的地方。mogile中，逻辑顺序是这样的：domain-&gt;class-&gt;keyvalue；stf中，逻辑顺序是这样的：bucket-&gt;object。所以一个完整的GET请求会看到object的url是两层目录的样子。</p>
  </li>
  <li>
    <p>entity，也就是replica的份数。</p>
  </li>
</ol>
<p>然后是CRUD的协议：</p>
<ol>
  <li>
    <p>创建bucket：PUT /bucket HTTP/1.0即可，成功创建返回状态码201，已存在返回204，url格式不对返回400，其他返回500。因为apache的mod_reproxy模块不支持chunk，所以使用HTTP/1.0协议，不清楚nginx的话，是否可以用HTTP/1.1，不过我记得有文章说在处理小图片的时候，其实HTTP/1.0比HTTP/1.1更好，因为浏览器可以开更多并发连接。</p>
  </li>
  <li>
    <p>删除bucket：DELETE /bucket HTTP/1.0\r\n\X-STF-Recursive-Delete: 1\r\n\r\n即可。这个多余出来的header可以指定删除bucket里所有的文件，否则会只清楚bucket保留文件，但是还不清楚这种情况下能否访问到这些孤儿文件呢？</p>
  </li>
  <li>
    <p>创建object：PUT /bucket/path/to/my.png HTTP/1.0&hellip;即可。有两个附加的header，一个叫X-STF-Replication-Count，一个叫X-STF-Consistency。前者在保存好第一份之后返回响应，然后通过Q4M让worker开始replica完指定的其他份数；后者则等到指定的份数都完成后才返回响应。</p>
  </li>
  <li>
    <p>获取object：GET /bucket/path/to/my.png HTTP/1.0即可。这里可以使用If-Modified-Since，也可以只使用HEAD请求。如果bucket不存在，响应状态码是500。</p>
  </li>
  <li>
    <p>修改object：POST /bucket/path/to/my.png HTTP/1.0即可。不清楚为什么会提供modify功能。一般分布式系统都是搞追加而已。还需要测试的一个是如果直接POST新object会如何？</p>
  </li>
  <li>
    <p>重命名object： MOVE /bucket/path/to/my.png HTTP/1.0\r\nX-STF-Move-Destination: /newbucket/newpath/to/my.png即可。又是一个古怪的需求。另外不清楚这两个是真修改了呢，还是在mysql里修改标记了而已。</p>
  </li>
</ol>
      <a href="/2012/06/14/intro-stf" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/06/13/use-redis-and-grok-pattern-for-logstash" title="【Logstash系列】使用Redis并自定义Grok匹配" rel="bookmark">【Logstash系列】使用Redis并自定义Grok匹配</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-06-13 00:00:00 +0800">13 Jun 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#logstash-ref" title="logstash" rel="category tag">logstash</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>之前提到，用RabbitMQ作为消息队列。但是这个东西实在太过高精尖，不懂erlang不会调优的情况下，很容易挂掉——基本上我这里试验结果跑不了半小时日志传输就断了。所以改用简单易行的redis来干这个活。</p>
<p>之前的lib里，有inputs/redis.rb和outputs/redis.rb两个库，不过output有依赖，所以要先gem安装redis库，可以修改Gemfile，取消掉相关行的注释，搜redis即可。</p>
<p>然后修改agent.conf：</p>
<div class="highlight"><pre><code class="ruby"><span class="n">input</span> <span class="p">{</span>
  <span class="n">file</span> <span class="p">{</span>
    <span class="n">type</span> <span class="o">=&gt;</span> <span class="s2">&quot;nginx&quot;</span>
    <span class="n">path</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;/var/log/nginx/access.log&quot;</span> <span class="o">]</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">output</span> <span class="p">{</span>
  <span class="n">redis</span> <span class="p">{</span>
    <span class="n">host</span> <span class="o">=&gt;</span> <span class="s2">&quot;MyHome-1.domain.com&quot;</span>
    <span class="n">data_type</span> <span class="o">=&gt;</span> <span class="s2">&quot;channel&quot;</span>
    <span class="n">key</span> <span class="o">=&gt;</span> <span class="s2">&quot;nginx&quot;</span>
    <span class="n">type</span> <span class="o">=&gt;</span> <span class="s2">&quot;nginx&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>启动方式还是一样。</p>
<p>接着修改server.conf:</p>
<div class="highlight"><pre><code class="ruby"><span class="n">input</span> <span class="p">{</span>
  <span class="n">redis</span> <span class="p">{</span>
    <span class="n">host</span> <span class="o">=&gt;</span> <span class="s2">&quot;MyHome-1.domain.com&quot;</span>
    <span class="n">data_type</span> <span class="o">=&gt;</span> <span class="s2">&quot;channel&quot;</span>
    <span class="n">type</span> <span class="o">=&gt;</span> <span class="s2">&quot;nginx&quot;</span>
    <span class="n">key</span> <span class="o">=&gt;</span> <span class="s2">&quot;nginx&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">filter</span> <span class="p">{</span>
  <span class="n">grok</span> <span class="p">{</span>
    <span class="n">type</span> <span class="o">=&gt;</span> <span class="s2">&quot;nginx&quot;</span>
    <span class="n">pattern</span> <span class="o">=&gt;</span> <span class="s2">&quot;%{NGINXACCESS}&quot;</span>
    <span class="n">patterns_dir</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;/usr/local/logstash/etc/patterns&quot;</span><span class="o">]</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">output</span> <span class="p">{</span>
  <span class="n">elasticsearch</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>然后创建Grok的patterns目录，主要就是github上clone下来的那个咯~在目录下新建一个叫nginx的文件，内容如下：</p>
<div class="highlight"><pre><code class="ruby"><span class="no">NGINXURI</span> <span class="sx">%{URIPATH}</span><span class="p">(</span><span class="sc">?:</span><span class="sx">%{URIPARAM}</span><span class="p">)</span><span class="o">*</span>
<span class="no">NGINXACCESS</span> <span class="p">\</span><span class="o">[</span><span class="sx">%{HTTPDATE}</span><span class="p">\</span><span class="o">]</span> <span class="sx">%{NUMBER:code}</span> <span class="sx">%{IP:client}</span> <span class="sx">%{HOSTNAME}</span> <span class="sx">%{WORD:method}</span> <span class="sx">%{NGINXURI:req}</span> <span class="sx">%{URIPROTO}</span><span class="o">/</span><span class="sx">%{NUMBER:version}</span> <span class="sx">%{IP:upstream}</span><span class="p">(</span><span class="ss">:%</span><span class="p">{</span><span class="ss">POSINT</span><span class="p">:</span><span class="n">port</span><span class="p">})?</span> <span class="sx">%{NUMBER:upstime}</span> <span class="sx">%{NUMBER:reqtime}</span> <span class="sx">%{NUMBER:size}</span> <span class="s2">&quot;(%{URIPROTO}://%{HOST:referer}%{NGINXURI:referer}|-)&quot;</span> <span class="sx">%{QS:useragent}</span> <span class="s2">&quot;(%{IP:x_forwarder_for}|-)&quot;</span>
</code></pre></div>
<p>Grok正则的编写，可以参考<a href="https://github.com/logstash/logstash/wiki/Testing-your-Grok-patterns-%28--logstash-1.1.0-and-above-%29">wiki</a>进行测试。</p>
<p>也可以不写配置文件，直接用&ndash;grok-patterns-path参数启动即可。</p>
<p>ps: 考察了一下statsd，发现它也要另存一份数据，放弃掉。转研究Kibana界面和Elasticsearch的分布式。</p>
      <a href="/2012/06/13/use-redis-and-grok-pattern-for-logstash" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/06/10/install-mogilefs" title="MogileFS安装" rel="bookmark">MogileFS安装</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-06-10 00:00:00 +0800">10 Jun 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>纯属凑数的更新，写写安装过程而已。没有调优，没有测评，嗯……</p>
<ul>
  <li>storage Node</li>
</ul>
<div class="highlight"><pre><code class="bash">cpanm MogileFS::Utils MogileFS::Client
<span class="c"># 因为MogileFS::Server的test里会测试mysql、sqlite、pgsql的支持，用不着，直接强制安装就好了</span>
cpanm --force MogileFS::Server
mkdir /etc/mogilefs
cat &gt; /etc/mogilefs/mogstored.conf <span class="s">&lt;&lt;EOF</span>
<span class="s">maxconns = 10000</span>
<span class="s">httplisten = 0.0.0.0:7500</span>
<span class="s">mgmtlisten = 0.0.0.0:7501</span>
<span class="s">docroot=/data/mogstore</span>
<span class="s">EOF</span>
<span class="c"># 不在同一分区的磁盘采用软连接方式建立伪DEV设备</span>
mkdir /data/mogstore/dev170
mkdir /data1/mogstore
ln -s /data1/mogstore /data/mogstore/dev171
</code></pre></div>
<ul>
  <li>Tracker</li>
</ul>
<div class="highlight"><pre><code class="bash">yum install -y mysql-server mysql-devel
cpanm DBI DBD::mysql MogileFS::Utils MogileFS::Client
cpanm --force MogileFS::Server
</code></pre></div>
<div class="highlight"><pre><code class="sql"><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="n">MogileFS</span> <span class="k">DEFAULT</span> <span class="nb">CHARACTER</span> <span class="k">SET</span> <span class="n">utf8</span> <span class="k">COLLATE</span> <span class="n">utf8_bin</span><span class="p">;</span>
<span class="k">grant</span> <span class="k">all</span> <span class="k">on</span> <span class="n">MogileFS</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">&#39;mogile&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span> <span class="n">identified</span> <span class="k">by</span> <span class="s1">&#39;mogile&#39;</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">mysql</span><span class="p">.</span><span class="k">user</span> <span class="k">SET</span> <span class="n">Password</span><span class="o">=</span><span class="n">PASSWORD</span><span class="p">(</span><span class="s1">&#39;newpass&#39;</span><span class="p">)</span> <span class="k">WHERE</span> <span class="k">User</span><span class="o">=</span><span class="s1">&#39;mogile&#39;</span><span class="p">;</span>
<span class="n">FLUSH</span> <span class="k">PRIVILEGES</span><span class="p">;</span>
</code></pre></div>
<div class="highlight"><pre><code class="bash"><span class="c"># 初始化mysql数据库表</span>
mogdbsetup --dbhost<span class="o">=</span>tracker.mogile.com --dbname<span class="o">=</span>MogileFS --dbuser<span class="o">=</span>mogile --dbpass<span class="o">=</span>newpass
mkdir /etc/mogilefs
cat &gt; /etc/mogilefs/mogilefsd.conf <span class="s">&lt;&lt;EOF</span>
<span class="s">db_dsn = DBI:mysql:MogileFS:host=tracker.mogile.com</span>
<span class="s">db_user = mogile</span>
<span class="s">db_pass = mogile</span>
<span class="s">listen = 0.0.0.0:7001</span>
<span class="s">conf_port = 7001</span>
<span class="s">query_jobs = 10</span>
<span class="s">delete_jobs = 1</span>
<span class="s">replicate_jobs = 5</span>
<span class="s">reaper_jobs = 1</span>
<span class="s">EOF</span>
<span class="c"># mogilefsd不能用root启动</span>
useradd mogile
su - mogile -c <span class="s1">&#39;mogilefsd -c /etc/mogilefs/mogilefsd.conf --daemon&#39;</span>
<span class="c"># 添加storage node和相关伪DEV设备信息</span>
mogadm host add mognode17 --ip<span class="o">=</span>10.0.0.17 --port<span class="o">=</span>7500 --status<span class="o">=</span>alive
mogadm device add mognode17 170
mogadm device add mognode17 171
<span class="c"># 添加域和类。文件的key在同一域内是唯一的。同一类可以指定自己的复制份数</span>
mogadm domain add fmn
mogadm class add fmn large --mindevcount<span class="o">=</span>3
mogadm class add fmn small --mindevcount<span class="o">=</span>3
<span class="c"># 检查状态，类似的有mogadm check命令</span>
mogstats --db_dsn<span class="o">=</span><span class="s2">&quot;DBI:mysql:MogileFS:host=tracker.mogile.com&quot;</span> --db_user<span class="o">=</span><span class="s2">&quot;mogile&quot;</span> --db_pass<span class="o">=</span><span class="s2">&quot;mogile&quot;</span> --verbose --stats<span class="o">=</span><span class="s2">&quot;all&quot;</span>
<span class="c"># 插入一个文件做测试</span>
mogtool --debug --trackers<span class="o">=</span>127.0.0.1:7001 --domain<span class="o">=</span>fmn --class<span class="o">=</span>large inject index.html <span class="s2">&quot;index.html&quot;</span>
</code></pre></div>
<ul>
  <li>Fuse</li>
</ul>
<p>这步没搞出来，因为search.cpan.org上的Fuse是0.14版本，cpanm安装居然说无法下载的是0.15版。而MogileFS::Client::Fuse里use的是0.11版……
而且直接下载的Fuse0.14版源码编译还一直通不过make test。。。</p>
<p>最后在github上找到两个资源：
<a href="https://github.com/dpavlin/perl-fuse">Fuse-0.15</a>  <br />
<a href="https://github.com/frett/MogileFS-Fuse">Mogile-Fuse-0.03</a>    </p>
<p>先解决依赖：</p>
<div class="highlight"><pre><code class="bash">yum install -y fuse fuse-devel fuse-libs
cpanm FUSE::Client FUSE::Server Lchown Filesys::Statvfs Unix::Mknod
</code></pre></div>
<p>然后perl Makefile.PL &amp;&amp; make &amp;&amp; make test &amp;&amp; make install即可。
挂载命令是：
mount-mogilefs &ndash;daemon &ndash;tracker 10.0.0.16:7001 /mnt/mogilefs
不过目前为止我挂载上去依然无法使用，输入输出有问题……</p>
      <a href="/2012/06/10/install-mogilefs" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/06/08/intro-trafficserver-ssd-branch-in-taobao" title="淘宝TrafficServer的SSD分支测试与介绍" rel="bookmark">淘宝TrafficServer的SSD分支测试与介绍</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-06-08 00:00:00 +0800">08 Jun 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#cdn-ref" title="cdn" rel="category tag">cdn</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>同事介绍说淘宝有关于trafficserver的一个分支支持SSD的。下来试试。<a href="http://gitorious.org/trafficserver/taobao/commits/tbtrunk_ssd">下载地址</a></p>
<p>官方的ats安装过程很简单，这个分支稍微麻烦一些，因为有些包变成强制依赖了，包括：expat/openssl/pcre等。根据提示安装好再重新编译即可。</p>
<p>表面看几乎没什么差别，就是多了一个storage_ssd.config配置文件。</p>
<p>基础配置项说明网上都有，无外乎就是records.config里的监听，remap.config里的域名，storage.config里的目录。下面说几个比较怪异或者难受的地方：</p>
<ol>
  <li>
    <p>trafficserver极其依赖DNS解析。我在parents.config中定义了多个parents的IP:port后，打开records.config里的debug信息，包括http.*、dns.*、cdn.*和url.*，结果发现ats针对每个url，会在获取完parents后依然去请求dns解析——注意这是在records.config里已经配置了no_dns_just_forward_to_parent为1之后，这种与字面意思严重不一样的结果让我很诧异……</p>
  </li>
  <li>
    <p>由于上面说的parent配置不可行，所以在remap.config中只能使用单个ip的方式回源。这里配置说明一般都说前后域名必须不一样，但是我在debug中没有发现这个逻辑，事实上ats不管这个事情，所谓不能一样，大概是怕本机dns解析回到自己变成loop吧。</p>
  </li>
  <li>
    <p>默认关于内存，是每1GB的磁盘启用1MB的内存。所以如果不指定的话，基本上磁盘的IO会很高很高！而最恶心的地方来了：配置里所有的数值都是以Byte为单位的，尼玛写4GB内存写的跟裹脚布一样长啊！</p>
  </li>
</ol>
<p>然后说测试。在性能方面，ats还是不错的。基本上我在单机走lo口，用http_load做压测，都是http_load先到瓶颈——因为http_load只用单核CPU。使用-p 1000的参数测试（因为最大只让开到1020），同机上的squid2.6.23、trafficserver和trafficserver-ssd三种，rps分别在6000，19000和14000的样子。first-bytes msec在10，4，1的样子，cpu在150％，25％，25％的样子。</p>
<p>以上是只用了4个域名每个域名1个url的小样本测试。实际运行起来应该不会这么高。</p>
<p>另：在需要dns解析的时候，14000的rps降到只有300＋，深表无语。</p>
<hr />
<p>线上流量运行测试后的补充：</p>
<ul>
  <li>不要使用文件存储，直接把裸设备交给ats管理！</li>
  <li>预估好要缓存的文件的平均大小，默认是8000。ats和squid不一样的是这个值会影响ats的文件组织结构。每次修改都会重建缓存。</li>
</ul>
      <a href="/2012/06/08/intro-trafficserver-ssd-branch-in-taobao" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/06/08/create-python-module-for-ganglia" title="用ganglia监控trafficserver" rel="bookmark">用ganglia监控trafficserver</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-06-08 00:00:00 +0800">08 Jun 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>trafficserver提供了几种很不错的性能监控方式。首先是一个模仿cisco的shell工具./bin/traffic_shell——这个工具可以set变量，也可以show变量，另一个是类似squidclient的./bin/traffic_line工具——这个工具同样可以set和show变量，不过这里变量更接近源代码函数名的样子，相当于调用API了。此外还有Perl和Web的其他方式……</p>
<p>注：有些变量是可以动态修改的，有些比如内存大小之类的必须重启才生效。</p>
<p>用shell工具最方便，因为你单写个show，会提示你所有可以show的参数。一般性能方面就是http-stats/http-trans-stats/proxy-stats/cache-stats这几个。淘宝ssd分支在这里增加了一个SSD吞吐量和RAM缓存命中率的显示。不过一开始，你会发现RAM Cache HITs一直是0.00%！！询问作者后才知道，为了尽量提高性能，默认配置下RAM命中后不统计数据直接pass了……需要在records.config里配置CONFIG proxy.config.http.record_tcp_mem_hit = 1 才行——这配置records.config.default里还没有，呵呵～～</p>
<p>长期监控来说，用shell工具就不方便了，就要改用line工具，不过这里line读取的API，官方文档里是不全的，有一个简单的办法，就是进src/mgmt/cli/ShowCmd.cc里去把Cli_RecordGetInt里的字符串全grep出来，然后慢慢挑拣吧～～</p>
<p>下面是一个python的脚本，用来在ganglia里监控几个我个人认为比较重要的trafficserver性能参数的。</p>
<div class="highlight"><pre><code class="python"><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">ts_line</span> <span class="o">=</span> <span class="s">&#39;/usr/local/trafficserver-ssd/bin/traffic_line&#39;</span>
<span class="k">def</span> <span class="nf">metric_read</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> -r </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ts_line</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="n">command</span><span class="p">)</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">&quot;ratio|percent&quot;</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">descriptors</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;Cache Bytes used&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.process.cache.bytes_used&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;Bytes&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;Cache size&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.process.cache.bytes_total&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;Bytes&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;Transactions per second&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.node.user_agent_xacts_per_second&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;requests/sec&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;Document hit rate&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.node.cache_hit_ratio_avg_10s&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;%&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;Bandwidth savings&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.node.bandwidth_hit_ratio_avg_10s&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;%&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;Cache percent free&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.node.cache.percent_free&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;%&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;Total document bytes from client&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.process.http.user_agent_response_document_total_size&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;Bytes&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;Total SSD Serve Bytes&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.process.http.ssd_serve_total_size&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;Bytes&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;RAM Cache Hits&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.node.cache_hit_mem_ratio&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;%&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;HTTP Transaction Fresh Speeds&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.node.http.transaction_msec_avg_10s.hit_fresh&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;ms&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">&#39;description&#39;</span><span class="p">:</span><span class="s">&#39;HTTP Transaction Now Cached Speeds&#39;</span><span class="p">,</span>
        <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;proxy.node.http.transaction_msec_avg_10s.miss_cold&#39;</span><span class="p">,</span>
        <span class="s">&#39;call_back&#39;</span><span class="p">:</span> <span class="n">metric_read</span><span class="p">,</span>
        <span class="s">&#39;time_max&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
        <span class="s">&#39;value_type&#39;</span><span class="p">:</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
        <span class="s">&#39;units&#39;</span><span class="p">:</span><span class="s">&#39;ms&#39;</span><span class="p">,</span>
        <span class="s">&#39;slope&#39;</span><span class="p">:</span><span class="s">&#39;both&#39;</span><span class="p">,</span>
        <span class="s">&#39;format&#39;</span><span class="p">:</span><span class="s">&#39;</span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span>
        <span class="s">&#39;groups&#39;</span><span class="p">:</span><span class="s">&#39;trafficserver&#39;</span>
    <span class="p">},</span>
<span class="p">]</span>
<span class="k">def</span> <span class="nf">metric_init</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">descriptors</span>
<span class="k">def</span> <span class="nf">metric_cleanup</span><span class="p">():</span>
    <span class="k">pass</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">metric_init</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">&#39;call_back&#39;</span><span class="p">](</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">])</span>
            <span class="k">print</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> = </span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&#39;-&#39;</span><span class="o">*</span><span class="mi">11</span>
</code></pre></div>
<p>个人之前从来没写过python，这个脚本完全照葫芦画瓢，万幸确实可以运行……</p>
<p>不过不太明白的就是，如果把def metric_read定义在descriptors数组后面，运行会报错。很奇怪python为什么会这样？</p>
      <a href="/2012/06/08/create-python-module-for-ganglia" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/06/01/dist-logstash-and-elasticsearch" title="【Logstash系列】用rabbitmq和elasticsearch搭建分布式日志收集存储系统" rel="bookmark">【Logstash系列】用rabbitmq和elasticsearch搭建分布式日志收集存储系统</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-06-01 00:00:00 +0800">01 Jun 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#logstash-ref" title="logstash" rel="category tag">logstash</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>上上篇讲到怎样用MRI的ruby在客户端收集日志。今天主要注意服务器端，考虑grok、elastic、web这几个功能在JRuby上才好。所以服务器端可以再开一个JRuby的进程。</p>
<ul>
  <li>首先安装RabbitMQ的过程</li>
</ul>
<p>最简单的办法，采用epel的yum，或者apt安装。其次简单的办法，从rabbitmq上下载bin的tar.gz。 <br />
这里需要注意一下，rabbitmq-server启动的时候，默认node启动在rabbit@${hostname}上。而且这个hostname不是fqdn的，是第一个主机名。比方说你的hostname是MyHome-1.mydomain.com.，那node就是rabbit@MyHome-1。这个时候很容易报Connect MyHome-1 timeout。所以/etc/hosts一定要写好。  <br />
rabbitmq-server起来之后，可以用rabbitmyctl来具体的创建user啊，vhost啊之类的东西，作为测试，我们就直接使用默认的guest用户和/了。</p>
<ul>
  <li>然后安装elasticsearch的过程</li>
</ul>
<p>这一步在logstash的docs里讲的很清楚了，就是下载tar.gz，解压然后java运行起来即可：    </p>
<div class="highlight"><pre><code class="bash"><span class="nv">ES_PACKAGE</span><span class="o">=</span>elasticsearch-0.18.7.zip
<span class="nv">ES_DIR</span><span class="o">=</span><span class="k">${</span><span class="nv">ES_PACKAGE</span><span class="p">%%.zip</span><span class="k">}</span>
<span class="nv">SITE</span><span class="o">=</span>https://github.com/downloads/elasticsearch/elasticsearch
<span class="k">if</span> <span class="o">[</span> ! -d <span class="s2">&quot;$ES_DIR&quot;</span> <span class="o">]</span> ; <span class="k">then</span>
<span class="k">  </span>wget --no-check-certificate <span class="nv">$SITE</span>/<span class="nv">$ES_PACKAGE</span>
  unzip <span class="nv">$ES_PACKAGE</span>
<span class="k">fi</span>
</code></pre></div>
<ul>
  <li>部署一个logstash的采集节点</li>
</ul>
<p>和上篇所述一样，传输一个删减版的Gemfile到采集节点。然后使用bundle安装这些模块：    </p>
<div class="highlight"><pre><code class="bash">mkdir -p /usr/local/logstash/etc /usr/local/logstash/bin /usr/local/logstash/lib
scp <span class="k">${</span><span class="nv">logstashmaster</span><span class="k">}</span>:/usr/local/logstash/Gemfile /usr/local/logstash/
scp -rf <span class="k">${</span><span class="nv">logstashmaster</span><span class="k">}</span>:/usr/local/logstash/lib/* /usr/local/logstash/lib/
scp <span class="k">${</span><span class="nv">logstashmaster</span><span class="k">}</span>:/usr/local/logstash/bin/logstash /usr/local/logstash/bin/
gem install bundler
<span class="nb">cd</span> /usr/local/logstash/
bundle install
</code></pre></div>
<p>然后编写一个使用rabbitmq的配置文件：</p>
<div class="highlight"><pre><code class="ruby"><span class="n">input</span> <span class="p">{</span>
  <span class="n">file</span> <span class="p">{</span>
    <span class="n">type</span> <span class="o">=&gt;</span> <span class="s2">&quot;syslog&quot;</span>
    <span class="n">path</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;/var/log/syslog.log&quot;</span><span class="p">,</span> <span class="s2">&quot;/var/log/messages&quot;</span> <span class="o">]</span>
  <span class="p">}</span> 
<span class="p">}</span>
<span class="n">output</span> <span class="p">{</span>
  <span class="n">amqp</span> <span class="p">{</span>
    <span class="n">host</span> <span class="o">=&gt;</span> <span class="s2">&quot;MyHome-1&quot;</span>
    <span class="n">exchange_type</span> <span class="o">=&gt;</span> <span class="s2">&quot;fanout&quot;</span>
    <span class="nb">name</span> <span class="o">=&gt;</span> <span class="s2">&quot;rawlogs&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>OK，用ruby /usr/local/logstash/bin/logstash agent -f /usr/local/logstash/etc/agent.conf启动即可。</p>
<ul>
  <li>部署一个logstash的汇聚节点</li>
</ul>
<p>这一步因为用到的模块大多是JRuby的，所以可以直接使用jar包的方式简单搞定。
编写一个使用rabbitmq和elasticsearch的配置文件：</p>
<div class="highlight"><pre><code class="ruby"><span class="n">input</span> <span class="p">{</span>
  <span class="n">amqp</span> <span class="p">{</span>
    <span class="n">type</span> <span class="o">=&gt;</span> <span class="s2">&quot;syslog&quot;</span>
    <span class="n">host</span> <span class="o">=&gt;</span> <span class="s2">&quot;MyHome-1&quot;</span>
    <span class="n">exchange</span> <span class="o">=&gt;</span> <span class="s2">&quot;rawlogs&quot;</span>
    <span class="nb">name</span> <span class="o">=&gt;</span> <span class="s2">&quot;rawlogs_consumer&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">filter</span> <span class="p">{</span>
  <span class="n">grok</span> <span class="p">{</span>
    <span class="n">type</span> <span class="o">=&gt;</span> <span class="s2">&quot;syslog&quot;</span>
    <span class="n">pattern</span> <span class="o">=&gt;</span> <span class="s2">&quot;%{SYSLOG}&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">output</span> <span class="p">{</span>
  <span class="n">elasticsearch</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>这里比较讨厌的还是rabbitmq的部分。假如前面的步骤rabbitmq-server压根启动失败了，这里amqp不会返回报错说连接失败或者连接node超时什么的，而是说你试图连接一个私有的被锁定的队列……</p>
<ul>
  <li>部署一个logstash的展示节点</li>
</ul>
<p>这个节点就没必要再单开一台了，就用上面的jar包再启动一个web即可：java -jar logstash-1.1.0-monolithic.jar agent -f server.conf &ndash; web &ndash;backend &lsquo;elasticsearch:///?local&rsquo;</p>
<ul>
  <li>测试</li>
</ul>
<p>现在可以打开浏览器访问web查看了。很简单的页面，顶上一个搜索栏，中间一个按时间轴显示的柱状图，下面是具体的日志记录。点具体的某条日志，会有浮框显示该条记录的详细信息(host/date/event/message等)</p>
<p>下一步研究grok正则匹配的编写，然后stated实时绘图，lucene查询语法。</p>
      <a href="/2012/06/01/dist-logstash-and-elasticsearch" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/06/01/create-slides-by-using-spork-and-tt2" title="用Spork和Template::Toolkit生成slides胶片展示" rel="bookmark">用Spork和Template::Toolkit生成slides胶片展示</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-06-01 00:00:00 +0800">01 Jun 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>在不少技术集会上，大家都不再采用ppt而是使用pdf，甚至浏览器，编辑器来显示内容。利用js和css完成slide效果已经越来越花哨。另一个用vim的流派也让人很是惊叹~  <br />
那不会css的童鞋怎么办呢？这里有个笨办法。用Spork工具生成html页——反正slide一般内容不多，html代码重复一点也不浪费啥事儿~用template技术刚刚好。
Spork是一个在Sporx基础上构成的工具，可以直接cpan安装，不过默认情况下没有plugin。所以比较好的办法是上git找个带plugin的代码clone。这样页面样式好看点。  <br />
比方我用的这个就是Spork作者用的：<a href="https://github.com/ingydotnet/spork-pm">Spork-pm</a></p>
<p>新建一个slide的工程相当简单：</p>
<div class="highlight"><pre><code class="bash">git clone https://github.com/ingydotnet/spork-pm.git
<span class="nb">cd </span>spork-pm
perl Makefile.PL
make <span class="o">&amp;&amp;</span> make install
<span class="c"># 必须新建，非空目录时命令无效</span>
mkdir /tmp/slides
<span class="nb">cd</span> /tmp/slides
Spork -new
Spork -make
Spork -start
</code></pre></div>
<p>在slide里每张都加载,css和js都是重复的。make的过程就是使用template展开的问题。start就是打开浏览器的命令行的alias。这里其实可以优化一下改成外链css/js(默认是因为有些控制bgcolor啊之类的spork语法可以在单页里用，所以就没外链)~  <br />
注意template里的模板html里charset都是写的UTF-8编码，而在win上，编辑器默认是GB2312的，需要更改过来。</p>
<p>具体语法，&mdash;-表示一页；==表示大标题；<em>表示小条目，</em>越多条目等级越低；+表示稍后显示(其实就是在本页基础上再开新页)。  <br />
然后还有一些config定义，用来显示head，foot和start页内容的。    </p>
<p>最后，上一个最近我的slide，关于DNS协议和应用的内容，浏览地址见：
<a href="http://chenlinux.com/dns-slides/slides/start.html">DNS协议与应用</a></p>
<p>比较无语的是js控制翻页这块。我的笔记本键盘只能捕获中间正常键位信号，上下左右、home、end、pgon、pgdn这些统统不行。无奈只好改用输入法一样的逗号,句号.翻页了……</p>
      <a href="/2012/06/01/create-slides-by-using-spork-and-tt2" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/05/31/use-ruby-1.8-for-logstash-agent" title="【Logstash系列】使用原版Ruby1.8运行logstash的客户端程序" rel="bookmark">【Logstash系列】使用原版Ruby1.8运行logstash的客户端程序</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-05-31 00:00:00 +0800">31 May 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#logstash-ref" title="logstash" rel="category tag">logstash</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>在一般情况下，我们实验logstash都是直接用官网上下载的jar包，然后java运行即可。但如果在大规模场景下，这样其实并不是运维的最佳实践：</p>
<ol>
  <li>并不是所有设备都默认或者很方便的可以安装java；</li>
  <li>默认使用的JRuby执行效率比MRI的版本低一些，为了大规模运维管理，一般部署puppet的时候附加yum/apt获取的是Ruby1.8.7。</li>
</ol>
<p>花了一点时间了解了一下代码结构，发现这点其实是可以做到的。从github上clone代码，在其中的example、bin和lib目录中都看到大量对应官网文档的input/filter/output的东东。</p>
<p>根据我对logstash的了解，仅保留input的file、syslog和remote_luby，filter里的grok，output里的elasticsearch和rabbitmq。然后看lib/logstash/*的具体模块，只有三个模块提到了必须使用java后台。</p>
<p>于是第一步，修改Gemile，只留下必备的模块。
第二步，通过bundle管理工具加载安装。
第三步，通过命令行方式指定配置变量和参数。
第四步，把所属包打包发送到其他设备测试。</p>
<p>现在保留的Gemfile如下：</p>
<div class="highlight"><pre><code class="ruby"><span class="n">source</span> <span class="ss">:rubygems</span>
<span class="n">gem</span> <span class="s2">&quot;cabin&quot;</span><span class="p">,</span> <span class="s2">&quot;0.4.4&quot;</span> <span class="c1"># for logging. apache 2 license</span>
<span class="n">gem</span> <span class="s2">&quot;bunny&quot;</span> <span class="c1"># for amqp support, MIT-style license</span>
<span class="n">gem</span> <span class="s2">&quot;uuidtools&quot;</span> <span class="c1"># for naming amqp queues, License ???</span>
<span class="n">gem</span> <span class="s2">&quot;filewatch&quot;</span><span class="p">,</span> <span class="s2">&quot;0.3.3&quot;</span>  <span class="c1"># for file tailing, BSD License</span>
<span class="n">gem</span> <span class="s2">&quot;jls-grok&quot;</span><span class="p">,</span> <span class="s2">&quot;0.10.6&quot;</span> <span class="c1"># for grok filter, BSD License</span>
<span class="n">gem</span> <span class="s2">&quot;json</span>
<span class="s2">gem &quot;</span><span class="n">mail</span><span class="s2">&quot;</span>
<span class="s2">gem &quot;</span><span class="n">minitest</span><span class="s2">&quot; # License: Ruby</span>
<span class="s2">gem &quot;</span><span class="n">statsd</span><span class="o">-</span><span class="n">ruby</span><span class="s2">&quot;, &quot;</span><span class="mi">0</span><span class="o">.</span><span class="mi">3</span><span class="o">.</span><span class="mi">0</span><span class="s2">&quot; # outputs/statsd, # License: As-Is</span>
<span class="s2">group :test do</span>
<span class="s2">  gem &quot;</span><span class="n">mocha</span><span class="s2">&quot;</span>
<span class="s2">  gem &quot;</span><span class="n">shoulda</span><span class="s2">&quot;</span>
<span class="s2">end</span>
</code></pre></div>
<p>然后客户端的运行，这里有点小问题，默认要求必须大于Ruby1.9.2的版本才行。但是通读一遍，发现其实只是用到了Ruby1.9.2里一个全局变量RUBY_ENGINE来判断自己是不是JRuby，这个对等判断很容易修改成为RUBY_DESCRIPTION变量的正则匹配判断。之后就OK了。</p>
<p>具体替换代码如下：</p>
<div class="highlight"><pre><code class="ruby"><span class="c1"># if RUBY_ENGINE == &#39;JRuby&#39; </span>
  <span class="k">if</span> <span class="no">RUBY_DESCRIPTION</span> <span class="o">=~</span> <span class="n">m</span><span class="o">/^</span><span class="no">Ruby</span><span class="o">/</span>
</code></pre></div>
<p>最后把挑好的lib/*.rb和bin/logstash、etc/logstash打包发送到其他设备。运行也没问题。写上不同的server和agent.conf启动起来一看，果然就传输过去了。
目前就到这步，随后随时更新</p>
      <a href="/2012/05/31/use-ruby-1.8-for-logstash-agent" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/05/25/nginx-auth-by-perl-and-lua" title="用perl和lua在nginx中验证url" rel="bookmark">用perl和lua在nginx中验证url</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-05-25 00:00:00 +0800">25 May 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#nginx-ref" title="nginx" rel="category tag">nginx</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>和三年前的博客一样，还是时间加密钥加路径的加密方式。不过这次改用nginx，这样不用重新缓存后面的squid文件了。
先用ngx_lua做：</p>
<div class="highlight"><pre><code class="nginx">    <span class="k">set</span> <span class="nv">$expire</span> <span class="s">&quot;600&quot;</span><span class="p">;</span>
    <span class="k">set</span> <span class="nv">$salt</span> <span class="s">&quot;mysalt&quot;</span><span class="p">;</span>
    <span class="k">location</span> <span class="p">~</span><span class="sr">*</span> <span class="s">\.mp3</span>$ <span class="p">{</span>
<span class="c1">#local m = ngx.re.match(ngx.var.uri,&quot;^/([0-9]{4})/([0-9]{2})/([0-9]{2})/([0-9]{2})/([0-9]{2})/([0-9a-z]{32})(/.*)&quot;)</span>
<span class="c1">#用ngx.re.match就不能%d,用string.match就不能{2}，郁闷</span>
<span class="c1">#而且ngx.re.match所有的捕获都在m数组里，这点类似perl的m//返回。</span>
        <span class="kn">rewrite_by_lua</span> <span class="s">&#39;</span>
        <span class="s">local</span> <span class="s">date</span> <span class="p">=</span> <span class="p">{}</span>
        <span class="kn">local</span> <span class="s">md5str</span>
        <span class="s">local</span> <span class="s">path</span>
        <span class="s">date.year,date.month,date.day,date.hour,date.min,md5str,path</span> <span class="p">=</span> <span class="s">string.match(ngx.var.uri,&quot;^/(%d+)/(%d+)/(%d+)/(%d+)/(%d+)/(%w+)(/%S+)&quot;)</span>
        <span class="s">if</span> <span class="s">date.year</span> <span class="p">==</span> <span class="s">nil</span> <span class="s">then</span>
             <span class="s">ngx.exit(404)</span>
        <span class="s">end</span>
        <span class="s">local</span> <span class="s">time1</span> <span class="p">=</span> <span class="s">tonumber(os.time(date))</span>
        <span class="s">local</span> <span class="s">time2</span> <span class="p">=</span> <span class="s">tonumber(ngx.time())</span>
        <span class="s">if</span> <span class="s">md5str</span> <span class="p">==</span> <span class="s">ngx.md5(ngx.var.salt..date.year..date.month..date.day..date.hour..date.min..path)</span> <span class="s">then</span>
            <span class="s">if</span> <span class="s">time2</span> <span class="s">-</span> <span class="s">time1</span> <span class="s">&lt;</span> <span class="s">tonumber(ngx.var.expire)</span> <span class="s">then</span>
                <span class="s">ngx.req.set_uri(path)</span>
            <span class="s">else</span>
                <span class="s">ngx.exit(405)</span>
            <span class="s">end</span>
        <span class="s">else</span>
            <span class="s">ngx.exit(403)</span>
        <span class="s">end</span>
        <span class="s">&#39;</span><span class="p">;</span>  
        <span class="kn">proxy_pass</span>         <span class="s">http://backend</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span>   <span class="s">Host</span>     <span class="nv">$host</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>然后用nginx_perl做：</p>
<div class="highlight"><pre><code class="nginx">    <span class="k">perl_require</span> <span class="s">POSIX.pm</span><span class="p">;</span>
    <span class="k">perl_require</span> <span class="s">Digest/MD5.pm</span><span class="p">;</span>
    <span class="k">perl_set</span> <span class="nv">$realurl</span> <span class="s">&#39;</span>
    <span class="s">sub</span> <span class="p">{</span>
        <span class="kn">my</span> <span class="nv">$secret</span> <span class="p">=</span> <span class="s">&quot;mysalt&quot;</span><span class="p">;</span>
        <span class="kn">my</span> <span class="nv">$expire</span> <span class="p">=</span> <span class="mi">600</span><span class="p">;</span>
        <span class="kn">my</span> <span class="nv">$r</span> <span class="p">=</span> <span class="s">shift</span><span class="p">;</span>
        <span class="kn">if</span> <span class="s">(</span> <span class="nv">$r-&gt;uri</span> <span class="p">=~</span> <span class="sr">m#^/(\d</span><span class="p">{</span><span class="kn">4})/(\d{2})/(\d{2})/(\d{2})/(\d{2})/(\w{32})(/\S+\.mp3)</span><span class="c1">#oi ) {</span>
            <span class="s">my</span> <span class="s">(</span><span class="nv">$year,</span> <span class="nv">$mon,</span> <span class="nv">$mday,</span> <span class="nv">$hour,</span> <span class="nv">$min,</span> <span class="nv">$md5,</span> <span class="nv">$path</span><span class="s">)</span> <span class="p">=</span> <span class="s">(</span><span class="nv">$1,</span> <span class="nv">$2,</span> <span class="nv">$3,</span> <span class="nv">$4,</span> <span class="nv">$5,</span> <span class="nv">$6,</span> <span class="nv">$7</span><span class="s">)</span><span class="p">;</span>
            <span class="kn">my</span> <span class="nv">$str</span> <span class="p">=</span> <span class="s">Digest::MD5::md5_hex(</span><span class="nv">$secret</span> <span class="s">.</span> <span class="nv">$year</span> <span class="s">.</span> <span class="nv">$mon</span> <span class="s">.</span> <span class="nv">$mday</span> <span class="s">.</span> <span class="nv">$hour</span> <span class="s">.</span> <span class="nv">$min</span> <span class="s">.</span> <span class="nv">$path</span><span class="s">)</span><span class="p">;</span>
            <span class="kn">my</span> <span class="nv">$reqtime</span> <span class="p">=</span> <span class="s">POSIX::mktime(00,</span> <span class="nv">$min,</span> <span class="nv">$hour,</span> <span class="nv">$mday,</span> <span class="nv">$mon</span> <span class="s">-</span> <span class="mi">1</span><span class="s">,</span> <span class="nv">$year</span> <span class="s">-</span> <span class="mi">1900</span><span class="s">)</span><span class="p">;</span>
            <span class="kn">my</span> <span class="nv">$now</span> <span class="p">=</span> <span class="s">time</span><span class="p">;</span>
            <span class="kn">if</span> <span class="s">(</span> <span class="nv">$str</span> <span class="s">eq</span> <span class="nv">$md5</span> <span class="s">and</span> <span class="nv">$now</span> <span class="s">-</span> <span class="nv">$reqtime</span> <span class="s">&lt;</span> <span class="nv">$expire</span> <span class="s">)</span> <span class="p">{</span>
                    <span class="kn">return</span> <span class="nv">$path</span><span class="p">;</span>
            <span class="p">}</span> <span class="kn">else</span> <span class="p">{</span>
                <span class="kn">return</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
            <span class="p">}</span>;
        <span class="p">}</span> <span class="kn">else</span> <span class="p">{</span>
            <span class="kn">return</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
        <span class="p">}</span>;
    <span class="p">}</span><span class="k">&#39;</span><span class="p">;</span>
  <span class="k">server</span> <span class="p">{</span> 
    <span class="kn">location</span> <span class="p">~</span><span class="sr">*</span> <span class="s">\.mp3</span>$ <span class="p">{</span>
                <span class="kn">if</span> <span class="s">(</span><span class="nv">$realurl</span> <span class="p">=</span> <span class="s">&quot;error&quot;)</span> <span class="p">{</span> <span class="kn">return</span> <span class="mi">403</span><span class="p">;</span> <span class="p">}</span>
                <span class="kn">proxy_pass</span>         <span class="s">http://music_store_local</span><span class="nv">$realurl</span><span class="p">;</span>
                <span class="kn">proxy_set_header</span>   <span class="s">Host</span>             <span class="nv">$host</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>
<p>然后用http_load测试单url响应情况，基本效率一样。在压力比较大(lo上跑大概200MB/s，再大就可能出错了)的情况下，第一字节响应时间大概比直接请求squid多一个数量级（从0.4ms到4ms）  <br />
这个情况下，squid的cpu%在130％，nginx_perl的worker是25％，nginx_lua的是19％。</p>
      <a href="/2012/05/25/nginx-auth-by-perl-and-lua" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/05/22/puppet-reports-analysis-by-web" title="【puppet系列】网页展示puppet的客户端报告" rel="bookmark">【puppet系列】网页展示puppet的客户端报告</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-05-22 00:00:00 +0800">22 May 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>上篇说到怎样使用ENC脚本控制puppet的客户端配置，这篇说如何监控和展示客户端运行状态报告。</p>
<p>目前还是使用puppet默认的store方式，也就是报告都存在/var/lib/puppet/reports/$host/$dates.yaml里。所以分析只要针对这个目录下的文件即可，主要使用File::Stat和File::Find两个模块搞定。注意这两个模块在Perl5.16里是默认内核模块了~~</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="n">autodie</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">File::</span><span class="n">Stat</span> <span class="sx">qw/:stat/</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">YAML::</span><span class="n">Syck</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">AnyEvent::Filesys::</span><span class="n">Notify</span><span class="p">;</span>
<span class="k">use</span> <span class="n">EV</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$interval</span> <span class="o">=</span> <span class="s">&quot;60&quot;</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$watch_dir</span> <span class="o">=</span> <span class="s">&quot;/var/lib/puppet/reports&quot;</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$periodic</span> <span class="o">=</span> <span class="nn">EV::</span><span class="n">periodic</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">$interval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$dirs</span> <span class="o">=</span> <span class="n">watchdir</span><span class="p">(</span><span class="nv">$interval</span><span class="p">);</span>
    <span class="n">process</span><span class="p">(</span> <span class="nv">$_</span><span class="p">,</span> <span class="s">&#39;No reports return.&#39;</span> <span class="p">)</span> <span class="k">for</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$dirs</span><span class="p">};</span>
<span class="p">};</span>
<span class="k">my</span> <span class="nv">$notifier</span> <span class="o">=</span> <span class="nn">AnyEvent::Filesys::</span><span class="n">Notify</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span>
    <span class="n">dirs</span>     <span class="o">=&gt;</span> <span class="p">[</span> <span class="nv">$watch_dir</span><span class="p">,</span> <span class="p">],</span>
    <span class="n">interval</span> <span class="o">=&gt;</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">filter</span>   <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span> <span class="nb">shift</span> <span class="o">=~</span><span class="sr"> /\.yaml$/</span> <span class="p">},</span>
    <span class="n">cb</span>       <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
        <span class="k">my</span> <span class="nv">@events</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span> <span class="nv">@events</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=~</span> <span class="sr">m/^(created|modified)$/</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>
                <span class="k">my</span> <span class="nv">$logs</span> <span class="o">=</span> <span class="n">LoadFile</span><span class="p">(</span><span class="nv">$file</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;logs&#39;</span><span class="p">};</span>
                <span class="k">for</span> <span class="p">(</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$logs</span><span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;level&#39;</span><span class="p">}</span> <span class="ow">eq</span> <span class="s">&#39;err&#39;</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">process</span><span class="p">(</span> <span class="nv">$file</span><span class="p">,</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;message&#39;</span><span class="p">}</span> <span class="p">);</span>
                    <span class="p">};</span>
                <span class="p">};</span>
            <span class="p">};</span>
        <span class="p">};</span>
    <span class="p">},</span>
<span class="p">);</span>
<span class="nn">EV::</span><span class="n">loop</span><span class="p">();</span>
<span class="k">sub </span><span class="nf">process</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span> <span class="nv">$path</span><span class="p">,</span> <span class="nv">$message</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nv">$path</span> <span class="o">=~</span> <span class="sr">m/\/([^\/]+\.opi\.com)/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">print</span> <span class="nv">$1</span><span class="p">,</span><span class="s">&quot; has err: &quot;</span><span class="p">,</span><span class="nv">$message</span><span class="p">,</span><span class="s">&quot;\n&quot;</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="k">sub </span><span class="nf">watchdir</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$interval</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$dirs</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nb">time</span> <span class="o">-</span> <span class="nb">stat</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nv">$interval</span> <span class="p">}</span> <span class="nb">glob</span><span class="p">(</span><span class="s">&quot;${watch_dir}/*&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nv">$dirs</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>上面这个脚本，通过libev的timer和io分别完成对diretory的mtime的遍历和对file的inotify的监听。process作为公共处理函数，可以随意改造成sms/email/msn等等方式。  <br />
定时器没有用AnyEvent的封装，因为没看到AE有periodic，只有timer。而在io运行的时候，timer是中断的。如果不停有文件inotify发生，timer就没法进行了……periodic的方式与timer不同，是绝对定时而不是相对定时——虽然我个人的浅薄理解觉得应该也被io阻塞，但试验结果是OK的。</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="n">autodie</span><span class="p">;</span>
<span class="k">use</span> <span class="n">Dancer</span><span class="p">;</span>
<span class="k">use</span> <span class="n">Template</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">YAML::</span><span class="n">Syck</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">File::</span><span class="n">Find</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">File::</span><span class="n">Stat</span> <span class="sx">qw/:stat/</span><span class="p">;</span>
<span class="k">use</span> <span class="n">POSIX</span> <span class="sx">qw/strftime/</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Data::Section::</span><span class="n">Simple</span> <span class="sx">qw/get_data_section/</span><span class="p">;</span>
<span class="n">set</span> <span class="n">port</span>   <span class="o">=&gt;</span> <span class="s">&quot;8080&quot;</span><span class="p">;</span>
<span class="n">set</span> <span class="n">daemon</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">set</span> <span class="n">logger</span> <span class="o">=&gt;</span> <span class="s">&#39;console&#39;</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$tt</span> <span class="o">=</span> <span class="n">Template</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span>
<span class="c1">#                       DEBUG =&gt; &#39;all&#39;,</span>
                      <span class="p">);</span>
<span class="k">my</span> <span class="nv">$ds_check</span> <span class="o">=</span> <span class="n">get_data_section</span><span class="p">(</span><span class="s">&#39;check.tt&#39;</span><span class="p">);</span>
<span class="n">get</span> <span class="s">&#39;/&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$html</span> <span class="o">=</span> <span class="s">&#39;&lt;form action=&quot;/ppcheck&quot;&gt;&#39;</span><span class="p">;</span>
    <span class="nv">$html</span> <span class="o">.=</span> <span class="s">&#39;Write an interval minutes for reports timestamp check: &#39;</span><span class="p">;</span>
    <span class="nv">$html</span> <span class="o">.=</span> <span class="s">&#39;&lt;input type=&quot;text&quot; name=&quot;interval&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;&#39;</span><span class="p">;</span>
    <span class="nv">$html</span> <span class="o">.=</span> <span class="s">&#39;&lt;/form&gt;&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$html</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">get</span> <span class="s">&#39;/ppcheck&#39;</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$interval</span> <span class="o">=</span> <span class="n">params</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;interval&#39;</span><span class="p">}</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">||</span> <span class="mi">300</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$watch_dir</span> <span class="o">=</span> <span class="s">&quot;/var/lib/puppet/reports&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="s">&quot;Too large number&quot;</span> <span class="k">if</span> <span class="nv">$interval</span> <span class="o">&gt;</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span><span class="p">;</span>   <span class="c1"># one day</span>
    <span class="k">my</span> <span class="nv">$context</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nv">$context</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;dirs&#39;</span><span class="p">}</span> <span class="o">=</span> <span class="n">watch_timeout</span><span class="p">(</span> <span class="nv">$interval</span><span class="p">,</span> <span class="nv">$watch_dir</span> <span class="p">);</span>
    <span class="nv">$context</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;logs&#39;</span><span class="p">}</span> <span class="o">=</span> <span class="n">watch_errlogs</span><span class="p">(</span> <span class="nv">$interval</span><span class="p">,</span> <span class="nv">$watch_dir</span> <span class="p">);</span>
    <span class="k">my</span> <span class="nv">$output</span><span class="p">;</span>
    <span class="nv">$tt</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span><span class="o">\</span><span class="nv">$ds_check</span><span class="p">,</span> <span class="nv">$context</span><span class="p">,</span> <span class="o">\</span><span class="nv">$output</span><span class="p">);</span>
<span class="c1">#    $tt-&gt;process(\*DATA, $context, \$output);</span>
<span class="c1">#    seek *DATA, 1234, 0;</span>
    <span class="k">return</span> <span class="nv">$output</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">sub </span><span class="nf">watch_timeout</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span> <span class="nv">$interval</span><span class="p">,</span> <span class="nv">$watch_dir</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@dirs</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nb">time</span> <span class="o">-</span> <span class="nb">stat</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nv">$interval</span> <span class="p">}</span> <span class="nb">glob</span><span class="p">(</span><span class="s">&quot;${watch_dir}/*&quot;</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">@ret</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="nv">@dirs</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$dirtime</span> <span class="o">=</span> <span class="n">strftime</span><span class="p">(</span><span class="s">&quot;%F %T&quot;</span><span class="p">,</span> <span class="nb">localtime</span><span class="p">(</span><span class="nb">stat</span><span class="p">(</span><span class="nv">$_</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]));</span>
        <span class="k">my</span> <span class="nv">$dirname</span> <span class="o">=</span> <span class="nv">$1</span> <span class="k">if</span> <span class="nv">$_</span> <span class="o">=~</span> <span class="n">s</span><span class="c1">#([^/]+\.opi\.com)#$1#;</span>
        <span class="nb">push</span> <span class="nv">@ret</span><span class="p">,</span> <span class="p">{</span><span class="n">name</span> <span class="o">=&gt;</span> <span class="nv">$dirname</span><span class="p">,</span> <span class="nb">time</span> <span class="o">=&gt;</span> <span class="nv">$dirtime</span><span class="p">,</span> <span class="p">};</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="o">\</span><span class="nv">@ret</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">sub </span><span class="nf">watch_errlogs</span> <span class="p">{</span>
    <span class="k">my</span><span class="p">(</span> <span class="nv">$interval</span><span class="p">,</span> <span class="nv">$watch_dir</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">my</span><span class="p">(</span> <span class="nv">$wanted</span><span class="p">,</span> <span class="nv">$list_reporter</span> <span class="p">)</span> <span class="o">=</span> <span class="n">find_file_by_mtime</span><span class="p">(</span><span class="nv">$interval</span><span class="p">);</span>
    <span class="nn">File::Find::</span><span class="n">find</span><span class="p">(</span> <span class="nv">$wanted</span><span class="p">,</span> <span class="nv">$watch_dir</span> <span class="p">);</span>
    <span class="k">my</span> <span class="nv">@ret</span> <span class="o">=</span> <span class="nv">$list_reporter</span><span class="o">-&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">\</span><span class="nv">@ret</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">sub </span><span class="nf">find_file_by_mtime</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$interval</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">@found</span> <span class="o">=</span> <span class="p">();</span>
    <span class="k">my</span> <span class="nv">$finder</span> <span class="o">=</span> <span class="k">sub </span><span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">-</span><span class="n">f</span> <span class="nv">$</span><span class="nn">File::Find::</span><span class="nv">name</span> <span class="o">&amp;&amp;</span> <span class="nb">time</span> <span class="o">-</span> <span class="nb">stat</span><span class="p">(</span><span class="nv">$</span><span class="nn">File::Find::</span><span class="nv">name</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nv">$interval</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">$yaml</span> <span class="o">=</span> <span class="nn">YAML::Syck::</span><span class="n">LoadFile</span><span class="p">(</span><span class="nv">$</span><span class="nn">File::Find::</span><span class="nv">name</span><span class="p">);</span>
            <span class="k">my</span> <span class="nv">@logs</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;level&#39;</span><span class="p">}</span> <span class="ow">eq</span> <span class="s">&#39;err&#39;</span> <span class="p">}</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$yaml</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;logs&#39;</span><span class="p">}};</span>
            <span class="k">for</span> <span class="p">(</span> <span class="nv">@logs</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nb">push</span> <span class="nv">@found</span><span class="p">,</span> <span class="p">{</span> <span class="n">host</span> <span class="o">=&gt;</span> <span class="nv">$yaml</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;host&#39;</span><span class="p">},</span> <span class="n">message</span> <span class="o">=&gt;</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;message&#39;</span><span class="p">},</span> <span class="p">};</span>
            <span class="p">};</span>
        <span class="p">};</span>
    <span class="p">};</span>
    <span class="k">my</span> <span class="nv">$reporter</span> <span class="o">=</span> <span class="k">sub </span><span class="p">{</span> <span class="nv">@found</span> <span class="p">};</span>
    <span class="k">return</span><span class="p">(</span> <span class="nv">$finder</span><span class="p">,</span> <span class="nv">$reporter</span> <span class="p">);</span>
<span class="p">};</span>
<span class="n">dance</span><span class="p">;</span>
<span class="bp">__DATA__</span>
<span class="nv">@@</span> <span class="nv">check</span><span class="o">.</span><span class="n">tt</span>
<span class="o">&lt;</span><span class="n">div</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;timeoutdirs&quot;</span><span class="o">&gt;</span>
<span class="n">List</span> <span class="n">of</span> <span class="n">nodes</span> <span class="n">whose</span> <span class="n">report</span> <span class="n">is</span> <span class="n">timeout:</span> <span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
<span class="sr">&lt;ul&gt;</span>
<span class="p">[</span><span class="nv">%</span> <span class="nv">FOREACH</span> <span class="n">dir</span> <span class="n">IN</span> <span class="n">dirs</span> <span class="nv">%</span><span class="err">]</span>
<span class="err">&lt;</span><span class="nv">li</span> <span class="n">style</span><span class="o">=</span><span class="s">&quot;width:200px;float:left&quot;</span><span class="o">&gt;</span><span class="p">[</span><span class="nv">%</span> <span class="nv">dir</span><span class="o">.</span><span class="n">name</span> <span class="nv">%</span><span class="err">]&lt;/</span><span class="nv">li</span><span class="o">&gt;&lt;</span><span class="n">li</span> <span class="n">style</span><span class="o">=</span><span class="s">&quot;width:200px;margin:0;float:left&quot;</span><span class="o">&gt;</span><span class="p">[</span><span class="nv">%</span> <span class="nv">dir</span><span class="o">.</span><span class="nb">time</span> <span class="nv">%</span><span class="err">]&lt;/</span><span class="nv">li</span><span class="o">&gt;</span>
<span class="p">[</span><span class="nv">%</span> <span class="nv">END</span> <span class="nv">%</span><span class="err">]</span>
<span class="err">&lt;/</span><span class="nv">ul</span><span class="o">&gt;</span>
<span class="sr">&lt;/div&gt;</span>
<span class="o">&lt;</span><span class="n">br</span> <span class="sr">/&gt;&lt;hr /</span><span class="o">&gt;&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">div</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;runerrlogs&quot;</span><span class="o">&gt;</span>
<span class="n">Error</span> <span class="n">messages</span> <span class="n">of</span> <span class="n">running</span> <span class="n">nodes:</span> <span class="o">&lt;</span><span class="n">br</span> <span class="o">/&gt;</span>
<span class="sr">&lt;ul&gt;</span>
<span class="p">[</span><span class="nv">%</span> <span class="nv">FOREACH</span> <span class="nb">log</span> <span class="n">IN</span> <span class="n">logs</span> <span class="nv">%</span><span class="err">]</span>
<span class="err">&lt;</span><span class="nv">li</span> <span class="n">style</span><span class="o">=</span><span class="s">&quot;width:200px;float:left&quot;</span><span class="o">&gt;</span><span class="p">[</span><span class="nv">%</span> <span class="nv">log</span><span class="o">.</span><span class="n">host</span> <span class="nv">%</span><span class="err">]&lt;/</span><span class="nv">li</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">li</span> <span class="n">style</span><span class="o">=</span><span class="s">&quot;width:400px;margin:0;float:left&quot;</span><span class="o">&gt;</span><span class="p">[</span><span class="nv">%</span> <span class="nv">log</span><span class="o">.</span><span class="n">message</span> <span class="nv">%</span><span class="err">]&lt;/</span><span class="nv">li</span><span class="o">&gt;</span>
<span class="p">[</span><span class="nv">%</span> <span class="nv">END</span> <span class="nv">%</span><span class="err">]</span>
<span class="err">&lt;/</span><span class="nv">ul</span><span class="o">&gt;</span>
<span class="sr">&lt;/div&gt;</span>
</code></pre></div>
<p>这个脚本实现的功能其实和上面那个类似。不过报警改成web页面，event触发改成web请求触发。  <br />
这里两个新难点：</p>
<p>其一是没有inotify后如何根据web请求参数查找范围内新建的报表。File::Find模块只有一个函数find(\&amp;wanted,@dirs)。其中&amp;wanted是不能传参进去的。  <br />
在CPAN上看到一个叫做File::Find::Closures的模块，提供了一系列可以给File::Find使用的&amp;wanted函数，包括一个示例。于是稍微改造一下，就写成了find_file_by_mtime()函数。</p>
<p>其二是因为偷懒没有用dancer建立完整项目，使用了perl virtual file来提供template。所以不能直接使用Dancer的template &lsquo;ttname&rsquo;, {var=&gt;$var};定义了。  <br />
Template::Toolkit提供的process()可以操作的template来源很多，可以是字符串／文件／句柄。所以process(*DATA)也是生效的。但是问题出现了：这样启动后，第一次访问正常；第二次访问返回空！  <br />
打开Template的DEBUG看到，第二次访问的时候，从*DATA里读不到数据了。也就是说，必须重新seek回去——而且试验证明seek的起始点是shebang行。。。。  <br />
所以只能先从__DATA__里读出数据，然后以字符串形式传递给process()了。    </p>
<p>这里用到了Data::Section模块。从CloudForecast项目里学来的。CloudForecast中的web页面，使用的Text::Xslate模板技术读取__DATA__。其中包括有index／server／servers／service等页面。也就是说，在一个__DATA__里实现了多个virtual file。用的就是Data::Section::Simple模块。以@@为标签分割即可。</p>
      <a href="/2012/05/22/puppet-reports-analysis-by-web" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/05/18/puppet-external-nodes-classifier" title="【puppet系列】puppet使用ENC定义节点" rel="bookmark">【puppet系列】puppet使用ENC定义节点</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-05-18 00:00:00 +0800">18 May 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>今天研究puppet dashboard。主要有ENC和reports两个功能。其中ENC功能相当扯淡，因为你在web上点击添加的class/node/group，是没有任何依赖性检查(比如node命名是否符合fqdn，class是否存在)的，随便咋填绝无报错和拒绝！而且也没有提供类似report的导入工具，一旦启用就要完全重新手工输入所有配置……所以无论是从导入角度还是管理角度，自己实现一个靠谱点的ENC都是有必要的。    </p>
<p>关于puppet的ENC配置，参见<a href="http://docs.puppetlabs.com/guides/external_nodes.html">ENC的文档</a>    </p>
<p>主要就是修改puppet.conf里两个配置：    </p>
<ul>
  <li><code>node_terminus</code>，由plain修改成exec；</li>
  <li><code>external_nodes</code>，由none修改为ENC脚本的路径。    </li>
</ul>
<p>类似如下：</p>
<pre><code>[master]    
node_terminus = exec    
external_nodes = /etc/puppet/webui/external_nodes    
</code></pre>
<p>脚本输入输出的说明：    </p>
<pre><code>Its only argument is the name of the node to be classified, and it returns a YAML document describing the node.
</code></pre>
<p>注意到此为止配置修改不算结束！文档中提到，puppet是支持同时开启ENC和site.pp配置的。puppet会自动merge两个配置。但是debug运行时可以看到，这个merge是按照node级别进行的。也就是说：    </p>
<ol>
  <li>puppet master收到一个node的请求，如果 <code>node_terminus</code> 配置为exec，输出node的fqdn给 <code>external_nodes</code>；    </li>
  <li>收到 <code>external_nodes</code> 的返回，为一个yaml体或者空；    </li>
  <li>加载site.pp，这是按照文本顺序进行的。如果都是import &ldquo;module&rdquo;，那么最后就进入module的parameter和template处理。    </li>
  <li>如果已经存在，检查是全局变量还是类，全局变量的话报错，类的话覆盖为site.pp中最后定义的类。  <br />
<strong>2013年4月10日更新：感谢<a href="http://weibo.com/liucy1983">@liu.cy</a>指出这里变量和类的区别</strong></li>
</ol>
<p>所以为了方便起见，请删除掉site.pp中的<code>import "node/*.pp"</code> 这行配置。我在这里就被郁闷了很久。</p>
<p>然后是我这里的想法是尽量不更改pp的语法，只是提供一个把group里的ip到fqdn的转化然后查找cluster配置组合成yaml。  <br />
也就是说有一个group的配置目录，其配置文件为&rdquo;groupname.pp&rdquo;，内容如下：</p>
<div class="highlight"><pre><code class="ruby"><span class="n">group</span> <span class="s2">&quot;groupname&quot;</span> <span class="p">{</span>
    <span class="vg">$string</span> <span class="o">=</span> <span class="s2">&quot;test&quot;</span>
    <span class="vg">$arrays</span> <span class="o">=</span> <span class="o">[</span><span class="mi">123</span><span class="p">,</span> <span class="n">abc</span><span class="o">]</span>
    <span class="kp">include</span> <span class="n">module1</span><span class="p">,</span> <span class="n">module2</span>
<span class="p">}</span>
</code></pre></div>
<p>还有一个iplist的配置目录，其配置文件为“groupname.iplist”，内容如下：</p>
<div class="highlight"><pre><code class="squid"><span class="mf">1.2.3.4</span><span class="w"></span>
<span class="mf">2.3.4.5</span><span class="w"></span>
</code></pre></div>
<p>那么以后服务器组有啥变更，只需要修改一下iplist就好了，不用重启puppet进程。    </p>
<p>所以有两个脚本，一个是 <code>external_node</code> 脚本：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/bin/env perl</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="n">autodie</span><span class="p">;</span>
<span class="k">use</span> <span class="n">DBI</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">YAML::</span><span class="n">Syck</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$base_dir</span> <span class="o">=</span> <span class="s">&quot;/etc/puppet/webui&quot;</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$node</span> <span class="o">=</span> <span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">my</span> <span class="nv">$group</span> <span class="o">=</span> <span class="n">sqlite_select</span><span class="p">(</span><span class="nv">$node</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$hash</span> <span class="o">=</span> <span class="n">pp2hashref</span><span class="p">(</span><span class="nv">$group</span><span class="p">);</span>
<span class="k">print</span> <span class="n">Dump</span><span class="p">(</span><span class="nv">$hash</span><span class="p">);</span>
<span class="c1"># ENC要求退出值必须为0 </span>
<span class="nb">exit</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">sub </span><span class="nf">pp2hashref</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$group</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nb">open</span> <span class="k">my</span> <span class="nv">$fh</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s">&quot;${base_dir}/group/${group}.pp&quot;</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$i</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="sr">&lt;$fh&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="sr"> /^#|^\s*$|}$/</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">elsif</span> <span class="p">(</span><span class="sr"> /^group\s+&quot;(\w+)&quot;/</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nb">die</span> <span class="s">&quot;group name do not match,check please!&quot;</span> <span class="k">unless</span> <span class="nv">$1</span> <span class="o">=~</span> <span class="sr">m/$group/i</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">elsif</span> <span class="p">(</span><span class="sr"> /^\s*?\$(\w+)\s*=\s*&quot;(.+)&quot;$/</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;parameters&quot;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;$1&quot;</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$2</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">elsif</span> <span class="p">(</span><span class="sr"> /^\s*?include\s+(.+)$/</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nv">@</span><span class="p">{</span><span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;classes&quot;</span><span class="p">}}</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/,\s*/</span><span class="p">,</span> <span class="nv">$1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">elsif</span> <span class="p">(</span><span class="sr"> /^\s*\$(\w+)\s*=\s*\[([^]]+)]?/</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nv">$i</span> <span class="o">=</span> <span class="nv">$1</span><span class="p">;</span>
            <span class="nb">grep</span> <span class="p">{</span> <span class="nb">push</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;parameters&quot;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;$i&quot;</span><span class="p">}},</span> <span class="nv">$_</span> <span class="p">}</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/,\s*/</span><span class="p">,</span> <span class="nv">$2</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">elsif</span> <span class="p">(</span><span class="sr"> /^\s*([^]]+)]?/</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nb">grep</span> <span class="p">{</span> <span class="nb">push</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;parameters&quot;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;$i&quot;</span><span class="p">}},</span> <span class="nv">$_</span> <span class="p">}</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/,\s*/</span><span class="p">,</span> <span class="nv">$1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">next</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">};</span>
    <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;parameters&quot;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;clustername&quot;</span><span class="p">}</span> <span class="o">=</span> <span class="nv">$group</span><span class="p">;</span>
    <span class="c1"># ENC要求输出的yaml中必须提供environment参数 </span>
    <span class="nv">$data</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;environment&quot;</span><span class="p">}</span> <span class="o">=</span> <span class="s">&quot;production&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nv">$data</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">sub </span><span class="nf">sqlite_select</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$node</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$dbh</span> <span class="o">=</span> <span class="n">DBI</span><span class="o">-&gt;</span><span class="nb">connect</span><span class="p">(</span><span class="s">&quot;dbi:SQLite:dbname=${base_dir}/node_info.db&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,{</span><span class="n">RaiseError</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span><span class="n">AutoCommit</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">});</span>
    <span class="k">my</span> <span class="nv">$sth</span> <span class="o">=</span> <span class="nv">$dbh</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">(</span><span class="s">&quot;select node_group from node_info where node_fqdn = ?&quot;</span><span class="p">);</span>
    <span class="nv">$sth</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;$node&quot;</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$ret</span> <span class="o">=</span> <span class="nv">$sth</span><span class="o">-&gt;</span><span class="n">fetchrow_hashref</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;node_group&quot;</span><span class="p">};</span>
    <span class="nv">$dbh</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">();</span>
    <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>一个是维护sqlite的脚本：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/bin/env perl</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="n">autodie</span><span class="p">;</span>
<span class="k">use</span> <span class="n">DBI</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Net::</span><span class="n">Nslookup</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$base_dir</span> <span class="o">=</span> <span class="s">&quot;/etc/puppet/webui&quot;</span><span class="p">;</span>
<span class="n">sqlite_update</span><span class="p">();</span>
<span class="k">sub </span><span class="nf">ip_conv</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$ip</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$name</span> <span class="o">=</span> <span class="n">nslookup</span><span class="p">(</span><span class="n">host</span> <span class="o">=&gt;</span> <span class="s">&quot;$ip&quot;</span><span class="p">,</span> <span class="n">type</span> <span class="o">=&gt;</span> <span class="s">&quot;PTR&quot;</span><span class="p">);</span>
    <span class="c1"># ENC的输入参数为全小写格式，所以sqlite中也必须存储小写格式的主机名 </span>
    <span class="k">return</span> <span class="nb">lc</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">sub </span><span class="nf">sqlite_rebuild</span> <span class="p">{</span>
    <span class="c1"># 配置系统变动不大，且puppet本身还有一层也是用sqlite的node配置缓存层，</span>
    <span class="c1"># 所以这里不用复杂的select判断再update或者insert，直接重建sqlite </span>
    <span class="nb">unlink</span> <span class="s">&quot;${base_dir}/node_info.db&quot;</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$dbh</span> <span class="o">=</span> <span class="n">DBI</span><span class="o">-&gt;</span><span class="nb">connect</span><span class="p">(</span><span class="s">&quot;dbi:SQLite:dbname=${base_dir}/node_info.db&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,{</span><span class="n">RaiseError</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span><span class="n">AutoCommit</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">});</span>
    <span class="k">my</span> <span class="nv">$sql</span> <span class="o">=</span> <span class="s">&#39;create table node_info (node_fqdn, node_group)&#39;</span><span class="p">;</span>
    <span class="nv">$dbh</span><span class="o">-&gt;</span><span class="k">do</span><span class="p">(</span><span class="nv">$sql</span><span class="p">);</span>
    <span class="c1"># sqlite支持简单事务，所以要即时提交 </span>
    <span class="nv">$dbh</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">();</span>
    <span class="k">my</span> <span class="nv">$sth</span> <span class="o">=</span> <span class="nv">$dbh</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">(</span><span class="s">&#39;replace into node_info values(?,?)&#39;</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">@groups</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span> <span class="sr">s/^${base_dir}\/iplist\/(\w+?).list$/$1/</span> <span class="p">}</span> <span class="nb">glob</span><span class="p">(</span><span class="s">&quot;${base_dir}/iplist/*&quot;</span><span class="p">);</span>
    <span class="k">print</span> <span class="nv">$_</span><span class="p">,</span><span class="s">&quot;\n&quot;</span> <span class="k">for</span> <span class="nv">@groups</span><span class="p">;</span>
    <span class="k">foreach</span> <span class="p">(</span> <span class="nv">@groups</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$group</span> <span class="o">=</span> <span class="nv">$_</span><span class="p">;</span>
        <span class="nb">open</span> <span class="k">my</span> <span class="nv">$fh</span><span class="p">,</span> <span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s">&quot;${base_dir}/iplist/${group}.list&quot;</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="sr">&lt;$fh&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">my</span> <span class="nv">$fqdn</span> <span class="o">=</span> <span class="n">ip_conv</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
            <span class="nv">$sth</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">(</span><span class="s">&quot;$fqdn&quot;</span><span class="p">,</span> <span class="s">&quot;$group&quot;</span><span class="p">);</span>
            <span class="nb">die</span> <span class="nv">$</span><span class="nn">DBI::</span><span class="nv">errstr</span> <span class="k">if</span> <span class="nv">$dbh</span><span class="o">-&gt;</span><span class="n">err</span><span class="p">();</span>
        <span class="p">};</span>
    <span class="p">};</span>
    <span class="nv">$dbh</span><span class="o">-&gt;</span><span class="n">commit</span><span class="p">();</span>
    <span class="nv">$dbh</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div>
<p>以上是ENC的配置。继续分析puppet dashboard，除了ENC外，另一个功能就是reports，相比ENC来说，reports功能还算稍微靠谱一点，用http方式替换puppet自身的store方式，并存数据在mysql里。目前使用dashboard的人主要也就是在用这个功能。  <br />
但是我个人认为，一般情况下运维不可能专门开一个页面看着puppet，也不太会有必要按照时间段查看状态报表汇总图这个东东，真正要紧的，是及时接到运行错误的报警以便上机处理。所以这里最后是一个监控reports的脚本，目前还没看到http方式的reports数据格式，所以暂时继续使用store的方式，然后采用Linux文件系统的inotify方式报警。</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!env perl</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">YAML::</span><span class="n">Syck</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">AnyEvent::Filesys::</span><span class="n">Notify</span><span class="p">;</span>
<span class="k">use</span> <span class="n">EV</span><span class="p">;</span>
<span class="c1"># 使用AE的这个扩展而不直接用Linux::Inotify2模块，方便万一之后迁移到BSD主机</span>
<span class="c1"># 而且异步回调的方式性能更好，在压力较大时不会阻塞丢失事件 </span>
<span class="k">my</span> <span class="nv">$notifier</span> <span class="o">=</span> <span class="nn">AnyEvent::Filesys::</span><span class="n">Notify</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span>
    <span class="n">dirs</span>     <span class="o">=&gt;</span> <span class="p">[</span><span class="sx">qw(/var/lib/puppet/reports)</span><span class="p">],</span>
    <span class="n">interval</span> <span class="o">=&gt;</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="c1"># 在puppetd请求的时候，会在目录下先生成临时文件，完成后再mv成正式的，所以要过滤</span>
    <span class="n">filter</span>   <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span> <span class="nb">shift</span> <span class="o">=~</span><span class="sr"> /\.yaml$/</span> <span class="p">},</span>
    <span class="n">cb</span>       <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="nv">@_</span> <span class="p">)</span> <span class="p">{</span>
            <span class="c1"># 一般这里会是两个type，创建的created和修改的modified，因为文件名只精确到分钟，如果两次运行在一分钟内，文件名就一样</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="n">type</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">my</span> <span class="nv">$file</span> <span class="o">=</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>
                <span class="k">my</span> <span class="nv">$logs</span> <span class="o">=</span> <span class="n">LoadFile</span><span class="p">(</span><span class="nv">$file</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;logs&#39;</span><span class="p">};</span>
                <span class="k">for</span> <span class="p">(</span> <span class="nv">@</span><span class="p">{</span><span class="nv">$logs</span><span class="p">}</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;level&#39;</span><span class="p">}</span> <span class="ow">eq</span> <span class="s">&#39;err&#39;</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">process</span><span class="p">(</span><span class="nv">$file</span><span class="p">,</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;message&#39;</span><span class="p">});</span>
                    <span class="p">};</span>
                <span class="p">};</span>
            <span class="p">};</span>
        <span class="p">};</span>
    <span class="p">},</span>
<span class="p">);</span>
<span class="nn">EV::</span><span class="n">loop</span><span class="p">();</span>
<span class="k">sub </span><span class="nf">process</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span> <span class="nv">$path</span><span class="p">,</span> <span class="nv">$message</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nv">$path</span> <span class="o">=~</span> <span class="sr">m/\/([^\/]+)\/\d{12}\.yaml$/</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1"># 这里用nagios还是email方式处理都可以，代码略</span>
        <span class="k">print</span> <span class="nv">$1</span><span class="p">,</span><span class="s">&quot; has err: &quot;</span><span class="p">,</span><span class="nv">$message</span><span class="p">,</span><span class="s">&quot;\n&quot;</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
      <a href="/2012/05/18/puppet-external-nodes-classifier" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/05/10/quick-start-for-puppet-facter-erb" title="【puppet系列】puppet安装／Facter插件和puppet模板编写" rel="bookmark">【puppet系列】puppet安装／Facter插件和puppet模板编写</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-05-10 00:00:00 +0800">10 May 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>使用puppet管理集群配置是个很靠谱的做法。跟其他同类产品相比，第一他的DSL语法很丰富够灵活，第二围绕他的生态圈活跃，资料比较多。</p>
<h1 id="puppet">puppet安装</h1>
<p>由于关注热度比较高，所以各种简便安装办法都出来了。大家可以各自选择，走yum、apt或者src都行。我这里演示一下用rubygems的办法。优点是不用像yum那样找epel源，而且版本够新，缺点是没有yum自动出来的配置目录和管理脚本。</p>
<div class="highlight"><pre><code class="bash"><span class="c">#!/usr/bin/env bash</span>
<span class="c"># Set Curlrc for https</span>
<span class="nb">echo</span> <span class="s1">&#39;insecure&#39;</span> &gt;&gt; ~/.curlrc
<span class="c"># Install git</span>
curl -L get-git.rvm.io | sudo bash
<span class="c"># Install RVM</span>
curl -L get.rvm.io | sudo bash -s stable
<span class="c"># Install Last Ruby</span>
<span class="nb">source</span> <span class="s2">&quot;/usr/local/rvm/scripts/rvm&quot;</span>
rvm install 1.9.3
<span class="c"># Use GEM Mirror in Taobao</span>
gem sources -r http://rubygems.org/
gem sources -a http://rubygems.taobao.org/
<span class="c"># Install puppet</span>
gem install puppet --no-ri --no-rdoc
groupadd puppet
useradd -g puppet -s /bin/false -M puppet
<span class="c"># Get default puppet config</span>
mkdir /etc/puppet
puppet --genconfig &gt; /etc/puppet/puppet.conf
</code></pre></div>
<p>需要说明一点，puppet对集群的识别高度依赖fdqn，所以必须保证主机名和IP的一一对应。我的环境里因为本身kerberos认证也是fdqn依赖的，所以反而省事不少，其他环境中，估计折腾dns或者hosts也是个大步骤。    </p>
<h1 id="facter">facter简介</h1>
<p>在安装puppet的时候，会顺带安装好facter工具，这个工具是用来探测本机各类变量，提供给puppetd使用的。    </p>
<p>因为facter也是ruby写的。所以我们可以自己根据其规则书写补充工具获取更多的变量，方便之后定制模块和类资源。</p>
<h1 id="puppetca">puppetca认证</h1>
<p>安装完成后需要建立认证关系。puppet没有像其他通用系统一样借用sshkey的认证，而是自己维护了一套，所以有这么个单独的章节：    </p>
<p>首先是客户端上的申请，没有单独的命令，就跟一次正常请求一样即可：    </p>
<div class="highlight"><pre><code class="bash">    puppetd --test --server master.pp.domain.com    
</code></pre></div>
<p>注意：因为puppet2.7和ruby1.9.2以上版本在ssl上的冲突，所以新版本ruby的client需要多几步处理：    </p>
<div class="highlight"><pre><code class="bash">scp master.puppet.domain.com:/etc/puppet/ssl/certs/ca.pem /etc/puppet/ssl/certs/
<span class="nb">hash</span><span class="o">=</span><span class="sb">`</span>openssl x509 -hash -noout -in /etc/puppet/ssl/certs/ca.pem<span class="sb">`</span>
ln -s /etc/puppet/ssl/certs/ca.pem /etc/pki/tls/certs/<span class="k">${</span><span class="nv">hash</span><span class="k">}</span>.0
</code></pre></div>
<p>这样才能正常申请cert。    </p>
<p>然后在主控端上审批。首先可以puppetca &ndash;list查看有多少请求过来的client是未认证的。然后运行如下命令通过：    </p>
<div class="highlight"><pre><code class="bash">    puppetca -s -a    
</code></pre></div>
<p>(吐槽一下，内网上已经有这么多认证了，还搞一套pp的，还搞出问题来了，有够无聊的，强烈希望pp提供一个开关)</p>
<h1 id="sitepp">site.pp简介</h1>
<p>/etc/puppet/manifests/site.pp是puppetmaster的总入口。在这里主要完成几个工作：加载模块(import &ldquo;module&rdquo;)；加载节点配置(node {})。    </p>
<p>模块的名字，就是直接来自于/etc/puppet/modules/dir_name的命名；而node里include包含的class类名，则是modules/dir_name/manifests/init.pp中写的名字。    </p>
<p>一般来说，这两个可以保持一致方便管理。但是规则毕竟如此，碰到不一致的还是要懂（我就是碰上不一致的样例才研究的）。    </p>
<p>node配置太多的话，可以另外写在别的目录和配置文件里。在site.pp中只要<code>include 'nodes/*.pp'</code>这样就可以了。</p>
<p>node配置主要三个部分：    </p>
<ol>
  <li>node的fdqn的正则匹配；    </li>
  <li>node的变量赋值；    </li>
  <li>node的特定类；    </li>
</ol>
<p>比如下面这个例子：</p>
<div class="highlight"><pre><code class="ruby"><span class="n">node</span> <span class="s2">&quot;cache[0-9]\.domain\.com&quot;</span> <span class="p">{</span>
  <span class="vg">$var</span> <span class="o">=</span> <span class="s2">&quot;strings&quot;</span>
  <span class="vg">$array</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="o">]</span>
  <span class="kp">include</span> <span class="n">facter</span> <span class="n">squid</span>
<span class="p">}</span>
</code></pre></div>
<h1 id="modules">modules简介</h1>
<p>模块中一定有manifests/init.pp作为入口，然后根据其中的定义，另外有templates和files作为辅助目录。    </p>
<p>init.pp中可以使用require &lsquo;other.pp&rsquo;指令来加载模块的其他配置。    </p>
<p>init.pp中可以使用puppet的各种资源，包括file、service、exec、package、cron、user等等。    </p>
<p>各种资源下有各种属性和方法可用，这里就不展开讲了，一来我也没掌握多少，二来真写全了够出书了。主要写关于file的几个，因为linux的本质就是All is file嘛~    </p>
<ol>
  <li>content:直接在puppet配置里写file的内容，一般只会在测试的时候这么直接用。更多的是用template(&lsquo;class/class.template.erb&rsquo;)的方式调用模板文件。    </li>
  <li>source:直接下载puppetmaster上的原始文件，具体url写法是puppet:///module/file。    </li>
  <li>notify:在客户端搞定file的写入后准备触发的下一个操作，一般用来重启服务(可以用service方法，也可以用exec方法)等等。    </li>
  <li>ensure:file的状态。比如absent是如果已存在的就删除掉；present是如果不存在就新建；directory是目录；latest是最新的包版本等等。    </li>
  <li>path:file在客户端的真是存放路径。如果没有定义，就是用name配置。    </li>
  <li>mode:file在客户端的权限，也就是644,755之类的。</li>
</ol>
<h1 id="template">template简介</h1>
<p>puppet用的erb模板引擎，也是RoR中用的模板引擎。看起来和Perl5中的Template::Toolkit相当的一样。尤其是&lt;%%&gt;里使用=和-的表现。    </p>
<p>我们可以在puppet里用erb完成比puppet语法复杂的多的功能，比如根据node的变量进行运算、循环、判断等等。    </p>
<h1 id="squid">squid示例</h1>
<p>最后举例今天完成的一个简单的squid的配置。</p>
<p>首先是/etc/puppet/manifests/site.pp：    </p>
<div class="highlight"><pre><code class="ruby"><span class="n">import</span> <span class="s2">&quot;squid&quot;</span>
<span class="n">node</span> <span class="s2">&quot;cache[0-9]\.domain\.com&quot;</span> <span class="p">{</span>
  <span class="vg">$cache_peers</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;1.2.3.4&#39;</span><span class="p">,</span> <span class="s1">&#39;1.2.3.5&#39;</span><span class="o">]</span>
  <span class="vg">$http_port</span> <span class="o">=</span> <span class="s2">&quot;8080&quot;</span>
  <span class="vg">$fs_type</span> <span class="o">=</span> <span class="s2">&quot;aufs&quot;</span>
<span class="c1">#  单独区分coss，是因为squid源码被修改过后，关于COSS的配置跟磁盘都是特制的，不能像原版那样计算了 </span>
<span class="c1">#  $fs_type = &quot;coss&quot;</span>
<span class="c1">#  $coss_options = &quot;/data/coss/stripe0 32 backstore=/data/coss/stripe4,32 max-size=1024768 block-size=1024&quot;</span>
  <span class="kp">include</span> <span class="n">facter</span> <span class="n">squid</span>
<span class="p">}</span>
</code></pre></div>
<p>然后是/etc/puppet/modules/facter/manifests/init.pp:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="n">facter</span> <span class="p">{</span>
    <span class="n">file</span> <span class="p">{</span> <span class="s2">&quot;df.rb&quot;</span><span class="p">:</span>
        <span class="n">path</span>   <span class="o">=&gt;</span> <span class="s2">&quot;/usr/lib/ruby/gems/1.8/gems/facter-1.6.8/lib/facter/df.rb&quot;</span><span class="p">,</span>
        <span class="k">ensure</span> <span class="o">=&gt;</span> <span class="n">file</span><span class="p">,</span>
        <span class="n">mode</span>   <span class="o">=&gt;</span> <span class="mi">644</span><span class="p">,</span>
        <span class="n">source</span> <span class="o">=&gt;</span> <span class="s2">&quot;puppet:///modules/facter/df.rb&quot;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>关于给facter写插件，网站的资料说的path都是直接在#{rubysitedir}/facter目录下。但我这里实际情况却不是(好吧，暴露了我的实验机并没有按照上面说的用rvm安装ruby而是yum的)。  <br />
<strong>2013年1月31日更正：</strong>
更优的做法应该是放在<code>#{puppetdir}/modules/yourmodule/lib/facter/</code>下，然后作为pluginsync发下去。
<strong>更正以上</strong></p>
<p>然后是对应的/etc/puppet/modules/facter/files/df.rb:</p>
<div class="highlight"><pre><code class="ruby"><span class="n">data_dir_list</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">df</span> <span class="o">=</span> <span class="ss">Facter</span><span class="p">:</span><span class="ss">:Util</span><span class="o">::</span><span class="no">Resolution</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="s2">&quot;/bin/df -m 2&gt;/dev/null&quot;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">each_line</span> <span class="k">do</span> <span class="o">|</span><span class="n">l</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">l</span> <span class="o">=~</span> <span class="sr">/^\/dev\/\w+\s+(\d+).+\/(data\d*)$/</span>
    <span class="n">data_dir_list</span><span class="o">[</span><span class="vg">$2</span><span class="o">]</span> <span class="o">=</span> <span class="vg">$1</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="no">Facter</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;DataDirCount&quot;</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">setcode</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">data_dir_list</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="n">data_dir_list</span><span class="o">.</span><span class="n">length</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">data_dir_list</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="o">|</span>
  <span class="no">Facter</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;DirSize_</span><span class="si">#{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">setcode</span> <span class="k">do</span>
      <span class="n">v</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>实现很简单，实质就是执行df -m，获取挂载点为/data、/data1&hellip;的目录数以及各目录的总大小，然后把结果添加到facter里。之所以要加这么个插件，是因为之后squid的缓存目录，需要根据目录数量和大小自动计算，而标准的facter里没有这方面的信息，无法传递相关变量。    </p>
<p>下面正式进入squid模块部分。看/etc/puppet/modules/squid/manifests/init.pp:</p>
<div class="highlight"><pre><code class="ruby"><span class="k">class</span> <span class="n">squid</span> <span class="p">{</span>
    <span class="n">service</span> <span class="p">{</span> <span class="s2">&quot;squid&quot;</span><span class="p">:</span>
        <span class="k">ensure</span>    <span class="o">=&gt;</span> <span class="n">running</span><span class="p">,</span>
        <span class="n">subscribe</span> <span class="o">=&gt;</span> <span class="no">File</span><span class="o">[</span><span class="s2">&quot;squid.conf&quot;</span><span class="o">]</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">file</span> <span class="p">{</span> <span class="s2">&quot;squid.conf&quot;</span><span class="p">:</span>
        <span class="n">path</span>    <span class="o">=&gt;</span> <span class="s2">&quot;/tmp/squid.conf&quot;</span><span class="p">,</span>
        <span class="n">notify</span>  <span class="o">=&gt;</span> <span class="no">Service</span><span class="o">[</span><span class="s2">&quot;squid&quot;</span><span class="o">]</span><span class="p">,</span>
        <span class="n">content</span> <span class="o">=&gt;</span> <span class="n">template</span><span class="p">(</span><span class="s2">&quot;squid/squid.conf.erb&quot;</span><span class="p">),</span>
        <span class="k">ensure</span>  <span class="o">=&gt;</span> <span class="n">present</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>这里只写了service和file两个，实际上还应该有package保证client上确实有squid软件，有file保证/etc/init.d/squid脚本存在等等。注意其中file里的notify和service里的subscribe正好是对应的意思。    </p>
<p>最后是/etc/puppet/squid/template/squid.conf.erb:</p>
<div class="highlight"><pre><code class="squid">&lt;%<span class="w"> </span>if<span class="w"> </span>(fs_type<span class="w"> </span>==<span class="w"> </span>&#39;aufs&#39;)<span class="w"> </span>-%&gt;<span class="w"></span>
<span class="k">cache_dir</span><span class="w"> </span>aufs<span class="w"> </span>/data/fcache<span class="w"> </span>&lt;%=<span class="w"> </span>Integer(dirsize_data.to_i*0.8)<span class="w"> </span>%&gt;<span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="m">256</span><span class="w"></span>
&lt;%<span class="w"> </span>if<span class="w"> </span>(datadircount.to_i<span class="w"> </span>&gt;<span class="w"> </span><span class="m">1</span>)<span class="w"> </span>-%&gt;<span class="w"></span>
&lt;%<span class="w"> </span><span class="m">1</span>.upto(datadircount.to_i<span class="w"> </span>-<span class="w"> </span><span class="m">1</span>).each<span class="w"> </span>do<span class="w"> </span>|i|<span class="w"> </span>-%&gt;<span class="w"></span>
&lt;%<span class="w"> </span>size<span class="w"> </span>=<span class="w"> </span>eval<span class="w"> </span>&quot;dirsize_data#{i}&quot;<span class="w"> </span>-%&gt;<span class="w"></span>
<span class="k">cache_dir</span><span class="w"> </span>aufs<span class="w"> </span>/data&lt;%=<span class="w"> </span>i<span class="w"> </span>%&gt;/fcache<span class="w"> </span>&lt;%=<span class="w"> </span>Integer(size.to_i*0.8)<span class="w"> </span>%&gt;<span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="m">256</span><span class="w"></span>
&lt;%<span class="w"> </span>end<span class="w"> </span>-%&gt;<span class="w"></span>
&lt;%<span class="w"> </span>end<span class="w"> </span>-%&gt;<span class="w"></span>
&lt;%<span class="w"> </span>else<span class="w"> </span>%&gt;<span class="w"></span>
<span class="k">cache_dir</span><span class="w"> </span>coss<span class="w"> </span>&lt;%=<span class="w"> </span>coss_options<span class="w"> </span>%&gt;<span class="w"></span>
&lt;%<span class="w"> </span>end<span class="w"> </span>%&gt;<span class="w"></span>
<span class="k">cache_mem</span><span class="w"> </span>&lt;%=<span class="w"> </span>Integer(memorysize.to_i<span class="w"> </span>*<span class="w"> </span><span class="m">0</span>.45<span class="w"> </span>*<span class="w"> </span><span class="m">1024</span>)<span class="w"> </span>%&gt;<span class="w"> </span>MB<span class="w"></span>
<span class="k">visible_hostname</span><span class="w"> </span>&lt;%=<span class="w"> </span>fqdn<span class="w"> </span>%&gt;<span class="w"></span>
<span class="k">http_port</span><span class="w"> </span>&lt;%=<span class="w"> </span><span class="k">http_port</span><span class="w"> </span>%&gt;<span class="w"> </span>vhost<span class="w"></span>
&lt;%<span class="w"> </span>cache_peers.each<span class="w"> </span>do<span class="w"> </span>|peer|<span class="w"> </span>-%&gt;<span class="w"></span>
<span class="k">cache_peer</span><span class="w"> </span>&lt;%=<span class="w"> </span>peer<span class="w"> </span>%&gt;<span class="w"> </span><span class="no">parent</span><span class="w"> </span><span class="m">80</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="no">no-query</span><span class="w"> </span>originserver<span class="w"> </span><span class="no">round-robin</span><span class="w"></span>
&lt;%<span class="w"> </span>end<span class="w"> </span>%&gt;<span class="w"></span>
</code></pre></div>
<p>这里只贴跟模板变量相关的部分。初学ruby，被to_i方法搞得很是郁闷，还好像eval方法之类的很像很眼熟~~  <br />
模板里cache_peers等，是在node配置里定义的；memorysize等，是facter获取的。</p>
      <a href="/2012/05/10/quick-start-for-puppet-facter-erb" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/05/08/collect-log-variables-by-ngx-lua" title="通过lua统计nginx内部变量数据" rel="bookmark">通过lua统计nginx内部变量数据</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-05-08 00:00:00 +0800">08 May 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#nginx-ref" title="nginx" rel="category tag">nginx</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>统计nginx的请求数据，一般有几个办法，一个是logrotate，通过access.log计算，这个很详细，但是实时性差一些；一个是Tengine提供的pipe，这个实时性更好，但是管道如果出现堵塞，麻烦就多了～这两种办法，归根结底都是把日志记录在本地(pipe方式如果要长期保留依然要记磁盘)然后由脚本完成计算。今天这里说另一种方法：在nginx内部，随着每次请求完成一些基础的数据统计，然后输出到存储里供长期调用。  <br />
代码如下：</p>
<div class="highlight"><pre><code class="nginx"><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">photo.domain.com</span><span class="p">;</span>
    <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
        <span class="kn">set</span> <span class="nv">$str</span> <span class="nv">$uri</span><span class="p">;</span>
        <span class="kn">content_by_lua</span> <span class="s">&#39;</span>
            <span class="s">local</span> <span class="s">url</span> <span class="p">=</span> <span class="s">ngx.var.uri</span>
            <span class="s">local</span> <span class="s">res</span> <span class="p">=</span> <span class="s">ngx.location.capture(&quot;/proxy&quot;,</span> <span class="p">{</span><span class="kn">vars</span> <span class="p">=</span> <span class="p">{</span> <span class="kn">str</span> <span class="p">=</span> <span class="s">url</span> <span class="err">}}</span><span class="s">)</span>
            <span class="s">ngx.print(res.body)</span>
            <span class="s">ngx.shared.log_dict:set(&quot;url&quot;,</span> <span class="s">url)</span>
            <span class="s">local</span> <span class="s">upstream_stat</span> <span class="p">=</span> <span class="s">ngx.var.status</span>
            <span class="s">local</span> <span class="s">upstream_time</span> <span class="p">=</span> <span class="s">tonumber(ngx.var.upstream_response_time)</span>
            <span class="s">local</span> <span class="s">redis</span> <span class="p">=</span> <span class="s">require</span> <span class="s">&quot;resty.redis&quot;</span>
            <span class="s">local</span> <span class="s">red</span> <span class="p">=</span> <span class="s">redis:new()</span>
            <span class="s">local</span> <span class="s">ok,</span> <span class="s">err</span> <span class="p">=</span> <span class="s">red:connect(&quot;127.0.0.1&quot;,</span> <span class="mi">6379</span><span class="s">)</span>
            <span class="s">if</span> <span class="s">upstream_stat</span> <span class="p">~</span><span class="sr">=</span> <span class="s">&quot;200&quot;</span> <span class="s">then</span>
                <span class="s">red:sadd(&quot;url&quot;,url)</span>
                <span class="s">red:incr(url)</span>
                <span class="s">red:incr(url..&quot;:time&quot;,</span> <span class="s">upstream_time)</span>
            <span class="s">end</span>
         <span class="s">&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kn">location</span> <span class="s">/dict_status</span> <span class="p">{</span>
        <span class="kn">content_by_lua</span> <span class="s">&#39;</span>
            <span class="s">local</span> <span class="s">url</span> <span class="p">=</span> <span class="s">ngx.shared.log_dict:get(&quot;url&quot;)</span>
            <span class="s">ngx.say(url)</span>
         <span class="s">&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kn">location</span> <span class="s">/redis_status</span> <span class="p">{</span>
        <span class="kn">content_by_lua</span> <span class="s">&#39;</span>
            <span class="s">local</span> <span class="s">redis</span> <span class="p">=</span> <span class="s">require</span> <span class="s">&quot;resty.redis&quot;</span>
            <span class="s">local</span> <span class="s">red</span> <span class="p">=</span> <span class="s">redis:new()</span>
            <span class="s">local</span> <span class="s">ok,err</span> <span class="p">=</span> <span class="s">red:connect(&quot;127.0.0.1&quot;,</span> <span class="mi">6379</span><span class="s">)</span>
            <span class="s">local</span> <span class="s">urlist,err</span> <span class="p">=</span> <span class="s">red:sort(&quot;url&quot;,&quot;limit&quot;,&quot;0&quot;,&quot;1&quot;,&quot;desc&quot;,&quot;by&quot;,&quot;*&quot;)</span>
            <span class="s">if</span> <span class="s">not</span> <span class="s">urlist</span> <span class="s">then</span>
                <span class="s">ngx.say(err)</span>
                <span class="s">return</span>
            <span class="s">end</span>
            <span class="s">for</span> <span class="s">i</span> <span class="p">=</span> <span class="mi">1</span><span class="s">,</span> <span class="c1">#urlist do</span>
                <span class="s">local</span> <span class="s">avg</span> <span class="p">=</span> <span class="s">red:get(urlist[i])</span>
                <span class="s">local</span> <span class="s">sum</span> <span class="p">=</span> <span class="s">red:get(urlist[i]..&quot;:time&quot;)</span>
                <span class="s">ngx.say(urlist[i],&quot;\tavg_time:&quot;,avg/sum,</span> <span class="s">&quot;\tsum:&quot;,sum)</span>
            <span class="s">end</span>
         <span class="s">&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kn">location</span> <span class="s">/proxy</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://backend_fmn_xnimg_cn</span><span class="nv">$str</span><span class="p">;</span>
        <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="s">&#39;fmn.rrimg.com&#39;</span><span class="p">;</span> 
        <span class="kn">include</span> <span class="s">conf.d/proxy.conf</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>ngx_lua里的指令有set/rewrite/header_filter/log/content/access_by_lua等，它们各自处于nginx处理流程中的某一步，所以有些日志变量可能不一定都能读取到。还有header_filter和log两个不能调用subrequest和output的API(也就是只能使用上例代码中的ngx.shared.DICT方式，但只支持简单的key-value),content不能和proxy_pass在一起等等……</p>
<p>不过content里可以调用ngx.location.capture()来subrequest其他location，比如这里利用/proxy来完成原来的proxy_pass的功能。  <br />
因为subrequest后$uri有变化，所以pass必须写对真正的url的全路径。这就靠之前的set $str来传递变量了。    </p>
<p>最终运行结果：</p>
<pre><code># curl http://fmn.rrimg.cn/redis_status    
/test avg_time:0.73 sum:12
</code></pre>
      <a href="/2012/05/08/collect-log-variables-by-ngx-lua" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/04/30/reading-notes-about-linux-system" title="Linux系统调优读书笔记" rel="bookmark">Linux系统调优读书笔记</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-04-30 00:00:00 +0800">30 Apr 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#linux-ref" title="linux" rel="category tag">linux</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>今天在图书馆看书，摘抄一些有意思的细节。</p>
<h1 id="linux">Linux服务器性能调整</h1>
<p>Linux内存布局NUMA：  <br />
    非一致性读取 每个节点；  <br />
    每个节点下有 多个管理区(ZONE)内存块；  <br />
    内存块包括：  <br />
        ZONE_DMA 0~16MB  <br />
        ZONE_NORMAL 16~896MB
        ZONE_HIGHMEM 896MB~结束  <br />
    32位处理器下，用户空间3GB，内核空间1GB；  <br />
        内核空间除去ZONE_DMA和ZONE_NORMAL后只剩下128MB用来vmalloc/kmap等操作；  <br />
        kmap操作用来虚拟化页表数据位，可以在32位处理器下支持64GB内存。 <br />
    NUMA结构下8节点的互连结构，只是3个相互最近的互连；  <br />
    不同节点之间的定时器很难一致，通常选一个做唯一定时。    </p>
<p>多处理SMP：  <br />
    松耦合系统：每个处理器都有自己的总线、内存和IO系统；  <br />
    紧耦合系统：只运行一个OS；  <br />
      对称系统均分任务；  <br />
      非对称系统有一个主控处理器；  <br />
        cache是否共享？内存、总线和IO子系统肯定是共享的，cache会带来一致性问题；  <br />
        锁竞争导致的开销，所以N个处理器不能达到N倍效率提升；  <br />
        affinity即绑定进程到CPU，让进程跟cache更近。  <br />
          linux里进程是高权的线程（一般说法是反过来说线程是小型的进程）    </p>
<p>集群cluster：  <br />
    高性能：分布式任务并行处理，100+节点，通称为计算机；  <br />
    高可用：故障问题，最多16节点，通常2~4节点，通称为企业服务器。    </p>
<p>系统跟踪前提：  <br />
    容量足够；开销较小；场景可重现；尽量无其他进程干扰除非是场景本身需要。    </p>
<p>strace命令场景：  <br />
    判断IO阻塞，内存分配及其频率等。    </p>
<p>OProfile：
    opcontrol命令：设置的count要足够大，否则中断本身次数会影响结果。</p>
<p>内核调度器：  <br />
    优先级0~MAX_PRIO(140)；  <br />
    0~100为实时任务；  <br />
    101~140为分时任务，即nice命令调整的-20~19。    </p>
<p>I/O调度器：  <br />
    deadline：  <br />
      read_expire;  <br />
      seek_cost=(x+stream_unit-1)/stream_unit，默认stream_unit为4字节；  <br />
      write_starved：读优先N次后才写；    </p>
<p>文件系统：  <br />
    hdparm：MaxMultSect参数，默认16，当前都支持32位输出了。    </p>
<p>网络：  <br />
    tcp_window_scaling、tcp_sack、tcp_fsack等。    </p>
<p>进程间通信：  <br />
    ipcs -u查看状态；  <br />
    ipcs -l查看限制。    </p>
<p>数据库：  <br />
    OLTP在线事务处理的业务类型类似小文件，一般文件块大小在2KB左右；  <br />
    DSS决策支持系统的业务类型类似大文件，一般文件块大小在8KB以上。    </p>
<h1 id="section">网站性能监测与优化</h1>
<p>Netflix的Jiffy是客户端收集的开源项目；  <br />
  sqmphoniq即是服务器端分析，也要客户端js的支持；  <br />
  Episodes同上。    </p>
<h1 id="jruby">JRuby语言实战技术</h1>
<p>类与超类：  <br />
    所有类的超类都是Object；  <br />
    所有类都是类Class的对象。</p>
<h1 id="hadoop">Hadoop实战</h1>
<p>chukwa监控系统：  <br />
    在HDFS和Map/Reduce的基础上，即意味着日志非tail方式，而是有collector先行合并成大文件再存储到HDFS；  <br />
    致力于2000+节点，1TB+日志量的集群日志分析，即意味着非实时性；  <br />
    数据结果目前还是存MySQL里再web展示，可能会转移到HBase上。  <br />
    流程架构类似如下：  <br />
        N个agents(每台server一个) &ndash;HTTP&ndash;&gt; M个collectors(每百个agent一个) &ndash;sink&ndash;&gt; HDFS &ndash;map/reduce&ndash;&gt; MySQL &lt;&ndash;JSP/JS&ndash;&gt; Web(HICC)  <br />
    整个流程跟logstash很类似，但是logstash没有固定hadoop平台，所以不用sink这步，实时性更好；而agent的input代码段就类似于执行类似map的工作，output段就是reduce结果了。</p>
      <a href="/2012/04/30/reading-notes-about-linux-system" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/04/21/backup-blog-to-51cto" title="51CTO博客自动发布脚本" rel="bookmark">51CTO博客自动发布脚本</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-04-21 00:00:00 +0800">21 Apr 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/bin/env perl</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">File::</span><span class="n">Util</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">YAML::</span><span class="n">Syck</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Perl6::</span><span class="n">Say</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">XMLRPC::</span><span class="n">Lite</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Data::</span><span class="n">Dumper</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$f</span> <span class="o">=</span> <span class="nn">File::</span><span class="n">Util</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@blogs</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span><span class="sr">/\.markdown$/</span><span class="p">}</span> <span class="nv">$f</span><span class="o">-&gt;</span><span class="n">list_dir</span><span class="p">(</span><span class="s">&#39;../_posts&#39;</span><span class="p">,</span> <span class="s">&#39;--recurse&#39;</span><span class="p">);</span>
<span class="k">foreach</span> <span class="p">(</span><span class="nv">@blogs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$yaml</span> <span class="o">=</span> <span class="n">LoadFile</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$title</span> <span class="o">=</span> <span class="nv">$yaml</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;title&#39;</span><span class="p">};</span>
    <span class="k">my</span> <span class="nv">$text</span> <span class="o">=</span> <span class="nv">$f</span><span class="o">-&gt;</span><span class="n">load_file</span><span class="p">(</span><span class="s">&quot;$_&quot;</span><span class="p">);</span>
    <span class="n">upload</span><span class="p">(</span><span class="nv">$title</span><span class="p">,</span> <span class="nv">$text</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">sub </span><span class="nf">upload</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$title</span><span class="p">,</span> <span class="nv">$text</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$username</span> <span class="o">=</span> <span class="s">&#39;username&#39;</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$password</span> <span class="o">=</span> <span class="s">&#39;password&#39;</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$blogid</span>   <span class="o">=</span> <span class="s">&#39;123456&#39;</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$proxyurl</span> <span class="o">=</span> <span class="s">&#39;http://blogname.blog.51cto.com/xmlrpc.php&#39;</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nn">XMLRPC::</span><span class="n">Lite</span><span class="o">-&gt;</span><span class="n">proxy</span><span class="p">(</span><span class="nv">$proxyurl</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">call</span><span class="p">(</span><span class="s">&#39;metaWeblog.newPost&#39;</span><span class="p">,</span> <span class="nv">$blogid</span><span class="p">,</span> <span class="nv">$username</span><span class="p">,</span> <span class="nv">$password</span><span class="p">,</span> <span class="p">{</span> <span class="n">title</span> <span class="o">=&gt;</span> <span class="s">&quot;$title&quot;</span><span class="p">,</span> <span class="n">description</span> <span class="o">=&gt;</span> <span class="s">&quot;$text&quot;</span><span class="p">,</span> <span class="n">categories</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s">&#39;【创作类型:原创】&#39;</span><span class="p">,</span><span class="s">&#39;IT管理&#39;</span><span class="p">,</span> <span class="p">]},</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
    <span class="n">say</span> <span class="s">&quot;newPost id -- &quot;</span> <span class="o">.</span> <span class="nv">$res</span> <span class="k">if</span> <span class="nv">$res</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>目前还有几个问题：</p>
<ol>
  <li>虽然写了创作类型是原创，但是发布后还是转载；</li>
  <li>categories的数组生成的xml格式是<array><data><value><base64>，但通过wireshark抓包windows live writer看到能被api接收的格式应该是<array><data><value><string>。在XMLRPC::Lite的代码中，有as_base64/as_string等好几个方法，但是找到从哪里定义使用，目前简单的采用注释掉了XMLRPC::Lite::Serializer::new()方法里的base64键值对，但是理论上应该不用修改源码的；</string></value></data></array></base64></value></data></array></li>
  <li>最后一个最关键的问题，不管我在服务器上是用utf8还是gb2312，上传后都是乱码。估计第一个问题其实也是由此产生的。</li>
</ol>
      <a href="/2012/04/21/backup-blog-to-51cto" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/04/18/get-location-of-some-companys" title="获取造价百强公司的真实位置" rel="bookmark">获取造价百强公司的真实位置</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-04-18 00:00:00 +0800">18 Apr 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>很久没更新，没用技术，今天稍微geek一下下。给老婆搜索她行业百强公司的具体地点，看看如果换单位的话是否方便出行~代码如下：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl</span>
<span class="k">use</span> <span class="nn">Data::</span><span class="n">Dumper</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">LWP::</span><span class="n">UserAgent</span><span class="p">;</span>
<span class="k">use</span> <span class="n">URI</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Web::</span><span class="n">Scraper</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">JSON::</span><span class="n">XS</span><span class="p">;</span>
<span class="c1"># 处理中文需要指定输入输出都用utf8格式，否则会有wide character in print的warning提示 </span>
<span class="k">use</span> <span class="n">utf8</span><span class="p">;</span>
<span class="nb">binmode</span><span class="p">(</span><span class="bp">STDIN</span><span class="p">,</span> <span class="s">&#39;:encoding(utf8)&#39;</span><span class="p">);</span>
<span class="nb">binmode</span><span class="p">(</span><span class="bp">STDOUT</span><span class="p">,</span> <span class="s">&#39;:encoding(utf8)&#39;</span><span class="p">);</span>
<span class="nb">binmode</span><span class="p">(</span><span class="bp">STDERR</span><span class="p">,</span> <span class="s">&#39;:encoding(utf8)&#39;</span><span class="p">);</span>
<span class="c1"># 百度地图搜索的查询结果返回的是json数据，需要转换成perl的哈希格式 </span>
<span class="k">sub </span><span class="nf">decode_map_json</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$map_json</span> <span class="o">=</span> <span class="n">decode_json</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="c1"># 如果是距离搜索，那么$map_json-&gt;{&quot;content&quot;}-&gt;[0]-&gt;{&quot;lines&quot;}-&gt;[0]-&gt;[2]是距离；$map_json-&gt;{&quot;taxi&quot;}-&gt;{&quot;detail&quot;}-&gt;[0]-&gt;{&quot;totalPrice&quot;}是打的费用。</span>
    <span class="k">return</span> <span class="nv">$map_json</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;content&quot;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&quot;addr&quot;</span><span class="p">};</span>
<span class="p">};</span>
<span class="c1"># 用LWP发起地图查询请求 </span>
<span class="k">sub </span><span class="nf">get_map_json</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$company</span> <span class="o">=</span> <span class="nv">$_</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$ua</span> <span class="o">=</span> <span class="nn">LWP::</span><span class="n">UserAgent</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nv">$ua</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://map.baidu.com/?qt=s&amp;wd=&#39;</span><span class="o">.</span><span class="nv">$company</span><span class="p">);</span>
    <span class="k">return</span> <span class="nv">$res</span><span class="o">-&gt;</span><span class="n">decoded_content</span> <span class="k">if</span> <span class="nv">$res</span><span class="o">-&gt;</span><span class="n">is_success</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1"># 采用Web::Scraper获取网页里的XPath内容 </span>
<span class="k">sub </span><span class="nf">get_company</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$ori_uri</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="c1"># 可以在firefox里直接查看元素的XPath，在google chrome里则需要安装Xpath Helper工具。</span>
    <span class="c1"># 安装完成后，使用Ctrl+Shift+X快捷键呼出顶端Xpath调试框，然后按住Shift键，用鼠标左键点击网页元素，上边框里就出现元素的Xpath和content了。</span>
    <span class="c1"># 注意复制过来的Xpath里的@会被perl理解成是数组的标示，所以要加上逃逸符\才行。</span>
    <span class="k">my</span> <span class="nv">$tweets</span> <span class="o">=</span> <span class="n">scraper</span> <span class="p">{</span>
        <span class="n">process</span> <span class="s">&quot;/html/body/div[\@class=&#39;index-main layout&#39;]/div[\@class=&#39;index-main layout&#39;]/div[\@class=&#39;index-content bcolor&#39;]/div[\@class=&#39;cont&#39;]/div[\@id=&#39;fontzoom&#39;]/span[\@id=&#39;BodyLabel&#39;]/div/table&quot;</span><span class="p">,</span> <span class="s">&quot;list&quot;</span> <span class="o">=&gt;</span> <span class="n">scraper</span> <span class="p">{</span>
            <span class="c1"># 第一个scraper里不能获取tbody，原因未知。所以分成两步，先获取一个到table的scraper，再获取tbody里面的TEXT。</span>
            <span class="n">process</span> <span class="s">&quot;tbody tr td:nth-child(2)&quot;</span><span class="p">,</span> <span class="s">&#39;cont[]&#39;</span> <span class="o">=&gt;</span> <span class="s">&#39;TEXT&#39;</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">};</span>
    <span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="nv">$tweets</span><span class="o">-&gt;</span><span class="n">scrape</span><span class="p">(</span><span class="n">URI</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span><span class="nv">$ori_uri</span><span class="p">));</span>
    <span class="k">return</span> <span class="nv">$res</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;list&#39;</span><span class="p">}</span><span class="o">-&gt;</span><span class="p">{</span><span class="s">&#39;cont&#39;</span><span class="p">};</span>
<span class="p">};</span>
<span class="k">my</span> <span class="nv">$company</span> <span class="o">=</span> <span class="n">get_company</span><span class="p">(</span><span class="s">&#39;http://www.ceca.org.cn/show.aspx?id=2006&#39;</span><span class="p">);</span>
<span class="k">foreach</span><span class="p">(</span><span class="nv">@$company</span><span class="p">){</span>
    <span class="k">print</span> <span class="nv">$_</span><span class="p">,</span><span class="s">&quot;\t&quot;</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$json</span> <span class="o">=</span> <span class="n">get_map_json</span><span class="p">(</span><span class="nv">$_</span><span class="p">);</span>
    <span class="k">print</span> <span class="n">decode_map_json</span><span class="p">(</span><span class="nv">$json</span><span class="p">),</span><span class="s">&quot;\n&quot;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>输出结果如下：    </p>
<pre><code>单位名称	
上海东方投资监理有限公司	中国·上海市江宁路1306弄7号富丽大厦23楼
中冶京诚工程技术有限公司	白广路4号
中铁工程设计咨询集团有限公司	
中冶赛迪工程技术股份有限公司	重庆市渝中区双钢路一号
中国电力工程顾问集团西南电力设计院	
上海第一测量师事务所有限公司	澳门路519弄1-5号
中竞发（北京）工程造价咨询有限公司	知春路108号豪景大厦A座13层
</code></pre>
<p>搜狗地图的api只是js的，不方便弄。不然直接获取从当前地点到目的地点的距离和耗时就更好了~~百度地图页面上就没看到有api提供，虽然用着，还是鄙视一下~~</p>
      <a href="/2012/04/18/get-location-of-some-companys" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/04/16/configs-automatically-effective-for-elastic-monitor" title="弹性集群监控中的配置自动生效问题研究" rel="bookmark">弹性集群监控中的配置自动生效问题研究</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-04-16 00:00:00 +0800">16 Apr 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>最近跟<a href="http://weibo.com/fedoracore">@画圈圈的星星</a> 聊天，说到nagios在大规模集群运用中一个比较严重的瓶颈：修改配置需要重启进程。 <br />
听起来似乎不是什么问题，我个人之前对nagios的追求，也都放在怎么样提供一个及时高效的监控和数据展示上面&mdash;-这两个问题在 <code>mod_gearman</code> 和 <code>pnp4nagios</code> 的协助下已经很给力了。    </p>
<p>但是聊天中提到了一个新的场景，事实上早在两个月前，<a href="http://weibo.com/tjpm">@GNUer</a> 就提到过类似的场景，就是当 nagios 监控的是这样一个弹性集群的时候：</p>
<pre><code>集群设备数以千记，甚至是上万的规模；
而且设备上运行着复杂的应用，每台设备都有几十上百的监控项需求；
为了提供高可靠性，集群以资源池的方式运行，即设备随时可能更改当前应用角色，在idle/lb/cache/web/app/db/storage等之间切换；
</code></pre>
<p>以上。    </p>
<p>尤其是最后一条，假如这个更改频率快到了每分钟都有变更，那么 nagios 重启进程这点就足以打死它了。实际运行中我们可以知道，当 <code>nagios reload</code> 的时候，这个命令的执行本身就要花费远大于1分钟的时间。    </p>
<p>临时的办法，就是在更改后不主动 reload，而是在 crontab 里定时去做。损失一些监控实时性。一般来说，还不至于真的同一台设备一分钟内连续更改角色并且需要分别监控的。    </p>
<p>但是真要做到实时，应该怎么做呢？    </p>
<p>首先想到的是 <code>mod_gearman</code> 的基础上进行改造。我们之前已经知道，<code>mod_gearman</code> 上是可以分别有 host_check/service_check/check_result 几个 jobs 的。那么，我们可以跳过 config 阶段，自己写 gearman client 发送 job 。这一步很容易。难点是 check_result 被 nagios 回收后，我们自己发的 job，其 host/service 在 nagios 的 service_list 结构里是不存在的&hellip;&hellip;所以还要自己写 gearman worker 来回收 result，具体来说，必须要做的事情包括有：根据 performance_data 来 create 和 update 相应的 rrds；根据 exit status 来启动 notification。这个工作内容一下子达到自己重写一个比较完整的监控系统的地步了，而且你如果通过原版的 cgi 查看，这部分内容还查看不到&hellip;&hellip;    </p>
<p>于是我在 github 上询问 <code>mod_gearman</code> 的作者<a href="https://github.com/sni">Sven Nierlein</a> ，他回答说：</p>
<pre><code>There is no such feature right now and it would be very hard to implement such thing in nagios or icinga.
It should be easier to implement something like that in shinken, but i guess it still takes 2-3 weeks of development.
</code></pre>
<p>好吧，比较失望的回答。尝试去瞄一眼 nagios-src，在 base/events.c 里可以看到，nagios 是在读取完全部 config 之后，才进入 loop，并提供 eventbroker 的 api 的。    </p>
<p>shinken 是完全重写过的披着 nagios 皮的监控系统，在 <a href="http://shinken.ideascale.com/">shinken 的 suggestion 征集页面</a> 上，我看到也有一位提议：<a href="http://shinken.ideascale.com/a/dtd/Arbiter-configuration-without-reloading-daemon/323455-10373">Arbiter configuration without reloading daemon</a>，不过应者寥寥，看来这种需求真的是极少数人才会碰到的。    </p>
<p>既然说到用 gearman，又说到监控，再回头看看去年提到的 cloudforecast。在 <code>ConfigLoader.pm</code> 中，可以看到一个 <code>watchdog</code> 方法。具体代码如下：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">my</span> <span class="nv">$watcher</span> <span class="o">=</span> <span class="nn">Filesys::Notify::</span><span class="n">Simple</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span><span class="o">\</span><span class="nv">@path</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="nv">$watcher</span><span class="o">-&gt;</span><span class="nb">wait</span><span class="p">(</span> <span class="k">sub </span><span class="p">{</span>
            <span class="k">my</span> <span class="nv">@path</span> <span class="o">=</span> <span class="nb">grep</span> <span class="p">{</span> <span class="nv">$_</span> <span class="o">!~</span> <span class="sr">m![/\\][\._]|\.bak$|~$!</span>  <span class="p">}</span> <span class="nb">map</span> <span class="p">{</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">path</span><span class="p">}</span> <span class="p">}</span> <span class="nv">@_</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">if</span> <span class="o">!</span> <span class="nv">@path</span><span class="p">;</span>
            <span class="nn">CloudForecast::</span><span class="n">Log</span><span class="o">-&gt;</span><span class="nb">warn</span><span class="p">(</span> <span class="s">&quot;File updates: &quot;</span> <span class="o">.</span> <span class="nb">join</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="nv">@path</span><span class="p">)</span> <span class="p">);</span>
            <span class="nb">sleep</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nb">kill</span> <span class="s">&#39;TERM&#39;</span><span class="p">,</span> <span class="nv">$parent_pid</span><span class="p">;</span>
            <span class="nb">exit</span><span class="p">;</span>
        <span class="p">}</span> <span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>可以看到，其实现方法是通过另起进程，通过 inotify 监听文件修改的方式，&rdquo;实时&rdquo;的重启主进程。实质上与 nagios 并无区别，都是要重新加载内存中保存的整个监控项配置列表。虽然没有大压力运用，但是可以猜测在预设环境中，重启耗时也会是瓶颈。    </p>
<p>另外一个监控系统 zabbix，与上面两个系统都不同，他的监控配置，不是通过文件方式存在监控服务器上，而是通过 web 操作保存在数据库里。整个 host/item/template 等等都是鼠标点击即可。    </p>
<p>zabbix 我的使用经验不多，只在三年前用它的预设步骤的方式监控过网页性能。印象中在 create graph 后需要等待一定时间后才能反映出结果。但不确定这个时间是监控项排队消耗的，还是监控进程重启消耗掉的。    </p>
<p>和<a href="http://weibo.com/frankymryao">@超大杯摩卡星冰乐</a> 询问了一下，只能猜测或许是通过循环 scan table 的方式&rdquo;实时&rdquo;的添加&rdquo;新&rdquo;监控项到监控进程的队列里。或许也得跟分析 nagios 一样看看代码才知道是否能在本文预设的弹性环境下适用了。</p>
      <a href="/2012/04/16/configs-automatically-effective-for-elastic-monitor" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/03/18/postgreSQL-DBA-2000-note2" title="PostgreSQL中国用户会DBA2000培训计划北京第二课笔记" rel="bookmark">PostgreSQL中国用户会DBA2000培训计划北京第二课笔记</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-03-18 00:00:00 +0800">18 Mar 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#database-ref" title="database" rel="category tag">database</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <h2 id="section">运行维护</h2>
<h3 id="vacuum">vacuum命令</h3>
<p>pgsql是multi-version concurrency control的，update和delete的操作并不会真正的修改原版本的内容，而只是做一个标记，最后需要用vacuum命令回收失效版本的位置。<br />
vacuum的主要作用：
1. 恢复或重用失效的空间；
2. 更新pgsql规划器的数据统计；
3. 避免事务ID的重复。
事务ID只有32位，差不多40亿左右。建议在达到10亿左右的时候就需要vacuum一次。<br />
在version8.*之后，默认就是用auto vacuum。注意auto vacuum不是定时启动，而是触发式的。</p>
<p>vacuum命令有两种形式：
1. vacuum，正常情况，不阻塞读写。
2. vacuum full，使用全表排他锁，不可读，产生最小大小的数据文件。不建议在7*24的生产环境使用。</p>
<p>vacuum full命令的操作原理简述：
1. 标记旧数据；
2. 移动数据成连续空间；
3. 截断文件。</p>
<h3 id="reindex">reindex命令</h3>
<p>在version7.4之后，该命令不再需要经常性运行了。<br />
执行该命令会阻塞写操作。读操作照常。</p>
<h3 id="analyze">analyze命令</h3>
<p>建议规划一个database范围的analyze，然后每天运行看效果。</p>
<h2 id="section-1">存储过程</h2>
<h3 id="plpgsql">pl/pgsql示例：</h3>
<div class="highlight"><pre><code class="sql"><span class="k">CREATE</span> <span class="k">FUNCTION</span> <span class="n">func_name</span> <span class="p">(</span> <span class="k">option</span> <span class="k">type</span> <span class="p">)</span> <span class="k">RETURNS</span>
    <span class="k">type</span> <span class="k">AS</span> <span class="err">$$</span>
    <span class="p">...</span>
</code></pre></div>
<h3 id="section-2">触发器示例：</h3>
<div class="highlight"><pre><code class="sql"><span class="k">CREATE</span> <span class="k">FUNCTION</span> <span class="k">trigger_name</span> <span class="p">(</span> <span class="k">option</span> <span class="k">type</span> <span class="p">)</span> <span class="k">RETURNS</span>
    <span class="n">tirgger</span> <span class="k">AS</span> <span class="err">$$</span>
<span class="k">DECLARE</span> <span class="p">...</span>
<span class="k">BEGIN</span>
    <span class="p">....</span>
    <span class="k">RETURN</span> <span class="k">NEW</span><span class="o">/</span><span class="k">NULL</span> <span class="cm">/*NULL就回滚上面的操作*/</span>
<span class="k">END</span>
</code></pre></div>
<h3 id="section-3">调试</h3>
<p>图形化安装时带有的pgadmin3里有一项debugger。<br />
配置：shared_preload_libraries=&rdquo;$libdir/plugins/plugin_debugger.so&rdquo;<br />
导入：debugger.sql</p>
<h2 id="section-4">监控</h2>
<ol>
  <li>data/pg_log/*.log</li>
</ol>
<p>标示等级一般为：通用等级LOG NOTICE，错误等级FATAL ERROR，提示等级LOG HINT
一般有一个startup.log文件记录启动过程；一些以时间为名字的日志，记录运行过程，每当文件超过10MB，每次重启，以及每过一整天的时候，就会生成一个新文件。</p>
<ol>
  <li>pgadmin3</li>
</ol>
<p>通过server status看锁状态，杀进程等。</p>
<ol>
  <li>psql命令</li>
</ol>
<div class="highlight"><pre><code class="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">pg_stat_activetity</span><span class="p">;</span>
</code></pre></div>
<p>配置：log_min_duration_statement，设置慢查询日志的时限，单位为毫秒。</p>
<h2 id="section-5">集群</h2>
<h3 id="section-6">8.*时代</h3>
<p>复制以WAL File为单位，一旦丢失，就可能损失16MB的事务。而且standby不可读。</p>
<h3 id="section-7">9.*时代</h3>
<p>复制以WAL中的record为单位，且standby可以读操作，能设置成读写分离集群。
9.0中只有异步复制；9.1中有同步复制。</p>
<h3 id="section-8">主要方案</h3>
<p>PGPool II等</p>
      <a href="/2012/03/18/postgreSQL-DBA-2000-note2" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/03/17/postgreSQL-DBA-2000-note1" title="PostgreSQL中国用户会DBA2000培训计划北京第一课笔记" rel="bookmark">PostgreSQL中国用户会DBA2000培训计划北京第一课笔记</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-03-17 00:00:00 +0800">17 Mar 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#database-ref" title="database" rel="category tag">database</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <h1 id="postgresql">PostgreSQL及中国用户会简介</h1>
<p>主讲人 李元佳 galy</p>
<h2 id="section">数据库分类</h2>
<p>商业数据库: Oracle, DB2, SQLserver, Sybase&hellip;
  开源数据库: MySQL, PostgreSQL, Firebird, SQLite, Apache Derby&hellip;</p>
<h2 id="postgresql-1">PostgreSQL沿革</h2>
<p>类BSD许可的，面向对象的，关系型数据库管理系统。</p>
<p>MIT &ndash;&gt; Ingres &ndash;&gt; Postgres &ndash;&gt; PostgreSQL ( 同源的还有SQLserver等 )</p>
<p>支持SQL2008标准的大部分功能特性，是各种RDBMS的SQL方言中最贴近标准的。</p>
<h1 id="postgresql-2">PostgreSQL简介</h1>
<p>主讲人 萧少聪 Scott.Siu</p>
<h2 id="section-1">用户与进程</h2>
<p><img src="/images/uploads/pgsql-process.png" alt="postgreSQL中用户与进程的联系" /></p>
<p>注意在上图中，不管是workmem还是sharebuffer，每个page都是8KB大小。</p>
<h2 id="section-2">复制流程</h2>
<p>stream replica的流程如下：</p>
<pre><code>client --&gt; postgres --&gt; WAL (not file)--&gt; slave --&gt; (return OK) --&gt; master --&gt; commit
</code></pre>
<p>在master上的流程细节如下：</p>
<pre><code>client --&gt; write-ahead log(WAL) buffer --&gt; commit --&gt; (async/fsync~~160%) --&gt; WAL Files (16MB * 132个)
   ^
   |--&gt; share buffer  --&gt; bgwriter --&gt; db files
             ^                            |
             |--        check point     &lt;-- ## 安装
</code></pre>
<p>linux: 注意使用独立的非root用户来安装启动pgsql。在version9.1后，可以跟SElinux结合使用，提高安全性。<br />
  win: 只能在NTFS文件系统上创建表空间。<br />
  窗口统一式安装，可以方便的安装stack builder套件。</p>
<h2 id="section-3">目录</h2>
<p>默认使用窗口安装的情况下，目录结构如下：</p>
<pre><code>/opt/PostgreSQL/9.1/
    |
    |--&gt; bin/
    |--&gt; doc/
    |--&gt; include/
    |--&gt; lib/
    |--&gt; share/
    |--&gt; install/
    |--&gt; data/
           |--&gt; base/		存放table和index的ID号
           |--&gt; global/
           |--&gt; pg_clog/	运行日志
           |--&gt; pg_xlog/	WAL日志
           |--&gt; pg_tblspc/	表空间ID，实质为到真实数据目录的软连接
           |--&gt; postgresql.conf
           |--&gt; pg_hba.conf
</code></pre>
<h2 id="section-4">创建</h2>
<ol>
  <li>使用bin/initdb命令；  </li>
  <li>修改data/pg_hba.conf里的连接地址段和登录权限；  </li>
  <li>修改data/postgresql.conf里的监听网卡。</li>
</ol>
<h2 id="section-5">启动与停止</h2>
<p>使用bin/pg_ctl命令。其停止命令可指定三种类型：</p>
<ol>
  <li>smart模式，即等待全部client连接断开后停止；  </li>
  <li>fast模式，即直接回滚全部尚未完成的事务后停止；  </li>
  <li>immediate模式，即立刻中止全部进程。</li>
</ol>
<h2 id="section-6">配置说明</h2>
<ol>
  <li>
    <p>work_mem:  <br />
并不是每个client连接的postgres进程分配一个work mem，而是SQL每一次的排序work使用一个work mem。包括join和order by。如果没有排序，就不用work mem。如果一条sql里同时使用了N次排序，那么就要使用N个work mem。所以理想的使用方法不是提供太大的work mem来排序，而是尽量缩小需要排序的数据大小，设置为4/8MB即可。  <br />
该配置是可以online修改的。命令如下：  <br />
 SET work_mem = 2048;
 SET work_mem = &lsquo;2MB&rsquo;;
上面两条命令等价。可以看书其计量单位为1KB，且类型为字符串，所以在自定义计量时需要用引号。</p>
  </li>
  <li>
    <p>share_buffers:  <br />
理论上为机器物理内存的40%大小。实际测试显示大于8GB后，性能不会有相应的提升，即可认为最大设置到8GB。</p>
  </li>
  <li>
    <p>temp_buffers:  <br />
无修改意义</p>
  </li>
  <li>
    <p>max_prepared_transactions:  <br />
并发事务数</p>
  </li>
  <li>
    <p>maintenance_work_mem:  <br />
vacuum、create index、alter table add foreign key等管理命令使用的work_mem，建议设置1G。因为这些命令经常涉及全表扫描。</p>
  </li>
</ol>
<h2 id="postgresql-3">postgreSQL的数据集概念</h2>
<pre><code>                      DataBase Cluster
                             |
                   |---------|---------|
                   |         |         |
                 user     database   tablespace
                             |
                           schema
</code></pre>
<p>这里的cluster不是HA cluster，而是数据集。<br />
  一个database里可以有多个schema，一个user可以有多个schema的管理权限，但一个schema只能归属于一个user。<br />
  默认有一个template0为schema的基础，不可修改，在template0基础上有template1，可以修改。实际创建schema时就是复制template1出来。
  创建user时，一般都会再创建一个同名的schema，并规定该schema的所属人为该user。这样在pgsql连接到database后，其默认schema即为该同名schema。</p>
<h2 id="section-7">备份与恢复</h2>
<h3 id="section-8">备份</h3>
<p>pg_dump命令，使用-s指定只备份数据结构，-t指定只备份数据内容。</p>
<h3 id="section-9">基于时间点的备份恢复</h3>
<ol>
  <li>select pg_start_backup(&lsquo;FullBackup&rsquo;);</li>
  <li>tar zcvf full_backup/week1.tgz /opt/PostgreSQL/9.1/data/</li>
  <li>
    <p>select pg_stop_backup();</p>
  </li>
  <li>tar zxvf full_backup/week1.tgz -C /</li>
  <li>echo &lsquo;restore_command=&rdquo;cp %f %p&rdquo;&rsquo; &gt; data/recovery.conf</li>
</ol>
      <a href="/2012/03/17/postgreSQL-DBA-2000-note1" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/03/10/go-deep-into-nginx-operation" title="加强了解nginx的几个问题" rel="bookmark">加强了解nginx的几个问题</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-03-10 00:00:00 +0800">10 Mar 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#nginx-ref" title="nginx" rel="category tag">nginx</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>被问到一些关于nginx或者说nginx运维相关的问题，记录下来几个值得思考的。这里面有些是自己曾经想到过但是浅浅的了解下就不放在心上的，有些是根本没想过这会成为一个&rdquo;有意思&rdquo;的问题的&hellip;&hellip;</p>
<h2 id="nginxclientip">1、nginx日志记录得到client的IP原理。</h2>
<p>nginx记录的client的IP分两种，一种是$remote_addr，一种是$http_x_forwarded_for。其中X-Forwarded-For里存放的是proxy加入的client端IP，通过http header传递的。而$remote_addr是TCP上的结果。但是具体如何不知道。今天回来翻nginx的src，先从定义nginx变量的ngx_http_variable.c看到$remote_addr是这样来的:</p>
<div class="highlight"><pre><code class="c"><span class="n">ngx_http_variable_remote_addr</span><span class="p">(</span><span class="kt">ngx_http_request_t</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span>
    <span class="kt">ngx_http_variable_value_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">connection</span><span class="o">-&gt;</span><span class="n">addr_text</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">no_cacheable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">not_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">v</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">connection</span><span class="o">-&gt;</span><span class="n">addr_text</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">NGX_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>然后可以在ngx_http.h和ngx_http_request.h里看到</p>
<div class="highlight"><pre><code class="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">ngx_http_request_s</span>     <span class="kt">ngx_http_request_t</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">struct</span> <span class="n">ngx_http_request_s</span> <span class="p">{</span>
    <span class="kt">uint32_t</span>                          <span class="n">signature</span><span class="p">;</span>         <span class="cm">/* &quot;HTTP&quot; */</span>
    <span class="kt">ngx_connection_t</span>                 <span class="o">*</span><span class="n">connection</span><span class="p">;</span>
    <span class="kt">ngx_buf_t</span>                        <span class="o">*</span><span class="n">header_in</span><span class="p">;</span>
    <span class="kt">ngx_http_headers_in_t</span>             <span class="n">headers_in</span><span class="p">;</span>
    <span class="kt">ngx_http_headers_out_t</span>            <span class="n">headers_out</span><span class="p">;</span>
    <span class="kt">ngx_http_request_body_t</span>          <span class="o">*</span><span class="n">request_body</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<p>然后在ngx_connection.c里看到</p>
<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;ngx_core.h&gt;</span>
<span class="p">...</span>
<span class="kt">ngx_listening_t</span> <span class="o">*</span>
<span class="n">ngx_create_listening</span><span class="p">(</span><span class="kt">ngx_conf_t</span> <span class="o">*</span><span class="n">cf</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sockaddr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">socklen</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">ngx_listening_t</span>  <span class="o">*</span><span class="n">ls</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr</span>  <span class="o">*</span><span class="n">sa</span><span class="p">;</span>
    <span class="n">u_char</span>            <span class="n">text</span><span class="p">[</span><span class="n">NGX_SOCKADDR_STRLEN</span><span class="p">];</span>
    <span class="n">ls</span> <span class="o">=</span> <span class="n">ngx_array_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">cycle</span><span class="o">-&gt;</span><span class="n">listening</span><span class="p">);</span>
    <span class="n">ngx_memzero</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">ngx_listening_t</span><span class="p">));</span>
    <span class="n">sa</span> <span class="o">=</span> <span class="n">ngx_palloc</span><span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">socklen</span><span class="p">);</span>
    <span class="n">ngx_memcpy</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">sockaddr</span><span class="p">,</span> <span class="n">socklen</span><span class="p">);</span>
    <span class="n">ls</span><span class="o">-&gt;</span><span class="n">sockaddr</span> <span class="o">=</span> <span class="n">sa</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">ngx_sock_ntop</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">NGX_SOCKADDR_STRLEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">ls</span><span class="o">-&gt;</span><span class="n">addr_text</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ngx_pnalloc</span><span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">ngx_memcpy</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">addr_text</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">};</span>
</code></pre></div>
<p>在ngx_core.h中，加载了</p>
<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;ngx_socket.h&gt;</span>
</code></pre></div>
<p>所以结果就是说，nginx日志里记载的$remote_addr变量，就是由connection的socket里获得的。在socket.h里可以看到accept函数的定义：</p>
<div class="highlight"><pre><code class="c"><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
</code></pre></div>
<p>另外，nginx上除了$remote_addr变量外，还有一个$binary_remote_addr变量。而且在ngx_http_variables.c里，根据是否是IPv6协议，做了区分，最终地址是通过r-&gt;connection结构体里的sockaddr-&gt;sin_addr获得。</p>
<p>目前就看到这里了&hellip;&hellip;关于socket如何从监听套接字上获得IP并建立连接套接字的，以后再继续研究TCP层上的知识。</p>
<h2 id="cookie-insert">2、cookie insert原理在负载均衡上是如何实现的。</h2>
<p>作7层负载均衡的时候，会遇到cookie类型的会话保持。</p>
<p>一般的session保持办法，是利用源地址哈希(source-hash)的办法，把同一个来源客户(实际通常是同一个C段的IP)，固定指向后端的同一台机器。</p>
<p>而利用cookie的办法，则是在负载均衡器上，给响应客户请求的http-response-header里Set-Cookie字段添加上有关内容，然后根据客户请求的http-request-header里Cookie的该字段内容，分发到和之前一样的后端服务器上。</p>
<p>在nginx上没有标准模块完成这个事情，不过可以用<a href="http://wiki.nginx.org/HttpMapModule">map功能</a>进行简单的模拟，如下：</p>
<div class="highlight"><pre><code class="nginx">    <span class="k">map</span> <span class="nv">$COOKIE_route</span> <span class="nv">$group</span> <span class="p">{</span>  
         <span class="kn">700003508</span>     <span class="s">admin</span><span class="p">;</span>  
         <span class="kn">~*3$</span>     <span class="s">admin</span><span class="p">;</span>  
         <span class="kn">default</span>   <span class="s">user</span><span class="p">;</span>  
     <span class="p">}</span>  
     <span class="k">upstream</span> <span class="s">backend_user</span> <span class="p">{</span>  
         <span class="kn">server</span>   <span class="n">10.3.24.11</span><span class="p">:</span><span class="mi">8080</span><span class="p">;</span>  
     <span class="p">}</span>  
     <span class="k">upstream</span> <span class="s">backend_admin</span> <span class="p">{</span>  
         <span class="kn">server</span>   <span class="n">10.3.25.21</span><span class="p">:</span><span class="mi">8081</span><span class="p">;</span>  
     <span class="p">}</span>  
     <span class="k">server</span> <span class="p">{</span>  
         <span class="kn">listen</span>       <span class="mi">80</span><span class="p">;</span>  
         <span class="kn">server_name</span>  <span class="s">photo.domain.com</span><span class="p">;</span>  
         <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>  
             <span class="kn">proxy_pass</span>            <span class="s">http://backend_</span><span class="nv">$group</span><span class="p">;</span>  
         <span class="p">}</span>  
     <span class="p">}</span>  
</code></pre></div>
<p>不过nginx社区有第三方模块叫做&rdquo;nginx-sticky-module&rdquo;的，用来完成这个功能。项目托管在googlecode上，具体地址是<a href="http://code.google.com/p/nginx-sticky-module">http://code.google.com/p/nginx-sticky-module</a>。具体实现的效果是首先根据轮训RR随机到某台后端，然后在响应的Set-Cookie上加上route=md5(upstream)字段，第二次请求再处理的时候，发现有route字段，直接导向原来的那台服务器。</p>
<p>编译后启用配置如下：</p>
<div class="highlight"><pre><code class="nginx"><span class="k">upstream</span> <span class="p">{</span>
  <span class="kn">sticky</span> <span class="s">[name=route]</span> <span class="s">[domain=.domain.com]</span> <span class="s">[path=/]</span> <span class="s">[expires=1h]</span> <span class="s">[hash=index|md5|sha1]</span> <span class="s">[no_fallback]</span><span class="p">;</span>
  <span class="kn">server</span> <span class="n">127.0.0.1</span><span class="p">:</span><span class="mi">9000</span><span class="p">;</span>
  <span class="kn">server</span> <span class="n">127.0.0.1</span><span class="p">:</span><span class="mi">9001</span><span class="p">;</span>
  <span class="kn">server</span> <span class="n">127.0.0.1</span><span class="p">:</span><span class="mi">9002</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="nginxworker80">3、nginx是多worker的，但是80端口只能有一个占用，这一段的工作原理是怎样的？</h2>
<p>这个问题的回答其实在第一个问题上已经部分涉及到了。就是socket的两个分类，一个是监听套接字，一个是连接套接字。占用80端口的，是使用的监听套接字。而worker里使用的，是accept之后建立的连接套接字。</p>
<p>正常情况下，nginx对worker加锁，在每一时刻，只有一个worker获得accept的权力。当监听的socket可以accept的时候，即有新链接时，主进程通过epoll的方式处理，先把这个事件保存起来，等通过锁的竞争选取一个worker后，再由这个worker真正的执行accept创建连接套接字，然后主进程返回监听状态。</p>
<p>代码中主要是ngx_trylock_accept_mutex()函数和ngx_process_events_and_timers()函数等，不过这个看不太懂，更多是根据别人的描述文章了。</p>
<h2 id="section">4、一致性哈希的原理。</h2>
<p>在7层负载均衡的时候，经常会利用到哈希。关于nginx上的url_hash和consistent_hash模块，我在2年前曾经简单的看过，博文链接如下：</p>
<ol>
  <li><a href="http://chenlinux.com/2010/03/15/consistent_hash/">url_hash的perl脚本模拟</a></li>
  <li><a href="http://chenlinux.com/2010/03/16/implement-consistent_hash-by-perl/">consistent_hash的perl脚本模拟</a></li>
</ol>
<p>两年后回头来看当初的脚本，真是很烂。不过从关键的uri和peer都取CRC32和取值做减法还是可以看出来一致性哈希的原理，即将节点通过哈希取值后均匀分布在一个0-9999999999的&rsquo;圆环&rsquo;上。然后要存储的url同样的算法取哈希值后，放进这个&rdquo;圆环&rdquo;里，顺时针方向离他最近的那个节点，即为他实际存储的节点。</p>
<p>在CPAN上，其实有<a href="http://search.cpan.org/~bradfitz/Set-ConsistentHash-0.92/lib/Set/ConsistentHash.pm">Set::ConsistentHash</a>模块可以看。如果是简单运用的话，<a href="http://search.cpan.org/~karavelov/Hash-ConsistentHash-0.05/lib/Hash/ConsistentHash.pm">Hash::ConsistentHash</a>模块是基于Set::ConsistentHash模块封装的易用版本。示例如下：</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="nn">Hash::</span><span class="n">ConsistentHash</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">String::</span><span class="n">CRC32</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$chash</span> <span class="o">=</span> <span class="nn">Hash::</span><span class="n">ConsistentHash</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span> <span class="n">buckets</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="n">A</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="n">C</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">},</span>
                                       <span class="n">hash_func</span><span class="o">=&gt;\&amp;</span><span class="n">crc32</span><span class="p">,</span>
                                     <span class="p">);</span>
<span class="k">my</span> <span class="nv">$server</span> <span class="o">=</span> <span class="nv">$chash</span><span class="o">-&gt;</span><span class="n">get_bucket</span><span class="p">(</span><span class="s">&#39;foo&#39;</span><span class="p">);</span>
</code></pre></div>
<h2 id="inotify">5、inotify丢事件。</h2>
<p>这个问题没有碰到过，只在网上看到过一篇<a href="http://doc.chinaunix.net/linux/201007/687123.shtml">Linux事件监控机制遗漏事件问题的相关分析</a>，里面提到&rdquo;发现在过于频繁的往目录下添加文件和目录的时候,会丢事件&rdquo;。但是只提到了这么个问题，然后通过重复添加监听解决问题，没有提到原因。</p>
<p>我个人疑心，会不会是sysctl参数没有设置好的原因呢？</p>
<p>sysctl里关于inotify的参数有三个，如下：</p>
<div class="highlight"><pre><code class="bash"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="nv">$ </span>sudo /sbin/sysctl -a|grep inotify
fs.inotify.max_queued_events <span class="o">=</span> 16384
fs.inotify.max_user_watches <span class="o">=</span> 8192
fs.inotify.max_user_instances <span class="o">=</span> 128
</code></pre></div>
<p>上示是默认值，明显偏小。比方sersync2方案中，启动前就要求修改这些值到50000000。如果启动的时候在sysctl范围内，启动时没问题的，但是迅速的添加到了范围外，那么应该就会出这个问题了。</p>
<p>当然，以上是我个人猜测，也说不准真的是inotify本身却有问题。</p>
<h2 id="nginxworkercpu">7、nginx的worker是怎么绑定到cpu上的？</h2>
<p>nginx有一个配置，就是启动多个worker的时候，可以使用cpu_affinity配置将worker分别绑定在不同的cpu上。</p>
<p>如果有8个cpu，那么相应参数就是：</p>
<p>00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000</p>
<p>也就是类似占位符一样一个位置代表一个CPU。如果按照普通理解的二进制，那么0011不是第三个CPU而是绑定在第1和第2个CPU上平均……</p>
<p>这种写法，是由操作系统决定的。在nginx的ngx_process_cycle.c中，相关内容如下：</p>
<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;ngx_config.h&gt;</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ngx_worker_process_init</span><span class="p">(</span><span class="kt">ngx_cycle_t</span> <span class="o">*</span><span class="n">cycle</span><span class="p">,</span> <span class="kt">ngx_uint_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cpu_affinity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sched_setaffinity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="kt">cpu_set_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cpu_affinity</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>在ngx_config.h中:</p>
<div class="highlight"><pre><code class="c"><span class="cp">#elif (NGX_LINUX)</span>
<span class="cp">#include &lt;ngx_linux_config.h&gt;</span>
</code></pre></div>
<p>在ngx_linux_config.h中:</p>
<div class="highlight"><pre><code class="c"><span class="cp">#include &lt;sched.h&gt;</span>
</code></pre></div>
<p>其实可以直接通过man sched_setaffinity看说明：</p>
<div class="highlight"><pre><code class="c">       <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sched</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
       <span class="kt">int</span> <span class="n">sched_setaffinity</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpusetsize</span><span class="p">,</span>
                             <span class="kt">cpu_set_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">);</span>
</code></pre></div>
<p>关于这个*mask，man文档之后描述如下：</p>
<pre><code>   The  actual  system
   call  interface is slightly different, with the mask being typed as unsigned long *, reflecting
   that the fact that the underlying implementation of CPU sets is a simple bitmask.
</code></pre>
<p>bitmask就是上面说到的那个意思了~~</p>
<h2 id="section-1">8、某应用经过7层负载均衡访问应用服务器，因业务需要设置了5秒无响应即返回502错误。有反馈说全网范围内5%的访问出现错误，如何判断问题具体出在哪里？</h2>
<p>这个问题目前我还想不到有什么特别简捷的办法。靠类似nagios那样的定时监测，肯定是很不容易抓到错误的。如果靠debug日志或者strace命令啊，tcpdump命令啊的，在高流量的情况下，又太容易淹没在海量的正常数据里了。</p>
<p>另一个猜测是连接数满了，TCP的或者HTTP的。不过按理说负载均衡器上应该有监控，不至于到这么危急的时候还是通过客户端访问来反馈问题&hellip;&hellip;</p>
      <a href="/2012/03/10/go-deep-into-nginx-operation" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2012/03/04/magic-about-perl-subroutine-return-value" title="perl函数返回值引起的误会" rel="bookmark">perl函数返回值引起的误会</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2012-03-04 00:00:00 +0800">04 Mar 2012</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>在微博上偶然看到有位<a href="http://weibo.com/iheartbeat" title="南唐古韵">@南唐古韵</a>童鞋发了一条关于perl的：</p>
<pre><code>发现perl的一个bug：（2**3）**2=8
</code></pre>
<p>显然perl不可能真的犯这么白痴的错误，那么问题在哪呢？我们先看看下面这个判断：</p>
<div class="highlight"><pre><code class="perl"><span class="p">[</span><span class="n">root</span><span class="nv">@localhost</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;print &quot;OK&quot; if (2**3)**2 == 8&#39;</span>
<span class="p">[</span><span class="n">root</span><span class="nv">@localhost</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;print &quot;OK&quot; if (2**3)**2 == 64&#39;</span>
<span class="n">OK</span>
<span class="p">[</span><span class="n">root</span><span class="nv">@localhost</span> <span class="o">~</span><span class="p">]</span><span class="c1">#</span>
</code></pre></div>
<p>一目了然，运算肯定是正确的。那上面那位童鞋的话是怎么得出来的呢？稍微想想，猜他可能是这样：</p>
<div class="highlight"><pre><code class="perl"><span class="p">[</span><span class="n">root</span><span class="nv">@localhost</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;print (2**3)**2&#39;</span>
<span class="mi">8</span>
</code></pre></div>
<p>哇，真的变成8啦？！</p>
<p>其实都是因为print搞的鬼啦~print作为内置的命令，我们在书写的时候经常用空格分隔开参数，而不记得其实标准的应该用中括号括起来的~
也就是说，其实上面那行命令应该是：</p>
<div class="highlight"><pre><code class="perl"><span class="p">[</span><span class="n">root</span><span class="nv">@localhost</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;print(2**3) **2&#39;</span>
</code></pre></div>
<p>然后下一个问题：在print之后还有一个**2啊，既然前面已经执行完成一个print命令，后面再加个东西，咋不会报错呢？</p>
<p>这就是涉及到关键了，perl的print执行也是有返回值的，真为1，假为0。也就是说，上面的命令其实是先执行了2的3次方得到8，然后执行print输出&rdquo;8&rdquo;到STDOUT并且返回1；然后执行1的2次方得到1；程序结束。</p>
<p>我们可以这样验证一下：</p>
<div class="highlight"><pre><code class="perl"><span class="p">[</span><span class="n">root</span><span class="nv">@AY110907102215177d47d</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;print (2**3)**2&#39;</span>
<span class="mi">8</span><span class="p">[</span><span class="n">root</span><span class="nv">@AY110907102215177d47d</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;$r=print (2**3)**2;print $r&#39;</span>
<span class="mi">81</span><span class="p">[</span><span class="n">root</span><span class="nv">@AY110907102215177d47d</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;$r=print (2**3)*2;print $r&#39;</span>
<span class="mi">82</span><span class="p">[</span><span class="n">root</span><span class="nv">@AY110907102215177d47d</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;$r=print (2**3)*2,&quot;\n&quot;;print $r&#39;</span>
<span class="mi">82</span><span class="p">[</span><span class="n">root</span><span class="nv">@AY110907102215177d47d</span> <span class="o">~</span><span class="p">]</span><span class="c1"># perl -e &#39;$r=print (2**3,&quot;\n&quot;)*2;print $r&#39;</span>
<span class="mi">8</span>
<span class="mi">2</span><span class="p">[</span><span class="n">root</span><span class="nv">@AY110907102215177d47d</span> <span class="o">~</span><span class="p">]</span><span class="c1"># </span>
</code></pre></div>
<p>因为要给print造一个返回值为假的示例不太容易，所以举一个1*2=2/0*2=0来证明咯~至于加上的&rdquo;\n&rdquo;测试，更进一步证明它跟print无关啦~~</p>
      <a href="/2012/03/04/magic-about-perl-subroutine-return-value" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div id="post-pagination" class="pagination pagination-centered">
  <ul class="pages nav nav-pills">
    <li>
      <a href="/page3">Previous</a>
    </li>
    <li class="page">
      <a href="/">1</a>
    </li>
    <li class="page">
      <a href="/page2">2</a>
    </li>
    <li class="page">
      <a href="/page3">3</a>
    </li>
    <li class="page active">
      <a href="#">4</a>
    </li>
    <li class="page">
      <a href="/page5">5</a>
    </li>
    <li class="page">
      <a href="/page6">6</a>
    </li>
    <li class="page">
      <a href="/page7">7</a>
    </li>
    <li class="page">
      <a href="/page8">8</a>
    </li>
    <li class="page">
      <a href="/page9">9</a>
    </li>
    <li class="page">
      <a href="/page10">10</a>
    </li>
    <li class="page">
      <a href="/page11">11</a>
    </li>
    <li class="page">
      <a href="/page12">12</a>
    </li>
    <li class="page">
      <a href="/page13">13</a>
    </li>
    <li class="page">
      <a href="/page14">14</a>
    </li>
    <li class="page">
      <a href="/page15">15</a>
    </li>
    <li class="page">
      <a href="/page16">16</a>
    </li>
    <li>
      <a href="/page5">Next</a>
    </li>
  </ul>
</div>
</div>
      </div>
      <div class="span4">
          <div class="well sidebar-nav">
             <ul id="relate_blog" class="nav nav-list">
               <li class="nav-header">最近文章</li>
            </ul>
          </div>
        <div class="well sidebar-nav">
          <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=0&skin=2&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1035836154&verifier=a26926d5&dpc=1"></iframe>
        </div>
        <div class="well sidebar-nav">
            <!--以下是QQ邮件列表订阅嵌入代码-->
            <script >var nId = "86cca8e03c1002936e00aaa28bd933c15c4a437a5e63cafd",nWidth="auto",sColor="light",sText="填写您的邮件地址，订阅logstash/ElasticSearch相关讨论：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>
        </div>
        <div class="well sidebar-nav">
            <div id="uyan_list_time_frame"></div>
            <script type="text/javascript" id="UYScriptTime" src="http://v1.uyan.cc/js/iframe_time_list.js?UYUserId=1589850&rankType=time" async=""></script>
        </div>
        <div class="well sidebar-nav">
          <ul id="linklists" class="nav nav-list">
            <li class="nav-header">友情链接(英文)</li>
              <li><a href="http://codeascraft.com/" title="Etsy 运维团队博客">Code as Craft</a></li>
              <li><a href="http://blog.dotcloud.com/" title="dotCloud 官方博客">dotCloud-Blog</a></li>
              <li><a href="http://devopsanywhere.blogspot.jp/" title="">devopsanywhere</a></li>
              <li><a href="http://www.jedi.be/blog/" title="">Jong En Dynamische Informatica</a></li>
              <li><a href="http://www.planetdevops.net/" title="">planetdevops</a></li>
              <li><a href="http://www.kitchensoap.com/" title="《网站运维》作者，Etsy 运维">Kitchen Soap</a></li>
              <li><a href="http://blog.johngoulah.com" title="Musings of linux, open source, cloud computing and systems">John Goulah</a></li>
              <li><a href="http://serverfault.com/" title="stackexchange下属的系统工程师问答网站">serverfault</a></li>
              <li><a href="http://www.thegeekstuff.com/" title="各种超酷Linux命令用法">TheGeekStuff</a></li>
              <li><a href="http://neilb.org/" title="The good,the bad,and the beautiful">neilb</a></li>
              <li><a href="http://blog.aka-cool.net/" title="">Aka.Why</a></li>
              <li><a href="http://www.reddit.com/r/perl/" title="">reddit perl 频道</a></li>
          </ul>
        </div>
        <div class="well sidebar-nav">
          <ul id="linklists" class="nav nav-list">
            <li class="nav-header">友情链接(中文)</li>
              <li><a href="http://www.icylife.net/blog/" title="">心路</a></li>
              <li><a href="http://dbahacker.com/" title="TB 杨德华">DBA Hacker</a></li>
              <li><a href="http://www.nginxs.com/" title="">eric</a></li>
              <li><a href="http://www.hellodb.net/" title="Ali DBA 张瑞">Hello DBA</a></li>
              <li><a href="http://blog.laird-sa.com/" title="">Laird-SA</a></li>
              <li><a href="http://www.linuxsee.com/" title="">LinuxSEE</a></li>
              <li><a href="http://blog.nosqlfan.com/" title="not only sql信息集散地">NoSQLfan</a></li>
              <li><a href="http://ourmysql.com/" title="">OurMySQL</a></li>
              <li><a href="http://www.puppeter.cn/" title="">piol</a></li>
              <li><a href="http://www.ducea.com/" title="">MDLog:/sysadmin</a></li>
              <li><a href="http://www.sanote.org/" title="">sa note</a></li>
              <li><a href="http://zauc.wordpress.com/" title="">Timo</a></li>
              <li><a href="http://julyclyde.org/" title="新浪系统工程师">七月的夏天</a></li>
              <li><a href="http://www.liurongxing.com/" title="">刘荣星</a></li>
              <li><a href="http://blog.s135.com/" title="金山·张宴">回忆未来</a></li>
              <li><a href="http://blog.ops.tudou.com/wp/" title="">土豆运营团队</a></li>
              <li><a href="http://www.91tuanfang.com/" title="安居客运维">家欣的天空</a></li>
              <li><a href="http://www.cnadn.net/" title="F5工程师">应用交付学习之路</a></li>
              <li><a href="http://scmbob.org/" title="杭州NSN工程师，shell高人~">扛一肩记忆</a></li>
              <li><a href="http://www.php-oa.com/" title="音悦台技术经理">扶凯</a></li>
              <li><a href="http://www.wenzizone.cn/" title="">蚊子世界</a></li>
              <li><a href="http://www.opboy.com" title="">运维小子</a></li>
              <li><a href="http://blog.liuts.com/" title="前天涯SA 刘天斯">运维进行时</a></li>
              <li><a href="http://www.lark.net.cn/" title="lark's cloud">lark's cloud</a></li>
              <li><a href="http://log.heartoutside.com/" title="HeartOutSide">HeartOutside</a></li>
              <li><a href="http://blog.liulantao.com/" title="刘兰涛">Lax</a></li>
              <li><a href="http://l09.me/" title="风声">风声</a></li>
              <li><a href="http://niubie.me/" title="莫言">莫言</a></li>
              <li><a href="http://mooser.me/" title="牛氓">牛氓</a></li>
              <li><a href="http://http://www.yinwang.org/" title="当然我在扯淡">当然我在扯淡</a></li>
              <li><a href="http://noops.me/" title="小米运维部">NoOps</a></li>
              <li><a href="http://www.searchtech.pro/" title="">云端分布式搜索技术</a></li>
              <li><a href="http://www.thegeekstuff.com/" title="各种超酷Linux命令用法">TheGeekStuff</a></li>
              <li><a href="http://muxueqz.laou.me" title="muxueqz">聊逍遥兮容与</a></li>
              <li><a href="http://www.usefulshare.com" title="当当网安全运维">UsefulShare</a></li>
              <li><a href="http://paperplane.ruhoh.com/" title="深入研究puppet">纸飞机</a></li>
              <li><a href="http://www.chinaxing.org/" title="">ChinaXing</a></li>
              <li><a href="http://blog.sectop.org/" title="">kindle</a></li>
              <li><a href="http://bubbyroom.com/" title="守住每一天">Liuyu's blog</a></li>
          </ul>
        </div>
      </div>
    </div> <!-- row -->
      <footer>
        <p>&copy; 陈子 2012 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>
    </div> <!-- /container -->
    <!-- JiaThis Button BEGIN -->
    <script type="text/javascript">var jiathis_config = {data_track_clickback:true};</script>
    <script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=1589850" charset="utf-8"></script>
    <!-- JiaThis Button END -->
    <!-- UJian Button BEGIN -->
    <script type="text/javascript" src="http://v1.ujian.cc/code/ujian.js?type=slide&uid=1589850"></script>
    <!-- UJian Button END -->
  </body>
</html>
