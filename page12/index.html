<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>三斗室</title>
    <meta name="author" content="陈子">
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/pygments/default.css" rel="stylesheet" type="text/css">
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">三斗室</a>
          <ul class="nav">
      	<li><a href="/tags.html">标签</a></li>
      	<li><a href="/archive.html">归档</a></li>
      	<li><a href="/errata.html">《网站运维技术与实践》勘误</a></li>
      	<li><a href="/projects.html">学习记录</a></li>
      	<li><a href="/categories.html">分类</a></li>
      	<li><a href="/pages.html">Pages</a></li>
            <li><link title="RSS 2.0" type="application/rss+xml" href="http://chenlinux.com/feed.xml" rel="alternate" /><a href="http://chenlinux.com/feed.xml" target="_blank">RSS订阅</a></li>
          </ul>
          <ul class="nav pull-right"><li><a href="/about.html">有关我</a></li></ul>
        </div>
      </div>
    </div>
    <div class="container">
    <div class="row">
      <div class="span7">
<div class="row">
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/05/11/performance-optimization-of-perl-script-2" title="perl脚本性能优化（续）" rel="bookmark">perl脚本性能优化（续）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-05-11 00:00:00 +0800">11 May 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>上回提到，性能优化的四个回答，今天在扶凯的博客里看到一篇文章，刚好是同样情况下的流程优化。按照其中的说法，修改测试，果然改进很大：</p>
<p>优化的地方在这里：</p>
<p>-:foreach (sort keys %url_table) {
+:if(exists $url_table{$1}) {
print LIST_FH &ldquo;$_n&rdquo;;}</p>
<p>在将所有的url写入散列后，一般的处理办法是用keys检索哈希表，而其实只需要判定存在，直接输出即可。
然后分别用time测试四个脚本，结果如下：</p>
<pre><code>长正则，检索哈希——1.882s
短正则，检索哈希——1.543s
长正则，判定输出——0.804s
短正则，判定输出——0.651s
</code></pre>
      <a href="/2010/05/11/performance-optimization-of-perl-script-2" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/05/07/purge-cache-by-perl-script-2" title="perl边学边练（purge脚本进阶）" rel="bookmark">perl边学边练（purge脚本进阶）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-05-07 00:00:00 +0800">07 May 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#cdn-ref" title="cdn" rel="category tag">cdn</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>之前的purge脚本usage是./purge.pl &ldquo;url1&rdquo; &ldquo;url2&rdquo;。如果url变成成百上千个那么多的时候，这样就不行了。也需要在脚本中处理成文件句柄。修改如下：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl -w</span>
<span class="k">use</span> <span class="nn">IO::</span><span class="n">Socket</span><span class="p">;</span>
<span class="k">unless</span> <span class="p">(</span><span class="nv">@ARGV</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="nb">die</span> <span class="s">&quot;usage: $0 ip.list url.list&quot;</span> <span class="p">}</span>
<span class="nb">open</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span><span class="s">&quot;&lt;$ARGV[0]&quot;</span><span class="p">)</span><span class="o">||</span><span class="nb">die</span> <span class="s">&quot;cannot open the ip list&quot;</span><span class="p">;</span>
<span class="nb">open</span><span class="p">(</span><span class="n">URL</span><span class="p">,</span><span class="s">&quot;&lt;$ARGV[1]&quot;</span><span class="p">)</span><span class="o">||</span><span class="nb">die</span> <span class="s">&quot;cannot open the url list&quot;</span><span class="p">;</span>
<span class="nv">$EOL</span> <span class="o">=</span> <span class="s">&quot;15121512&quot;</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">defined</span><span class="p">(</span><span class="nv">$ip</span><span class="o">=</span><span class="sr">&lt;HOST&gt;</span><span class="p">)){</span>
    <span class="nb">seek</span> <span class="n">URL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">defined</span><span class="p">(</span><span class="nv">$uri</span><span class="o">=</span><span class="sr">&lt;URL&gt;</span><span class="p">)){</span>
        <span class="nv">$remote</span> <span class="o">=</span> <span class="nn">IO::Socket::</span><span class="n">INET</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span> <span class="n">Proto</span> <span class="o">=&gt;</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span>
                                         <span class="n">PeerAddr</span><span class="err"> </span> <span class="o">=&gt;</span> <span class="nv">$ip</span><span class="p">,</span>
                                         <span class="n">PeerPort</span><span class="err"> </span> <span class="o">=&gt;</span> <span class="s">&quot;80&quot;</span><span class="p">,</span>
                                       <span class="p">);</span>
        <span class="k">unless</span> <span class="p">(</span><span class="nv">$remote</span><span class="p">)</span> <span class="p">{</span> <span class="nb">die</span> <span class="s">&quot;cannot connect to http daemon on $ip&quot;</span> <span class="p">}</span>
        <span class="nv">$remote</span><span class="o">-&gt;</span><span class="n">autoflush</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">print</span> <span class="nv">$remote</span> <span class="s">&quot;PURGE $uri HTTP/1.0&quot;</span><span class="o">.</span><span class="nv">$EOL</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="sr">&lt;$remote&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="k">print</span> <span class="p">}</span>
        <span class="nb">close</span> <span class="nv">$remote</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nb">close</span><span class="p">(</span><span class="n">URL</span><span class="p">);</span>
<span class="nb">close</span><span class="p">(</span><span class="n">HOST</span><span class="p">);</span>
</code></pre></div>
<p>在改编时碰到的问题，或者说学习到的东西就是这个while双重嵌套里句柄的问题。
一开始，我写成了 <code>open;open;while(a){while(b){}};close;close;</code> 这样子。结果输出结果只能执行完b循环就正常退出了。
然后修改成 <code>open;open;while(a){while(b){}close;};close;</code> 这样，结果在执行完一遍b循环后，继续的a循环提示打开的句柄已关闭——这证明a循环是执行了的，只是没结果……
再修改成 <code>open;while(a){open;while(b){}close;};close;</code> 这样，结果执行结果正常了！然后想到这么频繁的打开关闭句柄或许效率不太好，于是继续寻找办法。
最后修改成这样 <code>open;open;while(a){seek B,0,0;while(b){}};close;close;</code> 即上面代码段的样子，执行结果也正常。
关键在这个 <code>seek</code> 函数，用途是在（文件较大的情况下）指定从哪个位置开始读取：
usage：seek FILEHANDLE文件句柄,POSITION 读取开始位置字节,WHENCE（0-重新开始、1-当前开始、2-文件最后开始）
因为在第一遍b循环的时候，文件句柄已经读取到了文件最后，所以在下一次循环的时候，要用seek,0,0返回文件初始位置，重新逐行输入。
而之前的脚本因为while里嵌套的是foreach，已经一次性将文件读入数组了，所以不存在句柄的问题。</p>
      <a href="/2010/05/07/purge-cache-by-perl-script-2" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/05/07/performance-optimization-of-perl-script-by-devel-nytprof" title="用Devel::NYTProf模块排查优化perl脚本性能" rel="bookmark">用Devel::NYTProf模块排查优化perl脚本性能</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-05-07 00:00:00 +0800">07 May 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>缓存服务器上有一个perl写的日志分析脚本，记录所有不重复的url。之后对squid进行目录刷新时，从记录下来的文件中查找匹配的url即可。</p>
<p>不过这些天服务器老是出现负载报警，用top观察，这个 <code>url_parser.pl</code> 脚本一旦执行时，就占用了高达90%的CPU和40%的MEM。wc看存储的url.list文件，有大概4,000,000行；<code>url.$(date).list</code> 当前有140,000行。</p>
<p>于是上CU去请教perl执行效率的查找思路。</p>
<p>回复有：1、正则精准度；2、文件读取效率；3、全局变量数；4、频繁打开句柄；5、流程优化</p>
<p>比如读取文件不要用 <code>@line=FILE</code> 用 <code>while(&lt;FILE&gt;)</code> ；正则<code>^</code> 句首，带上 <code>/oi</code> ；注意哈希表与内存交换区等等；最后推荐给我 <code>Devel::NYTProf</code> ，进行测试。</p>
<div class="highlight"><pre><code class="perl"><span class="n">perl</span> <span class="o">-</span><span class="n">MCPAN</span> <span class="o">-</span><span class="n">e</span> <span class="n">shell</span>
<span class="o">&gt;</span><span class="n">install</span> <span class="nn">JSON::</span><span class="n">Any</span><span class="err">（不安这个东东，在</span><span class="n">nyt</span><span class="err">生成</span><span class="n">html</span><span class="err">的时候会报</span><span class="n">warning</span><span class="err">，不过不安也可以）</span>
<span class="o">&gt;</span><span class="n">install</span> <span class="nn">Devel::</span><span class="n">NYTProf</span>
</code></pre></div>
<p>然后采用 <code>perl -d:NYTProf /home/purge/url_parser.pl</code> 运行脚本，会在当前路径下生成nytprof.out。</p>
<p>再用 <code>nytprofhtml nytprof.out</code> 生成web页面。</p>
<p>另开一个apache，将生成的nytprof目录发布出来。用ie打开即可看到了，如下：</p>
<p><img src="/images/uploads/nytprof-index.jpg" alt="nytprof" /></p>
<p>下面还有载入模块的时间。之前我用strace跟踪了一下脚本的运行，发现在载入pm的时候，perl会搜索好多乱七八糟的目录，最后才正确，还一度担心是因为这个原因浪费了时间和资源呢。不过根据测试结果来看，载入模块总共花了不到30ms，不是什么可怕的事情。</p>
<p>然后点击 <code>/home/purge/url_parser.pl</code> 的 <code>reports（line·block·sub）</code>，可以看到具体每个语句的执行情况：</p>
<p><img src="/images/uploads/devel-nytprof-time.jpg" alt="nytprof-0" /></p>
<p>打开十四万行的url文件花了2.14s，然后再用2.09s将它们载入哈希表中；</p>
<p><img src="/images/uploads/devel-nytprof-time1.jpg" alt="nytprof-1" /></p>
<p>打开正在运行的access.log（5分钟截取一次，squidclient mgr:5min里rps为17.65，即大概该有5000行以下；结果显示是3306 calls）并截取其中的url，花了141ms，然后再用42.6ms载入哈希表中；</p>
<p><img src="/images/uploads/devel-nytprof-time2.jpg" alt="nytprof-2" /></p>
<p>最后，用919ms对哈希表排序，用1.58s重记录整个url文件。</p>
<p>(143677-143579=98，即3306条日志中有98条是新增url)</p>
<p>注意到第二张图中，对access.log分析时，match那步，<strong>每行花了30us</strong>！而在对urllist和tmplog分析时，每行只花3-4us的样子。看来是这一步的正则写的不好了，如下:</p>
<div class="highlight"><pre><code class="perl">    <span class="k">my</span> <span class="nv">$log_pattern</span><span class="err">  </span> <span class="o">=</span> <span class="n">qr</span> <span class="s">&#39;^.*?d+s+w+s+(http://.+?)s+.+&#39;</span><span class="p">;</span>
</code></pre></div>
<p>根据日志的格式和需求，改成这样 <code>my $log_pattern   = qr 's(http://.+?)s';</code> 其他不变，再次测试，该部分的测试结果如下：</p>
<p><img src="/images/uploads/devel-nytprof-time3.jpg" alt="nytprof-3" /></p>
<p>__降低成7us每行__啦！效果明显呀~~</p>
      <a href="/2010/05/07/performance-optimization-of-perl-script-by-devel-nytprof" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/05/06/intro-httping" title="web服务监控小工具httping" rel="bookmark">web服务监控小工具httping</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-05-06 00:00:00 +0800">06 May 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>今天偶然看到这个工具，感觉挺有用的，记录一下。
安装过程很简单：</p>
<div class="highlight"><pre><code class="bash">wget http://www.vanheusden.com/httping/httping-1.4.1.tgz
tar zxvf httping-1.4.1.tgz -C /tmp/
<span class="nb">cd</span> /tmp/httping-1.4.1/
make <span class="o">&amp;&amp;</span> make install
</code></pre></div>
<p>默认就安装在/usr下了。如果不想，直接改Makefile去。
然后使用：</p>
<p>httping -options</p>
<h3 id="g-url">-g url</h3>
<p>###  -h hostname
###  -p port
###  -x host:port（如果是测squid，用-x，不要用-h；和curl的不一样，curl -H指定的是发送的hostname，这个-h是指定给DNS解析的hostname）
###  -c count
###  -t timeout
###  -s statuscode
###  -S 将时间分开成连接和传输两部分显示
###  -G GET（默认是HEAD）
###  -b 在使用了GET的前提下显示传输速度KB/s
###  -B 同-b，不过使用了压缩
###  -I useragent
###  -R referer
###  -C cookie=*
###  -l SSL
###  -U username
###  -P password
###  -n a,b 提供给nagios监控用的，当平均响应时间&gt;=a时，返回1；&gt;=b，返回2；默认为0
###  -N c 提供给nagios监控用的，一切正常返回0，否则只要有失败的就返回c</p>
<p>举例如下：</p>
<pre><code>httping -x 211.151.78.37:80 http://bj.qu114.com/ -SGbs -c 10
Using proxyserver: 211.151.78.37:80
PING bj.qu114.com:80 (http://bj.qu114.com/):
connected to bj.qu114.com:80, seq=0 time=27.00+2945.88=2972.87 ms 200 OK 16KB/s
connected to bj.qu114.com:80, seq=1 time=27.09+2233.38=2260.47 ms 200 OK 17KB/s
connected to bj.qu114.com:80, seq=2 time=26.90+168.70=195.60 ms 200 OK 400KB/s
connected to bj.qu114.com:80, seq=3 time=26.89+2524.52=2551.41 ms 200 OK 15KB/s
connected to bj.qu114.com:80, seq=4 time=26.90+1939.48=1966.37 ms 200 OK 20KB/s
connected to bj.qu114.com:80, seq=5 time=26.79+2085.52=2112.31 ms 200 OK 18KB/s
connected to bj.qu114.com:80, seq=6 time=27.04+1294.78=1321.82 ms 200 OK 32KB/s
connected to bj.qu114.com:80, seq=7 time=26.97+2527.29=2554.26 ms 200 OK 15KB/s
connected to bj.qu114.com:80, seq=8 time=26.88+1498.28=1525.16 ms 200 OK 27KB/s
connected to bj.qu114.com:80, seq=9 time=27.21+1208.70=1235.91 ms 200 OK 34KB/s
--- http://bj.qu114.com/ ping statistics ---
10 connects, 10 ok, 0.00% failed
round-trip min/avg/max = 195.6/1869.6/2972.9 ms
Transfer speed: min/avg/max = 15/59/400 KB
</code></pre>
      <a href="/2010/05/06/intro-httping" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/05/05/intro-netperf" title="netperf网络测试" rel="bookmark">netperf网络测试</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-05-05 00:00:00 +0800">05 May 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#linux-ref" title="linux" rel="category tag">linux</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>本文的主要参考是IBM工作室的一篇文章：<a href="http://www.ibm.com/developerworks/cn/linux/l-netperf/index.html" target="_blank">http://www.ibm.com/developerworks/cn/linux/l-netperf/index.html</a></p>
<p>文中指出网络性能的五个衡量指标，前两个是可用性和响应时间，这也是最经常关注的，因为有最常见的ping命令；然后是利用率、可用带宽和剩余带宽。</p>
<ul>
  <li>安装：</li>
</ul>
<div class="highlight"><pre><code class="bash">wget ftp://ftp.netperf.org/netperf/netperf-2.4.5.tar.gz
tar zxvf netperf-2.4.5.tar.gz -C /tmp
<span class="nb">cd</span> /tmp/netperf-2.4.5
./configure <span class="o">&amp;&amp;</span> make <span class="o">&amp;&amp;</span> make install
</code></pre></div>
<p>然后在服务器端运行/usr/local/bin/netserver启动服务，可以看到如下正确结果：</p>
<pre><code>Starting netserver at port 12865
Starting netserver at hostname 0.0.0.0 port 12865 and family AF_UNSPEC
</code></pre>
<p>同样在客户端（即网络另一头的服务器上）安装好，就可以用/usr/local/bin/netperf工具进行测试了。</p>
<ul>
  <li>我的测试环境是：</li>
</ul>
<p>S:121.14.225.197 汕头电信  <br />
C:218.60.36.39 沈阳网通</p>
<p>绝对的跨网测试了，呵呵~</p>
<p>一、先测试默认的TCP_STREAM批量传输，结果如下：</p>
<pre><code>/usr/local/bin/netperf -H 121.14.225.197 -l 60
TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 121.14.225.197 (121.14.225.197) port 0 AF_INET
Recv   Send    Send
Socket Socket  Message  Elapsed
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    10^6bits/sec
873800 163840 163840    60.46       6.52
</code></pre>
<p>即电信设备采用873800字节的socket接收缓存，网通设备采用163840字节的socket发送缓存，测试60.46秒后，网络吞吐量为6.52Mb/s。</p>
<p>逐次采用-m修改发送包的大小后，发现在如下情况时，网络吞吐量是最好的（是默认发送分组的两倍半）：</p>
<pre><code>/usr/local/bin/netperf -H 121.14.225.197 -l 60 -- -m 8192
TCP STREAM TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 121.14.225.197 (121.14.225.197) port 0 AF_INET
Recv   Send    Send
Socket Socket  Message  Elapsed
Size   Size    Size     Time     Throughput
bytes  bytes   bytes    secs.    10^6bits/sec
873800 163840   8192    61.46      17.60
</code></pre>
<p>可见在南北互联中间某环节的路由器，限定了socket缓冲区的大小。</p>
<p>二、然后测试UDP的批量：</p>
<pre><code>/usr/local/bin/netperf -t UDP_STREAM -H 121.14.225.197 -l 60 -- -m 8192
UDP UNIDIRECTIONAL SEND TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 121.14.225.197 (121.14.225.197) port 0 AF_INET
Socket  Message  Elapsed      Messages
Size    Size     Time         Okay Errors   Throughput
bytes   bytes    secs            #      #   10^6bits/sec
6553600    8192   60.01     6973545      0    7615.92
6553600           60.01      393669            429.93
</code></pre>
<p>可以看到，只有5.65%的UDP分组被接收了……</p>
<p>三、小请求大应答模式的测试</p>
<p>1、数据库请求（一次TCP连接，反复传输数据）：</p>
<pre><code>/usr/local/bin/netperf -t TCP_RR -H 121.14.225.197  -- -r 32,1024
TCP REQUEST/RESPONSE TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 121.14.225.197 (121.14.225.197) port 0 AF_INET
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec
163840 873800 32       1024    10.00      18.49
163840 873800
</code></pre>
<p>在32字节请求和1024字节响应的情况下，平均交易率为18.49次/秒。</p>
<p>2、HTTP请求（每次传输都新建连接）：</p>
<pre><code>/usr/local/bin/netperf -t TCP_CRR -H 121.14.225.197  -- -r 32,1024
TCP Connect/Request/Response TEST from 0.0.0.0 (0.0.0.0) port 0 AF_INET to 121.14.225.197 (121.14.225.197) port 0 AF_INET
Local /Remote
Socket Size   Request  Resp.   Elapsed  Trans.
Send   Recv   Size     Size    Time     Rate
bytes  Bytes  bytes    bytes   secs.    per sec
163840 873800 32       1024    10.00       9.30
163840 873800
</code></pre>
<p>RPS几乎下降一般，可见TCP建连是很耗时间的。</p>
<p>3、还可以测试UDP_RR，理论上来说，去除掉TCP建连的耗时，UDP_RR的RPS应该有所提高。不过在我的跨网环境下，rps几乎低到0.1，考虑到之前测试得到的5%的收发率，这个测试基本只能在局域网内才有意义。</p>
      <a href="/2010/05/05/intro-netperf" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/30/ipcs-error-in-squid-start" title="系统消息队列（squid启动小故障）" rel="bookmark">系统消息队列（squid启动小故障）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-30 00:00:00 +0800">30 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#linux-ref" title="linux" rel="category tag">linux</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>昨天公司一台服务器被机房动手动脚之后，上面的虚拟机变得极不正常。squid基本跑不了三四个小时就out of memory一次。虽然已经把cache_mem调低到free的1/4了。依然如此。
更过分的事情刚才发生了，在又一次挂掉后，squid重启动彻底失败起不来了。
赶紧查看cache.log，其中记载了失败的原因，如下：</p>
<pre><code>storeDiskdInit: msgget: (28) No space left on device
FATAL: msgget failed
</code></pre>
<p>一眼看起来像是磁盘空间满了，df一看，没问题呀，use才1%呢！
然后注意到其具体失败处，是msgget函数。msgget是用来新建/获取信息队列的。也就是说，信息队列的某个方面满了。查看一下这方面的信息：</p>
<pre><code>[root@sitesquid1 ~]# ipcs -l
------ Shared Memory Limits --------
max number of segments = 4096
max seg size (kbytes) = 67108864
max total shared memory (kbytes) = 17179869184
min seg size (bytes) = 1
------ Semaphore Limits --------
max number of arrays = 128
max semaphores per array = 250
max semaphores system wide = 32000
max ops per semop call = 32
semaphore max value = 32767
------ Messages: Limits --------
max queues system wide = 16
max size of message (bytes) = 65536
default max size of queue (bytes) = 65536
</code></pre>
<p>看着有点晕，队列系统宽度的最大值，这个比较难理解（下面明明有最大大小了呀？）。只好求助百度，原来就是能打开的消息队列的最大个数，或者说消息队列标识符的最大值。
看这个值挺小的，再看网上也有DB2和apache修改这个值的说法，那就修改一下试试：</p>
<pre><code>sysctl -w kernel.msgmni=128
</code></pre>
<p>再启动squid，OK！！
再重新看看消息队列标识符到底打开了多少：</p>
<pre><code>[root@spshort5 ~]# ipcs|awk '/msqid/{a=NR}END{print NR-a}'
19
</code></pre>
<p>果然是超过16。</p>
      <a href="/2010/04/30/ipcs-error-in-squid-start" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/29/tech-to-get-int-in-awk" title="awk取数值小技巧" rel="bookmark">awk取数值小技巧</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-29 00:00:00 +0800">29 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#bash-ref" title="bash" rel="category tag">bash</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>今天在Q群里看到有人在取ping值时用的小技巧，很是不错，加深了对awk的理解。
ping命令输出如下：</p>
<p>64 bytes from xd-22-5-a8.bta.net.cn (202.108.22.5): icmp_seq=1 ttl=55 time=20.7 ms</p>
<p>要取20.7出来，一般会指定=和&rdquo; &ldquo;两个FS，然后取NF-1列。</p>
<p>不过这个群友给出另一个办法，指定=为FS，然后取$NF+0，其值就是20.7了！</p>
<p>很好很好，采用一个+0的计算，等于是指定前面的$NF为数字型，于是~~</p>
<p>不过这个字母不能在数字前面，否则awk会认为是0。例如下：</p>
<pre><code>echo 123ms|awk '{print $1+0}'
123
echo ms123|awk '{print $1+0}'
0
</code></pre>
      <a href="/2010/04/29/tech-to-get-int-in-awk" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/26/intro-at-command" title="at命令" rel="bookmark">at命令</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-26 00:00:00 +0800">26 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#bash-ref" title="bash" rel="category tag">bash</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>经常使用crontab做定时任务。不过偶然碰到只需要半夜执行一次就够了的时候，还用crontab的话，第二天还得记得上去删除掉任务。就比较麻烦了——尤其是我记忆力不太好~~
好在发现了at命令：</p>
<p>首先启动at服务/etc/init.d/atd start</p>
<p>然后at -f test.sh -v 17:10</p>
<p>系统返回</p>
<pre><code>job 1 at 2010-04-27 17:10
</code></pre>
<p>然后at -f ptest.sh  2:00 july 11
系统返回</p>
<pre><code>job 2 at 2010-07-11 02:00
</code></pre>
<p>用atq查看任务队列</p>
<pre><code>2 2010-07-11 02:00 a root
1 2010-04-27 16:10 a root
</code></pre>
<p>用at -c [job号]查看任务内容</p>
<p>用atrm [job号]删除任务</p>
      <a href="/2010/04/26/intro-at-command" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/25/learning-concurrent-shell-script" title="shell并发脚本学习" rel="bookmark">shell并发脚本学习</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-25 00:00:00 +0800">25 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#bash-ref" title="bash" rel="category tag">bash</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>在CU上看到的老帖子，创建并发程序的shell。个人觉得非常经典，贴回来好好学习使用。用（）包围的是我写的学习笔记，#的是原帖注释：</p>
<div class="highlight"><pre><code class="bash"><span class="c">#!/usr/bin/ksh（自然我得把这里改成bash）</span>
<span class="c"># SCRIPT: ptest.sh</span>
<span class="c"># AUTHOR: Ray001（呃，这些也是要学习滴，版权意识嘛~）</span>
<span class="c"># DATE: 2008/10/03</span>
<span class="c"># REV: 2.0</span>
<span class="c"># For STUDY</span>
<span class="c"># PURPOSE:</span>
<span class="c"># 实现进程并发，提高执行效率，同时能记录每个执行失败的子进程信息</span>
<span class="c">#定义并发进程数量</span>
<span class="nv">PARALLEL</span><span class="o">=</span>3
<span class="c">#定义临时管道文件名（我为这个定义想了好久，不知道$$.是什么特殊变量；后来实际上测试机一实验才发现把事情想复杂了……这就是以“脚本pid+.fifo”组成的字符串而已。完全可以改写成其他样子。</span>
<span class="nv">TMPFILE</span><span class="o">=</span><span class="nv">$$</span>.fifo
<span class="c">#定义导出配置文件全路径名（其实我个人很诧异为什么这里要定义到家目录去，这样在touch ptest.cfg的时候多麻烦呀）</span>
<span class="nv">CMD_CFG</span><span class="o">=</span><span class="nv">$HOME</span>/cfg/ptest.cfg
<span class="c">#定义失败标识文件</span>
<span class="nv">FAILURE_FLAG</span><span class="o">=</span>failure.log
<span class="c">####################### 函数定义 ########################</span>
<span class="c"># 中断时kill子进程（学习重点一：kill -9 0——杀死脚本自己及衍生出来的子进程，嗯，全家自杀）</span>
<span class="k">function </span>trap_exit
<span class="o">{</span>
    <span class="nb">kill</span> -9 0
<span class="o">}</span>
<span class="c"># 通用执行函数</span>
exec_cmd<span class="o">()</span>
<span class="o">{</span>
    <span class="c"># 此处为实际需要执行的命令，本例中用sleep做示例</span>
    sleep <span class="k">${</span><span class="nv">1</span><span class="k">}</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -ne 0 <span class="o">]</span>
    <span class="k">then</span>
<span class="k">        </span><span class="nb">echo</span> <span class="s2">&quot;命令执行失败&quot;</span>
    <span class="k">return </span>1
<span class="k">fi</span>
<span class="o">}</span>
<span class="c">####################### 主程序 ########################</span>
<span class="c">#（学习重点二：当信号为1、2、3、15时，执行&#39;&#39;中的命令，即调用trap_exit函数自杀，然后退出该shell并返回信号2——把0、1留给后面用）</span>
<span class="nb">trap</span> <span class="s1">&#39;trap_exit; exit 2&#39;</span> 1 2 3 15
<span class="c">#清理失败标识文件</span>
rm -f  <span class="k">${</span><span class="nv">FAILURE_FLAG</span><span class="k">}</span>
<span class="c">#为并发进程创建相应个数的占位（其实这个定义不绝对正确有效，比如占了十个位，但cfg中只有7个参数传递，这个脚本就只有7个并发，不过这是小节，无关大雅~）</span>
<span class="c">#（创建命名管道）</span>
mkfifo <span class="nv">$TMPFILE</span>
<span class="c">#（学习重点三：为命名管道指定文件标识符为4，&lt;&gt;分别是输入和输出，即绑定了该管道的输入输出都在4这个文件标识符上！）</span>
<span class="nb">exec </span>4&lt;&gt;<span class="nv">$TMPFILE</span>
<span class="c">#(删除管道文件，不知道这步是为什么，目前只能猜测是担心程序运行时该文件被其他人或者程序误用吧？)</span>
rm -f <span class="nv">$TMPFILE</span>
<span class="c">#（用{}和用()的区别在shell是否会衍生子进程。let命令用以变量运算。这一段给文件标识符输入了几个回车。）</span>
<span class="c">#（不知道这几个回车和“并发占位”什么关系。找了很久，没发现？？目前猜测是管道的流处理所以每个子进程用一行）</span>
<span class="o">{</span>
    <span class="nv">count</span><span class="o">=</span><span class="nv">$PARALLEL</span>
    <span class="k">while</span> <span class="o">[</span> <span class="nv">$count</span> -gt 0 <span class="o">]</span>
    <span class="k">do</span>
<span class="k">        </span><span class="nb">echo</span>
<span class="nb">        let </span><span class="nv">count</span><span class="o">=</span><span class="nv">$count</span>-1
    <span class="k">done</span>
<span class="o">}</span> &gt;&amp; 4
<span class="c">#从任务列表 seq 中按次序获取每一个任务</span>
<span class="c">#（从家目录下那个cfg文件中读取sleep的时间）</span>
<span class="k">while </span><span class="nb">read </span>SEC
<span class="k">do</span>
    <span class="c">#（从标识符中读取回车？不懂，还是管道和子进程的问题……）</span>
    <span class="nb">read</span> &lt;&amp; 4
    <span class="c">#（后台执行主程序命令或者输出错误日志，完成后清空标识符）</span>
    <span class="o">(</span>  exec_cmd <span class="k">${</span><span class="nv">SEC</span><span class="k">}</span> <span class="o">||</span> <span class="nb">echo</span> <span class="k">${</span><span class="nv">SEC</span><span class="k">}</span>&gt;&gt;<span class="k">${</span><span class="nv">FAILURE_FLAG</span><span class="k">}</span> ; <span class="nb">echo</span> &gt;&amp;amp;4 <span class="o">)</span> &amp;
<span class="k">done</span>&lt;<span class="nv">$CMD_CFG</span>
<span class="c">#（等待子进程结果返回值）</span>
<span class="nb">wait</span>
<span class="c">#（关闭文件标识符4）</span>
<span class="nb">exec </span>4&gt;&amp;-
<span class="c">#并发进程结束后判断是否全部成功</span>
<span class="k">if</span> <span class="o">[</span> -f <span class="k">${</span><span class="nv">FAILURE_FLAG</span><span class="k">}</span> <span class="o">]</span>
<span class="k">then</span>
<span class="k">    </span><span class="nb">exit </span>1
<span class="k">else</span>
<span class="k">    </span><span class="nb">exit </span>0
<span class="k">fi</span>
</code></pre></div>
      <a href="/2010/04/25/learning-concurrent-shell-script" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/23/cdn-analysis-for-www-qidian-com" title="起点小说网的cdn分析~（绝非正式报告）" rel="bookmark">起点小说网的cdn分析~（绝非正式报告）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-23 00:00:00 +0800">23 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#cdn-ref" title="cdn" rel="category tag">cdn</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>每天习惯了在起点小说网看看小说轻松一下神经，今天一不小心，看见了squid错误页面。于是小小的查看了一下起点的cdn状况。
首先声明本身的接入情况：宽带通4M接入，ip138显示为北京网通adsl……
访问的是决战朝鲜的第三十三章。页面内容来看，域名主要有www.qidian.com、image.cmfu.com、ipagent.igalive.com、cj.qidian.com四个，前两个在网宿加速(lxdns)、第三个在蓝汛加速(ccgslb)、第四个在起点母公司盛大加速(sdo)，其余零散域名未加速。
lxdns返回的ip是天津网通（ping值7ms）；
ccgslb返回的ip是北京蓝汛（ping值8ms）；
sdo返回的是上海联通（本地ping不通，在沈阳网通测试机上居然ping通了，返回的是同一个ip，30ms，汗）……
整个页面一共81个对象:
加速的域名uedas.qidian.com和sdo的cj.qidian.com下的对象，time都在100ms以上；
网宿加速域名下的对象，主要是小图片和页面；
图片小到以B计算，返回time在16ms左右；页面包括aspx和html，html大小在15-20KB左右，返回time在50ms左右；
耗时最大的是主页面http://www.qidian.com/BookReader/1501306,27478560.aspx，耗时437ms，其中15ms建立链接，而422ms传输内容，content-length 69408，请求头带有no-cache的cache-control和gzip,deflate的压缩；返回头带有Age 1的HIT结果，但X-Cache有两层，分别是一层MISS一层HIT，via头信息是jsyz232:80 (Cdn Cache Server V2.0), tg146:80 (Cdn Cache Server V2.0)。预计应该是parent上设定强制缓存，而leaf上不缓存；
另一个耗时较大的是http://www.qidian.com/Javascript/ReadChapterNew.js?t=091216，耗时250ms，content-length 35423，其他情况和aspx差不多，不过返回了三个X-Cache，一个MISS两个HIT，在via头上很奇怪的看到三个服务器分别是jsyz232:80 (Cdn Cache Server V2.0), zb99:80 (Cdn Cache Server V2.0), tg134:8103 (Cdn Cache Server V2.0)，不知道这个开8103端口的是什么意思？？（网上查了一下，民生网银用的是这个端口，~~）
最后是蓝汛加速域名下的对象，都是广告；
js文件url是相同的，都是http://ipagent.igalive.com/show_ads.js，但先后请求了5次，返回时间依次为：4.28s、48.42s、3.14s、6.17s和875ms，波动相当大！观察这5次的Age，分别是778、827、782、834、835；对应返回时间，可以看出是同一台服务器返回的同一份缓存。再具体看time的细分，建立连接时间都很短，传输内容时间从500ms到1.5s不等。也就是说，主要波动在于服务器的响应时间上。
aspx?文件，url比较长，类似这种：http://ipagent.igalive.com/s.aspx?adid=100144&amp;host=http://ipagent.igalive.com&amp;dt=1272030174514&amp;lmt=1272028966&amp;output=101&amp;url=http://www.qidian.com/BookReader/1501306/27478560.aspx&amp;ref=http://me.qidian.com/BookCase/1/1&amp;flash=10&amp;u_h=660&amp;u_w=1126&amp;u_ah=627&amp;u_aw=1126&amp;u_cd=24&amp;u_tz=480&amp;u_his=1&amp;u_nplug=7&amp;u_nmime=16，都是MISS回源的。长度和上面的js差不多都在40KB左右。但是到最后甚至有一个文件连接超时了……&lt;/</p>
<hr />
<p>综上：
网宿给起点的cache服务器，应该是针对超小文件做过优化的，所以在16KB以下的图片，返回TCP_MEM_HIT；超过这个大小的那两个文件，响应速度就下降的比较厉害。
蓝汛给起点的cache服务器，负载压力可能比较大，导致响应速度很慢且有极大波动；我猜测对于js文件，其服务器可能还采用了304回源；从回源的aspx来看，回源效果很差很差……
盛大给起点的cache服务器，不说啥了~~
最后附squid的错误信息ERR_READ_TIMEOUT图：
<img src="/images/uploads/err_read_timeout.jpg" alt="" /></p>
      <a href="/2010/04/23/cdn-analysis-for-www-qidian-com" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/22/perl-built_in-variables" title="perl内置变量" rel="bookmark">perl内置变量</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-22 00:00:00 +0800">22 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>$_ 默认输入/模式搜索空间，常用于-f -d测试、print unlink函数、m// s/// tr///匹配、foreach while循环</p>
<p>@_ 传递给函数的所有参数</p>
<p>$&amp;/$<code>/$' 分别是上次匹配成功（时/前/后）的字符串（这三个变量会导致效率显著降低）
local $_ = 'abcdefghi';
/def/;
print "$</code>:$&amp;:$&rsquo;n&rdquo;;         # prints abc:def:ghi</p>
<p>$+ 上次搜索中最后一个括号匹配的文本
/Version: (.<em>)|Revision: (.</em>)/ &amp;&amp; ($rev = $+);</p>
<p>$^N 上次搜索中最后闭合的组所匹配的文本（可能嵌套）
(?:(&hellip;)(?{ $var = $^N }));    #这样可以省去计算括号个数</p>
<p>$* 匹配模式优化（即当其==0时，perl认为字符串仅为一行(n)，推荐使用/s和/m代替此变量）</p>
<p>$. 相当于awk中的NR，但如果文件句柄被close()，$.就会复位，相当于FNR</p>
<p>$/ 相当于RS，正常情况设置为字符串；设置为undef即一口气全读入；设置为整数标量时则读入小于该整数的记录而不是行；一些小文件，可以采用$data = do { local $/;<fh>; };单行命令读入，就是这个原理。</fh></p>
<p>$ 相当于ORS</p>
<p>$, 相当于OFS</p>
<p>$&rdquo; 同$,不过用于向用&rdquo;引起的字符串插入数据的时候</p>
<p>$; 模拟多维数组时下标的分隔符。
$foo{$a,$b,$c};
$foo{join($;, $a, $b, $c)};        #两者相当</p>
<table>
  <tbody>
    <tr>
      <td>$</td>
      <td>设置为非零值时，强制刷新每次输出缓存；在向管道和套接字输出时设置该变量</td>
    </tr>
  </tbody>
</table>
<p>$# 相当于OFMT，不过awk里是%.6g，perl里是%<em>n</em>g，<em>n</em>取决于OS上float.h 中 DBL_DIG 宏的值（不建议使用该变量）</p>
<p>@-/@+ 分别是模式匹配时，每次成功匹配字符串开始和结束处的偏移量</p>
<p>在对某个变量 $var 进行匹配后：
$` 和 &ldquo;substr($var, 0, $-[0])&rdquo; 相同
$&amp; 和 &ldquo;substr($var, $-[0], $+[0] - $-[0])&rdquo; 相同
$&rsquo; 和 &ldquo;substr($var, $+[0])&rdquo; 相同
$1 和 &ldquo;substr($var, $-[1], $+[1] - $-[1])&rdquo; 相同
$2 和 &ldquo;substr($var, $-[2], $+[2] - $-[2])&rdquo; 相同</p>
<p>$#+是最近成功匹配了多少个组</p>
<p>$[ 数组中的第一个元素/字符串中第一个字符的索引号，默认为0（最好不要改）</p>
<p>$] perl解释器版本（5.001格式）</p>
<p>$^V perl解释器版本（5.8.8格式）</p>
<p>$^T 程序运行时间（UNIX秒）</p>
<p>$$ perl脚本的运行进程号</p>
<p>$&lt; perl脚本的运行实际用户</p>
<p>$&gt; perl脚本的运行有效用户</p>
<p>$( perl脚本的运行实际用户组</p>
<p>$) perl脚本的运行有效用户组</p>
<p>$0 当前程序名</p>
<p>$@/$!/$^E/$? 分别是perl解释器、C库、操作系统、外部程序检测到的错误</p>
<div class="highlight"><pre><code class="perl"><span class="nb">eval</span> <span class="sx">q{</span>
<span class="sx">    open my $pipe, &quot;/cdrom/install |&quot; or die $!;</span>
<span class="sx">    my @res = &lt;$pipe&gt;;</span>
<span class="sx">    close $pipe or die &quot;bad pipe: $?, $!&quot;;</span>
<span class="sx">}</span><span class="p">;</span>
</code></pre></div>
<p>在需要 &ldquo;eval&rdquo; 的字符串没有通过编译(若 &ldquo;open&rdquo; 或 &ldquo;close&rdquo;导入的原型错误则可能发生)或者 Perl 代码在执行过程中 die() 掉，则 $@变量会被设置。这些情况下 $@ 的值是编译错误信息或 &ldquo;die&rdquo; 的参数(其中会内插 $! 和 $?)。(另见 Fatal)  <br />
上面的 eval() 表达式执行后，open()、&rdquo;<pipe>" 和 "close" 被翻译成对 C运行库的调用，继而 进入操作系统内核。若其中某个调用失败，则 $! 会设置为C 库的 "errno" 值。</pipe></p>
<p>在少数操作系统下，$^E 可能含有更详细的错误指示，例如“CDROM仓门没有关闭”。不支持扩展错误 信息的系统只是将 $^E 设置为和 $!一样的值。</p>
<p>最后，$? 在外部程序 /cdrom/install 失败时设置为非 0 值。高8位反映出该程序遇到的特定错误 条件(程序的 exit() 值)，低8位反映失败方式，例如信号致死或核心转储，细节参见 wait(2)。对比仅在检测到错误条件时才设置的 $! 和 $^E，变量 $? 在每个 &ldquo;wait&rdquo; 或管道&rdquo;close&rdquo; 时都会 设置并冲掉旧值。这一行为更接近 $@，后者在每次 eval()后总是在失败时设置并在成功时清除。</p>
<p>更多细节请分别参见 $@、$!、$^E 和 $? 各自的说明。</p>
      <a href="/2010/04/22/perl-built_in-variables" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/22/nginx-default-proxy_cache_key" title="要命的刷新" rel="bookmark">要命的刷新</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-22 00:00:00 +0800">22 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#cdn-ref" title="cdn" rel="category tag">cdn</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>今天一天都在跟刷新做斗争。
先是squid的目录刷新，用/home/squid/bin/squidclient -p 80 mgr:objects|awk &lsquo;/harbin/{system(&ldquo;/home/squid/bin/squidclient -p 80 -m purge &ldquo;$2}&rsquo;刷新一遍；客户反馈看到的依然是旧页面；我想想似乎看到url里有带()的，awk的system函数这时候会出错；于是改成用for i in <code>/home/squid/bin/squidclient -p 80 mgr:objects|awk '/harbin/{print $2}'</code>;do /home/squid/bin/squidclient -p 80 -m purge &ldquo;$i&rdquo;;done再刷新一遍；然后自己绑定节点访问，居然也还看到是旧页面！</p>
<p>通过httpwatch抓取，其中的http://www.harbin-beer.cn/flash/age.swf的Age高达23325，显然没有被purge到，单独提交/home/squid/bin/squidclient -p 80 -m purge http://www.harbin-beer.cn/flash/age.swf，再访问，Ok了！！
毫无疑问http://www.harbin-beer.cn/flash/age.swf这个url绝对是能被/harbin/模式匹配的，但为什么之前刷新不到？而且不单单是某一台服务器如此。。。</p>
<p>然后是nginx的url刷新，某小图片加速客户原先是增量缓存，于是nginx中只是很简单的配置了一下文件类型和缓存时间。不料今天客户突然传过来一个24M大小的url列表，将近30万条url要求全网刷新！而这批nginx连后台刷新接口都没有……哭
临时更换nginx版本为&ndash;add-ngx_cache_purge的。在设置proxy_cache_purge时却又碰到了难题。因为之前的cache配置里压根没配置proxy_cache_key！！有心格盘，但一算，300000*5k=1.5G，而cache已存文件是100G，格盘动作太大了……
进到nginx的cache目录下，strings其中的文件，看到如下信息：</p>
<div class="highlight"><pre><code class="bash"><span class="o">[</span>root@ct5 ~<span class="o">]</span><span class="c"># strings /cache/0/00/c7de957045a9987b18f94d3cc1f99000 |head</span>
KEY: http://images6.anjukestatic.com/property/20090904/22/65/91/69/22659169/600x600.jpg
HTTP/1.0 200 OK
Server: nginx
Date: Thu, 11 Mar 2010 15:48:20 GMT
Content-Type: image/jpeg
ajk: <span class="nv">server</span><span class="o">=</span>img01-001
Expires: Thu, 31 Dec 2037 23:55:55 GMT
Cache-Control: max-age<span class="o">=</span>315360000
X-Cache: HIT from CDN01-001
Age: 1465699
</code></pre></div>
<p>对照其他带purge的nginx_cache格式，可以发现nginx默认的proxy_cache_key应该是$scheme://$host$uri$is_args$args，那么proxy_cache_purge就设成$scheme://$host$1$is_args$args，重读配置，然后curl -x 127.0.0.1:80 http://images6.anjukestatic.com/purge/property/20090904/22/65/91/69/22659169/600x600.jpg，看到</p>
<div class="highlight"><pre><code class="html"><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;&lt;title&gt;</span>Successful purge<span class="nt">&lt;/title&gt;&lt;/head&gt;</span>
<span class="nt">&lt;body</span> <span class="na">bgcolor=</span><span class="s">&quot;white&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;center&gt;&lt;h1&gt;</span>Successful purge<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;br&gt;</span>Key : http://images6.anjukestatic.com/property/20090904/22/65/91/69/22659169/600x600.jpg
<span class="nt">&lt;br&gt;</span>Path: /cache/0/00/c7de957045a9987b18f94d3cc1f99000
<span class="nt">&lt;/center&gt;</span>
<span class="nt">&lt;hr&gt;&lt;center&gt;</span>nginx/0.7.65<span class="nt">&lt;/center&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div>
<p>（写到这里，想到google首页源代码省略了&lt;/body&gt;&lt;/html&gt;，据说是因为就少这几个字符，在全球就能节省几个G的带宽。相比来说这个purgemodule可真浪费的）
再ls /cache/0/00/c7de957045a9987b18f94d3cc1f99000，提示No such file or directory，成功了。接下来就是for循环刷新了……</p>
      <a href="/2010/04/22/nginx-default-proxy_cache_key" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/20/sscanf-usage" title="sscanf用法" rel="bookmark">sscanf用法</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-20 00:00:00 +0800">20 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#c-ref" title="c" rel="category tag">c</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>int sscanf(</p>
<p>const char *buffer,</p>
<p>const char *format [,argument ] &hellip;</p>
<p>);
最简单的举例：切割时间</p>
<p>char sztime1[16] = &ldquo;&rdquo;, sztime2[16] = &ldquo;&rdquo;;
sscanf(&ldquo;2006:03:18 - 2006:04:18&rdquo;, &ldquo;%s - %s&rdquo;, sztime1, sztime2);</p>
<p>可是如果时间是&rdquo;2006:03:18-2006:04:18&rdquo;，即没有空格时，%s的定义就没法用了。这时候可以使用%[..]来定义，如下</p>
<p>sscanf(&ldquo;2006:03:18-2006:04:18&rdquo;, &ldquo;%[0-9,:]-%[0-9,:]&rdquo;, sztime1, sztime2);</p>
<p>%[]的用法，类似正则表达式，可以采用[a-z]这样的匹配；可以采用[^a-z]这样的排除匹配；还可以采用*[a-z]这样的匹配过滤。举例如下：</p>
<p>const  char sourceStr[] = &ldquo;hello, world&rdquo;;</p>
<p>char buf[10] = {0};</p>
<p>sscanf(sourceStr, &ldquo;%*s%s&rdquo;, buf);</p>
<p>执行结果就是过滤了hello，打印出world~~</p>
      <a href="/2010/04/20/sscanf-usage" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/15/intro-iscsi-2" title="iscsi试验（读写测试）" rel="bookmark">iscsi试验（读写测试）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-15 00:00:00 +0800">15 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#linux-ref" title="linux" rel="category tag">linux</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>隔了一天，回头再来mount /dev/sda /mnt；成功了~
不信邪，再上一台，login，mount，继续成功……
难道是前天rp不行？</p>
<p>然后试验写入。发现在每台client上的写入，都暂时不会显示在server和其他client上。只有经过logout和login后才会显示。
接着进行一下简单的读写速度测试，先是read，用hdparm工具，结果如下：</p>
<p>服务器端：[root@ct5 ~]# hdparm -tT /dev/xvdb1
/dev/xvdb1:
 Timing cached reads:   20880 MB in  1.99 seconds = 10486.02 MB/sec
 Timing buffered disk reads:  162 MB in  3.01 seconds =  53.85 MB/sec</p>
<p>客户端：[root@ct5 ~]# hdparm -tT /dev/sda
/dev/sda:
 Timing cached reads:   21944 MB in  1.99 seconds = 11022.51 MB/sec
 Timing buffered disk reads:  152 MB in  3.02 seconds =  50.41 MB/sec</p>
<p>然后用apache发布，wget的速度基本也差不多。</p>
<p>然后是write，用time dd，最开始指定了bs=4k，结果让我很惊讶</p>
<p>服务器端：[root@ct5 cache]# time dd if=/dev/zero of=rao bs=4k count=655360
655360+0 records in
655360+0 records out
2684354560 bytes (2.7 GB) copied, 35.1299 seconds, 76.4 MB/s  <br />
real 0m35.204s  <br />
user 0m0.440s  <br />
sys 0m6.968s    </p>
<p>而客户端2684354560 bytes (2.7 GB) copied, 28.584 seconds, 93.9 MB/s  <br />
real 0m28.650s  <br />
user 0m0.496s  <br />
sys 0m7.404s    </p>
<p>居然比服务器端还快。于是想到iscsi的封包机制，可能bs4k有影响，于是往下降成2k，结果立刻有体现了</p>
<p>服务器1342177280 bytes (1.3 GB) copied, 6.93954 seconds, 193 MB/s  <br />
real 0m6.943s  <br />
user 0m0.428s  <br />
sys 0m4.848s    </p>
<p>客户端1342177280 bytes (1.3 GB) copied, 12.5357 seconds, 107 MB/s  <br />
real 0m12.539s  <br />
user 0m0.348s  <br />
sys 0m4.720s    </p>
<p>再降成1k，结果稍慢</p>
<p>服务器671088640 bytes (671 MB) copied, 4.1199 seconds, 163 MB/s  <br />
real 0m4.123s  <br />
user 0m0.372s  <br />
sys 0m3.280s    </p>
<p>客户端671088640 bytes (671 MB) copied, 7.06874 seconds, 94.9 MB/s  <br />
real 0m7.093s  <br />
user 0m0.328s  <br />
sys 0m3.324s  <br />
可见在写速率上，还是有一定差距的。</p>
      <a href="/2010/04/15/intro-iscsi-2" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/15/anti_hotlinking-in-apache-by-mod_perl" title="apache防盗链（mod_perl试用）" rel="bookmark">apache防盗链（mod_perl试用）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-15 00:00:00 +0800">15 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#web-ref" title="web" rel="category tag">web</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>客户需求如下：</p>
<p>在web请求视频时，按算法生成密文和明文串，然后依规则组成最终的url请求；</p>
<p>算法规则：</p>
<p>用如下三个关键词生成 MD5 密文：</p>
<ol>
  <li>自定义密钥：abcde.；</li>
  <li>视频文件真实路径，即/path/to/file.rmvb；</li>
  <li>请求时间，以当前UNIX时间换算为十六进制字符串，并作为明文；</li>
</ol>
<p>最终url格式是 <code>http://www.test.com/path/to/file.rmvb?key=1234567890abcdefghijklmnopqrstuy&amp;t=1234abcd</code> 这样。</p>
<p>要求失效时间为8小时。</p>
<p>这个需求和之前一次相当类似，不过上回是squid，这次是apache。同样采用perl脚本进行防盗链设置，apache需要使用mod_perl模块。</p>
<p>首先安装perl模块：</p>
<div class="highlight"><pre><code class="bash">wget http://perl.apache.org/dist/mod_perl-2.0-current.tar.gz
tar zxvf mod_perl-2.0-current.tar.gz
<span class="nb">cd </span>mod_perl-2.0-current.tar.gz
perl Makefile.PL <span class="nv">MP_APXS</span><span class="o">=</span>/home/apache2/bin/apxs
make <span class="o">&amp;&amp;</span> make install
<span class="nb">echo</span> <span class="s2">&quot;LoadModule perl_module modules/mod_perl.so&quot;</span> &gt;&gt; /home/apache2/conf/httpd.conf
perl -MCPAN -e shell
&gt;install Apache2::Request
&gt;look Apache2::Request
rm -f configure
rm -f apreq2-config
./buildconf
perl Makefile.PL
make <span class="o">&amp;&amp;</span> make install
<span class="nb">exit</span>
<span class="c">#因为64位系统的libexpat.so有问题，编译libapreq2会出问题，只好如此强制安装</span>
<span class="nb">echo</span> <span class="s2">&quot;LoadModule apreq_module modules/mod_apreq2.so&quot;</span> &gt;&gt; /home/apache2/conf/httpd.conf
</code></pre></div>
<p>因为libapreq2.so安装在/home/apache2/lib/下了，所以需要echo &ldquo;/home/apache2/lib&rdquo; &gt;/etc/lo.so.conf.d/apache.conf，然后ldconfig。</p>
<p>修改httpd.conf，加入如下设置：</p>
<div class="highlight"><pre><code class="apache"><span class="nb">PerlPostConfigRequire</span> <span class="sx">/home/apache2/perl/start.pl</span>
<span class="nt">&lt;Location</span> <span class="s">/smg</span><span class="nt">&gt;</span>
<span class="nb">SetHandler</span> modperl
<span class="nb">PerlAccessHandler</span> DLAuth
<span class="nb">PerlSetVar</span> ShareKey abcde.
<span class="nt">&lt;/Location&gt;</span>
</code></pre></div>
<p>然后mkdir /home/apache2/perl/，在其中创建start.pl和DLAuth.pm两个文件。start.pl文件内容如下：</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="n">strict</span><span class="p">;</span> 
<span class="k">use</span> <span class="n">lib</span> <span class="sx">qw(/home/apache2/perl)</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">RequestIO</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">RequestRec</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">Connection</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">RequestUtil</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">ServerUtil</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">Log</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">Request</span> <span class="p">();</span>
<span class="mi">1</span><span class="p">;</span> 
</code></pre></div>
<p>DLAuth.pm文件内容如下：</p>
<div class="highlight"><pre><code class="perl"><span class="nb">package</span> <span class="n">DLAuth</span><span class="p">;</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
<span class="k">use</span> <span class="n">Socket</span> <span class="sx">qw(inet_aton)</span><span class="p">;</span>
<span class="k">use</span> <span class="n">POSIX</span> <span class="sx">qw(difftime strftime)</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Digest::</span><span class="n">MD5</span> <span class="sx">qw(md5_hex)</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">RequestIO</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">RequestRec</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">Connection</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">RequestUtil</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">ServerUtil</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">Log</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">Request</span> <span class="p">();</span>
<span class="k">use</span> <span class="nn">Apache2::</span><span class="n">Const</span> <span class="o">-</span><span class="n">compile</span> <span class="o">=&gt;</span> <span class="sx">qw(OK FORBIDDEN)</span><span class="p">;</span>
<span class="k">sub </span><span class="nf">handler</span> <span class="p">{</span>
<span class="err">   </span> <span class="k">my</span> <span class="nv">$r</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
<span class="err">   </span> <span class="k">my</span> <span class="nv">$s</span> <span class="o">=</span> <span class="nn">Apache2::</span><span class="n">ServerUtil</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">;</span>
<span class="err">   </span> <span class="k">my</span> <span class="nv">$shareKey</span> <span class="o">=</span> <span class="nv">$r</span><span class="o">-&gt;</span><span class="n">dir_config</span><span class="p">(</span><span class="s">&#39;ShareKey&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="s">&#39;&#39;</span><span class="p">;</span>
<span class="err">   </span> <span class="k">my</span> <span class="nv">$uri</span> <span class="o">=</span> <span class="nv">$r</span><span class="o">-&gt;</span><span class="n">uri</span><span class="p">()</span> <span class="o">||</span> <span class="s">&#39;&#39;</span><span class="p">;</span>
<span class="err">   </span> <span class="k">my</span> <span class="nv">$args</span> <span class="o">=</span> <span class="nv">$r</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">()</span> <span class="o">||</span> <span class="s">&#39;&#39;</span><span class="p">;</span>
<span class="err">   </span> <span class="k">my</span> <span class="nv">$expire</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">;</span>
<span class="err">   </span> <span class="k">if</span> <span class="p">(</span><span class="nv">$args</span> <span class="o">=~</span> <span class="n">m</span><span class="c1">#^key=(\w{32})&amp;t=(\w{8})$#i) {</span>
<span class="err">   </span>     <span class="k">my</span> <span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$date</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$1</span><span class="p">,</span> <span class="nv">$2</span><span class="p">);</span>
<span class="err">   </span>     <span class="k">my</span> <span class="nv">$str</span> <span class="o">=</span> <span class="n">md5_hex</span><span class="p">(</span><span class="nv">$shareKey</span> <span class="o">.</span> <span class="nv">$uri</span> <span class="o">.</span> <span class="nv">$date</span><span class="p">)</span>
<span class="err">   </span>     <span class="k">my</span> <span class="nv">$reqtime</span> <span class="o">=</span> <span class="nb">hex</span><span class="p">(</span><span class="nv">$date</span><span class="p">);</span>
<span class="err">   </span>     <span class="k">my</span> <span class="nv">$now</span> <span class="o">=</span> <span class="nb">time</span><span class="p">;</span>
<span class="err">   </span>     <span class="k">if</span> <span class="p">(</span> <span class="nv">$now</span> <span class="o">-</span> <span class="nv">$reqtime</span> <span class="o">&lt;</span> <span class="nv">$expire</span><span class="p">)</span> <span class="p">{</span>
<span class="err">   </span> <span class="err">   </span>     <span class="k">if</span> <span class="p">(</span><span class="nv">$str</span> <span class="ow">eq</span> <span class="nv">$key</span><span class="p">)</span> <span class="p">{</span>
<span class="err">   </span> <span class="err">   </span> <span class="err">   </span>     <span class="k">return</span> <span class="nn">Apache2::Const::</span><span class="n">OK</span><span class="p">;</span>
<span class="err">   </span> <span class="err">   </span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="err">       </span> <span class="err">   </span> <span class="err">   </span> <span class="nv">$s</span><span class="o">-&gt;</span><span class="n">log_error</span><span class="p">(</span><span class="s">&quot;[$uri FORBIDDEN] Auth failed&quot;</span><span class="p">);</span>
<span class="err">   </span> <span class="err">   </span> <span class="err">   </span>     <span class="k">return</span> <span class="nn">Apache2::Const::</span><span class="n">FORBIDDEN</span><span class="p">;</span>
<span class="err">   </span> <span class="err">   </span>     <span class="p">}</span>
<span class="err">   </span>     <span class="p">}</span>
<span class="err">   </span> <span class="p">}</span>
<span class="err">   </span> <span class="nv">$s</span><span class="o">-&gt;</span><span class="n">log_error</span><span class="p">(</span><span class="s">&quot;[$uri FORBIDDEN] Auth failed&quot;</span><span class="p">);</span>
<span class="err">   </span> <span class="k">return</span> <span class="nn">Apache2::Const::</span><span class="n">FORBIDDEN</span><span class="p">;</span>
<span class="p">}</span>
<span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>就可以了。</p>
<p>apachectl restart。测试一下，先用perl自己生成一个测试链接：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl -w</span>
<span class="k">use</span> <span class="nn">Digest::</span><span class="n">MD5</span> <span class="sx">qw(md5_hex)</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$key</span> <span class="o">=</span> <span class="s">&quot;bestv.&quot;</span><span class="p">;</span>
<span class="nv">$path</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">(</span><span class="nv">@ARGV</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$date</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">(</span><span class="s">&quot;%x&quot;</span><span class="p">,</span><span class="nb">time</span><span class="p">);</span>
<span class="nv">$result</span> <span class="o">=</span> <span class="n">md5_hex</span><span class="p">(</span><span class="nv">$key</span> <span class="o">.</span> <span class="nv">$path</span> <span class="o">.</span> <span class="nv">$date</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$uri</span> <span class="o">=</span> <span class="s">&quot;http://127.0.0.1$path?key=$result&amp;t=$date&quot;</span><span class="p">;</span>
<span class="k">print</span> <span class="nv">$uri</span><span class="p">;</span>
</code></pre></div>
<p>运行 <code>./url.pl /smg/abc.rmvb</code> 生成 <code>http://127.0.0.1/smg/abc.rmvb?key=4fb6b4e6a0ec484aea98fa727fc7149d&amp;t=4bc7dd5a</code>，然后 <code>wget -S -O /dev/null "http://127.0.0.1/smg/abc.rmvb?key=4fb6b4e6a0ec484aea98fa727fc7149d&amp;t=4bc7dd5a"</code>，返回 200 OK;任意修改 t 为 12345678，再 wget，返回 403 Forbidden。<code>error_log</code> 显示如下：</p>
<pre><code>[Fri Apr 16 11:47:06 2010] [error] [/smg/abc.rmvbkey=4fb6b4e6a0ec484aea98fa727fc7149d&amp;t=12345678 FORBIDDEN] Auth failed
</code></pre>
      <a href="/2010/04/15/anti_hotlinking-in-apache-by-mod_perl" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/12/intro-iscsi-1" title="iscsi试验（失败，慎入）" rel="bookmark">iscsi试验（失败，慎入）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-12 00:00:00 +0800">12 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#linux-ref" title="linux" rel="category tag">linux</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>聊天时听同事提及iscsi。回来后借助百度和谷歌大概了解了一下是网络存储，就赶紧下了软件包作测试。</p>
<div class="highlight"><pre><code class="bash">wget http://downloads.sourceforge.net/project/iscsitarget/iscsitarget/1.4.19/iscsitarget-1.4.19.tar.gz
tar zxvf iscsitarget-1.4.19.tar.gz
<span class="nb">cd </span>iscsitarget-1.4.19
make <span class="o">&amp;&amp;</span> make install
</code></pre></div>
<p>就完成了服务器端的安装，然后修改配置文件/etc/iet/ietd.conf，方便起见，就写最基本的三行：</p>
<pre><code>Target iqn.2010-04.com.test:storage.xvdb1
Lun 0 Path=/dev/xvdb1,Type=fileio
Alias Test
</code></pre>
<p>启动服务/etc/init.d/iscsi-target start，netstat查看，发现有3260端口的监听了。</p>
<p>然后是客户端，更容易，直接yum install iscsi-initiator-utils就够了。然后启动服务/etc/init.d/iscsid start。</p>
<p>然后链接服务器，iscsiadm -m discovery -t st -p 10.12.13.86，可以搜索到了。不过居然出现两个，分别是服务器内外网ip搜索的值。两个办法。</p>
<p>一个是定义客户端/var/lib/iscsi/iface/ieth0文件如下：</p>
<pre><code>iface.iscsi_ifacename = ieth0
iface.net_ifacename = eth0
iface.hwaddress = default
iface.transport_name = tcp
</code></pre>
<p>然后用iscsiadm -m discovery -t st -p 10.12.13.86 -I ieth0命令搜索；</p>
<p>一个是定义服务端/etc/iet/targets.allow文件如下：</p>
<pre><code>ALL 10.12.13.0/24
</code></pre>
<p>然后/etc/init.d/iscsi-target restart就可以了。</p>
<p>最后搜索结果如下：</p>
<pre><code>10.12.13.86:3260,1 iqn.2010-04.com.rao:storage.xvdb1
</code></pre>
<p>在客户端用iscsiadm -m node -p 10.12.13.86 &ndash;targetname iqn.2010-04.com.rao:storage.xvdb1 &ndash;login命令，就可以连上磁盘了。然后用fdisk -l命令可以看到如下输出：</p>
<pre><code>Disk /dev/sda: 750.1 GB, 750153729024 bytes
</code></pre>
<p>试验到目前为止一切正常。然后再mount这个sda的时候，赫然提示没有格式化！！
好吧，fdisk /dev/sda然后mkfs.ext3 /dev/sda1再mount /dev/sda1 /mnt。
OK，返回服务器端，mount，居然提示ext3错误~~</p>
<p>再开一台，同样到mount的时候，又一次提示没有格式化。
难道iscsi和nfs不一样，压根不能多客户端同时连接一块磁盘？？？
还是说因为iscsi默认是sda，而虚拟机是xvda，之间有冲突？？？
于是返回谷歌搜索“iscsi xen”，结果看来应该是第一种了。
<a href="http://www.performancemagic.com/iscsi-xen-howto/index.html">xen和iscsi的常见合用</a>
，是在Domain0上链接iscsi，然后基于不同的target分别create虚拟机模板和虚拟机磁盘，进一步可以保证虚拟平台出问题时，可以迅速的转移到另一个虚拟平台上。
而后看到<a target="_blank" href="http://www.sansky.net/">存储部落</a>中的介绍，iscsi可以同样理解为裸设备，要达到网络共享，需要配套另外的共享软件~比如GFS</p>
      <a href="/2010/04/12/intro-iscsi-1" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/10/refresh-problem-of-js-location_replace" title="客户页面小故障" rel="bookmark">客户页面小故障</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-10 00:00:00 +0800">10 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#cdn-ref" title="cdn" rel="category tag">cdn</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>今天接到客户电话，说，主页已经提交过了刷新任务，上面的图片已经更新，但点击图片后链接到的页面内容还是老的……
仔细一看，原来主页里的html是这么定义的：</p>
<div class="highlight"><pre><code class="html"><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://msn.golfbox.cn/cache/922/36717.html&quot;</span> <span class="na">target=</span><span class="s">&quot;_blank&quot;</span><span class="nt">&gt;&lt;img</span> <span class="na">src=</span><span class="s">&quot;/upload/img/20100410/20100410144202.jpg&quot;</span> <span class="na">width=</span><span class="s">&quot;125&quot;</span> <span class="na">height=</span><span class="s">&quot;80&quot;</span> <span class="na">class=</span><span class="s">&quot;border_blue&quot;</span> <span class="nt">/&gt;&lt;/a&gt;</span>
</code></pre></div>
<p>而http://msn.golfbox.cn/cache/922/36717.html的内容是这样：</p>
<div class="highlight"><pre><code class="html"><span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">&quot;Content-Type&quot;</span> <span class="na">content=</span><span class="s">&quot;text/html; charset=utf-8&quot;</span> <span class="nt">/&gt;&lt;script </span><span class="na">language=</span><span class="s">&quot;JavaScript&quot;</span><span class="nt">&gt;</span>
<span class="err"> </span><span class="nx">location</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s2">&quot;http://msn.golfbox.cn/cache/874/36804.html&quot;</span><span class="p">);</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div>
<p>于是跟客户交流确认，他们网站的主页框架上比较固定的地方，都是采用这种方式，来提供内容更新的。。。
他们又不肯给出具体更新了那些跳转页面，只好写个小脚本，去处理比对。如果有相同url的location.replace地址不统一的，就强制更新这些页面。</p>
<div class="highlight"><pre><code class="bash"><span class="c">#!/bin/bash</span>
curl http://msn.golfbox.cn/ |sed <span class="s1">&#39;s/\n//g&#39;</span>|sed <span class="s1">&#39;s/href=/\n/g&#39;</span>|grep <span class="s2">&quot;^&quot;</span>http://msn.golfbox.cn/cache<span class="s2">&quot;|awk -F&#39;&quot;</span><span class="s1">&#39; &#39;</span><span class="o">{</span>print <span class="nv">$2</span><span class="o">}</span><span class="s1">&#39;&gt;url</span>
<span class="s1">for j in `cat url`;do</span>
<span class="s1"> for i in `cat ip`;do</span>
<span class="s1">  curl -x $i:80 $j|awk -F&#39;</span><span class="s2">&quot;&#39; &#39;/replace/{print &quot;</span><span class="s1">&#39;$j&#39;</span><span class="s2">&quot;,&quot;</span><span class="s1">&#39;$i&#39;</span><span class="s2">&quot;,$2}&#39;&gt;&gt;golfbox.log</span>
<span class="s2">#  curl -x $i:80 -I $j|awk &#39;/Age/{print &quot;</span><span class="s1">&#39;$j&#39;</span><span class="s2">&quot;,&quot;</span><span class="s1">&#39;$i&#39;</span><span class="s2">&quot;,$2}&#39;&gt;&gt;age.log</span>
<span class="s2"> done</span>
<span class="s2">done</span>
<span class="s2">cat golfbox.log |awk &#39;{if($1==a){if($3!=b){system(&quot;</span>/home/squid/bin/squidclient -p 80 -h <span class="s2">&quot;$2&quot;</span> -m purge <span class="err">&quot;</span><span class="nv">$1</span><span class="o">)}}</span>;<span class="nv">a</span><span class="o">=</span><span class="nv">$1</span>;<span class="nv">b</span><span class="o">=</span><span class="nv">$3</span><span class="o">}</span><span class="err">&#39;</span>
</code></pre></div>
<p>（该脚本有一个问题：如果刚好是第一台的url未更新，结果会反而去刷新那些已经更新了的服务器；所以应该是输出url，然后再用for do done去刷新所有服务器~如果curl可以在获取内容的同时获取Age就好了~所以最后用一个讨巧的办法：在ip列表的最开始放上客户源站的ip，这样就能保证最新了）
以上是第一个。
第二个：
客户首页上还有一个问题：其右下角有跟随悬浮窗口，本来应该可以关闭的。但一点关闭，就提示javascrpt:iclose()错误页面。而用浏览器另存为html到桌面以后，再打开保存下来的页面，点击关闭就正常关闭了！
经过查找，其中调用的js文件是http://msn.golfbox.cn/js/show.js，内容中关于javascrpt:iclose()的内容如下：</p>
<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">sogouTall</span> <span class="o">=</span><span class="s1">&#39;&lt;div style=&quot;z-index:1000;position: absolute;display:none;&quot; id=&quot;sogoubox&quot;&gt;&#39;</span>
<span class="err">  </span> <span class="o">+</span><span class="s1">&#39;&lt;a href=&quot;javascript:iclose();&quot; style=&quot;float:left; margin-left:190px&quot;&gt;关闭&lt;/a&gt;&#39;</span>
<span class="err">  </span> <span class="o">+</span><span class="s1">&#39;&lt;div style=&quot;clear:both&quot;&gt;&#39;</span>
<span class="err">  </span> <span class="o">+</span><span class="s1">&#39;&lt;a href=&quot;&lt;a href=&quot;http://new.msn.golfbox.cn/wd/&quot;&gt;http://new.msn.golfbox.cn/wd/&quot;&gt;&lt;img&lt;/a&gt; src=&quot;&lt;a href=&quot;http://new.msn.golfbox.cn/wd/dbtt.jpg&quot;&gt;http://new.msn.golfbox.cn/wd/dbtt.jpg&lt;/a&gt;&quot; style=&quot;width:220px;height:160px&quot;/&gt;&lt;/a&gt;&#39;</span>
<span class="err">     </span> <span class="o">+</span> <span class="s1">&#39;&lt;input type=hidden name=&quot;sogouAccountId&quot; value=&quot;202014&quot;&gt;&#39;</span>
<span class="err">  </span> <span class="o">+</span> <span class="s1">&#39;&#39;</span>
<span class="err"> </span><span class="kd">function</span> <span class="nx">iclose</span><span class="p">()</span>
<span class="err"> </span><span class="p">{</span>
<span class="err">  </span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;sogoubox&#39;</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">display</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">;</span>
<span class="err"> </span><span class="p">}</span>
</code></pre></div>
<p>以我浅薄的web知识，是没看出来什么问题~~客户也莫名其妙，最好撤销掉这个窗口了</p>
      <a href="/2010/04/10/refresh-problem-of-js-location_replace" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/08/url_rewrite_concurrency" title="url_rewrite_concurrency" rel="bookmark">url_rewrite_concurrency</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-08 00:00:00 +0800">08 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#squid-ref" title="squid" rel="category tag">squid</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>squid的重定向，我看网上一般都采用 <code>redirect_children</code> (即 <code>url_rewrite_children</code>)。估计是因为中文权威指南的原因吧。不过中文权威指南还是2.5版的时候出的。有些新东西没有。比如 <code>squid.conf.default</code> 中提供的另一种 <code>url_rewrite_concurrency</code>。</p>
<p>官方使用说明如右：<a href="http://wiki.squid-cache.org/Features/Redirectors#How_do_I_make_it_concurrent.3F">http://wiki.squid-cache.org/Features/Redirectors#How_do_I_make_it_concurrent.3F</a></p>
<p>简单的说，就是开启 <code>url_rewrite_concurrency</code> 后，squid传递给rewriter的流由四个域增加为五个——最前头多了一个ID。然后rewriter返回的，也就有两个域，ID和uri。</p>
<p>简单修改一下原来的脚本如下即可：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl -wl</span>
<span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
<span class="vg">$|</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span><span class="nv">$id</span><span class="p">,</span><span class="nv">$url</span><span class="p">,</span><span class="nv">$client</span><span class="p">,</span><span class="nv">$ident</span><span class="p">,</span><span class="nv">$method</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span> <span class="p">);</span>
    <span class="p">(</span><span class="nv">$id</span><span class="p">,</span> <span class="nv">$url</span><span class="p">,</span> <span class="nv">$client</span><span class="p">,</span> <span class="nv">$ident</span><span class="p">,</span> <span class="nv">$method</span><span class="p">)</span> <span class="o">=</span> <span class="nb">split</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$url</span> <span class="o">=~</span><span class="n">m</span><span class="c1">#^(.*)(?.*)#i) {</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$domain</span><span class="p">,</span><span class="nv">$option</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$1</span><span class="p">,</span><span class="nv">$2</span><span class="p">);</span>
        <span class="k">print</span> <span class="s">&quot;$id $domain\n&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">print</span> <span class="s">&quot;$id\n&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>然后squid.conf里修改如下：</p>
<div class="highlight"><pre><code class="squid"><span class="k">acl</span><span class="w"> </span>rewriteurl<span class="w"> </span><span class="k">url_regex</span><span class="w"> </span>-i<span class="w"> </span>^http://drag.g1d.net/.*.mp40drag?<span class="w"></span>
url_rewrite_access<span class="w"> </span><span class="no">deny</span><span class="w"> </span>!rewriteurl<span class="w"></span>
url_rewrite_program<span class="w"> </span>/home/squid/etc/redirect.pl<span class="w"></span>
<span class="c">#url_rewrite_children 10</span><span class="w"></span>
url_rewrite_concurrency<span class="w"> </span><span class="m">10</span><span class="w"></span>
</code></pre></div>
      <a href="/2010/04/08/url_rewrite_concurrency" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/03/a-unfound-option-of-date-command" title="date的一个怪问题" rel="bookmark">date的一个怪问题</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-03 00:00:00 +0800">03 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#bash-ref" title="bash" rel="category tag">bash</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>今天看同事的一个备份脚本，在取昨天的日期时，采用了YESTERDAY_NAME=<code>date -I -d'-1 day' +"%Y-%m-%d"</code>的方法。</p>
<p>我对这个方法比较感兴趣，赶紧试试，结果赫然返回“date: multiple output formats specified”的报错来！</p>
<p>而单独采用date -I -d&rsquo;-1 day&rsquo;或者date -d&rsquo;-1 day&rsquo; +&rdquo;%Y-%m-%d&rdquo;这两种方法，都能返回正确结果。</p>
<p>返回同事的机器上，运行原命令确实没有问题。于是开始查版本，我的机器bash是3.2.25，date是5.97；他的bash是3.0.0.9，date是5.2.1。</p>
<p>不过在date -help中，不论是我的，还是他的机器上，都没发现-I这个option！！</p>
<p>为了移植性，同事也更改脚本删除了-I。不过之前脚本中为什么有这个，为什么还就真能跑，真是怪事~~</p>
      <a href="/2010/04/03/a-unfound-option-of-date-command" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/04/02/diff-between-lvs-active_conn-and-netstat-conn" title="lvs的activeconn与netstat的conn" rel="bookmark">lvs的activeconn与netstat的conn</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-04-02 00:00:00 +0800">02 Apr 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#linux-ref" title="linux" rel="category tag">linux</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>曾经有过一组高并发请求的服务器，在lvs上看到单台 activeconn 约等于 220000；同时，在RS上执行 <code>netstat -s -t|grep "connections established"</code> 结果大概是 65000，而 <code>squidclient mgr:5min|grep client_http.requests</code> 结果却只有 180。后来说起并发数的时候，有些茫然，到底哪个才算是呢？</p>
<p>今天在squid-user里问起，居然有幸碰见另一位中国订阅者，夏兄随后提供给我一个06年的帖子，所述甚详。算是解惑了~
<a href="http://www.linuxsir.org/bbs/showthread.php?t=248500">http://www.linuxsir.org/bbs/showthread.php?t=248500</a></p>
<p>原来 lvs 默认有个超时时间，可以用 <code>ipvsadm -L --timeout</code> 查看，默认是 <code>900 120 300</code> ，分别是 <code>TCP TCPFIN UDP</code> 的时间。</p>
<p>而RS上参数如下：</p>
<div class="highlight"><pre><code class="bash">net.ipv4.tcp_keepalive_time <span class="o">=</span> 600
net.ipv4.route.gc_timeout <span class="o">=</span> 100
net.ipv4.tcp_fin_timeout <span class="o">=</span> 30
net.ipv4.netfilter.ip_conntrack_tcp_timeout_close <span class="o">=</span> 10
net.ipv4.netfilter.ip_conntrack_tcp_timeout_max_retrans <span class="o">=</span> 300
net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait <span class="o">=</span> 120
net.ipv4.netfilter.ip_conntrack_tcp_timeout_last_ack <span class="o">=</span> 30
net.ipv4.netfilter.ip_conntrack_tcp_timeout_close_wait <span class="o">=</span> 60
net.ipv4.netfilter.ip_conntrack_tcp_timeout_fin_wait <span class="o">=</span> 120
net.ipv4.netfilter.ip_conntrack_tcp_timeout_established <span class="o">=</span> 300
net.ipv4.netfilter.ip_conntrack_tcp_timeout_syn_recv <span class="o">=</span> 60
net.ipv4.netfilter.ip_conntrack_tcp_timeout_syn_sent <span class="o">=</span> 120
net.ipv4.netfilter.ip_conntrack_udp_timeout_stream <span class="o">=</span> 180
net.ipv4.netfilter.ip_conntrack_udp_timeout <span class="o">=</span> 30
</code></pre></div>
<p>可见 RS 的超时时间（仅指 <code>ESTABLISHED</code> ）比 LVS 小了 3 倍。再加上 <code>WAIT</code> 和 <code>SYN_RECV</code> 等状态，差不多就是 220000/65000 的比例了。而 squid 的 RPS 是按秒计算的，<code>180*300=~55000</code> ，在数量级上和 netstat 的结果也就差不多了~ </p>
      <a href="/2010/04/02/diff-between-lvs-active_conn-and-netstat-conn" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/03/30/purge-script-by-perl" title="perl边学边练（purge脚本）" rel="bookmark">perl边学边练（purge脚本）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-03-30 00:00:00 +0800">30 Mar 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#cdn-ref" title="cdn" rel="category tag">cdn</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>squid的purge，一般有两种方式，squidclient -m purge url或者http request (method)purge url。如果任务不太多的情况下，直接使用squidclient -p 80 -h 1.2.3.4 -m purge url即可。如果任务比较繁重的情况下，telnet80后直接发送purge请求稍微好一些。作为初学perl的练手，写一个purge脚本。如下：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl -w</span>
<span class="k">use</span> <span class="nn">IO::</span><span class="n">Socket</span><span class="p">;</span>
<span class="c1">#检测脚本参数个数</span>
<span class="k">unless</span> <span class="p">(</span><span class="nv">@ARGV</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nb">die</span> <span class="s">&quot;usage: $0 url&quot;</span> <span class="p">}</span>
<span class="c1">#打开ip列表文件，定义文件句柄HOST</span>
<span class="nb">open</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span><span class="s">&quot;./ip&quot;</span><span class="p">);</span>
<span class="c1">#定义连接结束符，然后翻倍（汗这个方式~）</span>
<span class="nv">$EOL</span> <span class="o">=</span> <span class="s">&quot;1512&quot;</span><span class="p">;</span>
<span class="nv">$BLANK</span> <span class="o">=</span> <span class="nv">$EOL</span> <span class="n">x</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">#从打开的文件中读取具体ip</span>
<span class="c1">#@host = HOST;</span>
<span class="c1">#my $ip;</span>
<span class="c1">#foreach $ip(@host){</span>
<span class="c1">#当ip列表较大时，采用@host的方法可能out of memory，所以采取逐行读取</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">defined</span><span class="p">(</span><span class="nv">$ip</span><span class="o">=</span><span class="sr">&lt;HOST&gt;</span><span class="p">)){</span>
    <span class="c1">#从参数中默认读取url变量</span>
    <span class="k">foreach</span> <span class="nv">$document</span> <span class="p">(</span> <span class="nv">@ARGV</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">#利用IO::Socket::INET模块定义TCP80连接，port可以读取/etc/services文件里的定义</span>
        <span class="nv">$remote</span> <span class="o">=</span> <span class="nn">IO::Socket::</span><span class="n">INET</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span> <span class="n">Proto</span>     <span class="o">=&gt;</span> <span class="s">&quot;tcp&quot;</span><span class="p">,</span>
                                         <span class="n">PeerAddr</span><span class="err"> </span> <span class="o">=&gt;</span> <span class="nv">$ip</span><span class="p">,</span>
                                         <span class="n">PeerPort</span><span class="err"> </span> <span class="o">=&gt;</span> <span class="s">&quot;http(80)&quot;</span><span class="p">,</span>
                                       <span class="p">);</span>
        <span class="k">unless</span> <span class="p">(</span><span class="nv">$remote</span><span class="p">)</span> <span class="p">{</span> <span class="nb">die</span> <span class="s">&quot;cannot connect to http daemon on $ip&quot;</span> <span class="p">}</span>
        <span class="c1">#立即输出</span>
        <span class="nv">$remote</span><span class="o">-&gt;</span><span class="n">autoflush</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">#向定义的TCP连接文件句柄发送purge请求</span>
        <span class="c1">#这里可以直接&quot;\n\n&quot;，不过采用&quot;&quot;.$BLANK的方式可能规范一些，因为在win或者mac的平台上，是不一样的</span>
        <span class="k">print</span> <span class="nv">$remote</span> <span class="s">&quot;PURGE $document HTTP/1.0&quot;</span> <span class="o">.</span> <span class="nv">$BLANK</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="sr">&lt;$remote&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="k">print</span> <span class="p">}</span>
        <span class="c1">#关闭tcp连接</span>
        <span class="nb">close</span> <span class="nv">$remote</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">#关闭ip列表文件</span>
<span class="nb">close</span><span class="p">(</span><span class="n">HOST</span><span class="p">);</span>
</code></pre></div>
      <a href="/2010/03/30/purge-script-by-perl" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/03/28/modify-error_page-src-for-location" title="squid源站故障转向（终结篇）" rel="bookmark">squid源站故障转向（终结篇）</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-03-28 00:00:00 +0800">28 Mar 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#cdn-ref" title="cdn" rel="category tag">cdn</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>因为这么一个想法，我陆陆续续的把squid很多功能都理了一遍，今天终于打算写个不完美的终结篇。而就在写这个终结篇的同时，公司里也已经开始把这批别扭的客户改往nginx平台加速了。</p>
<p>总结这批客户的跳转要求，其实格式都比较统一，大抵就是*.abc.com(.cn)坏了就转到abc.cdn.21vokglb.cn。在3月24日的博文最后，已经有了一个思路——既然无法执行php的header(Location)和strstr(%U)，那么就干脆在squid的src里对%U进行操作好了。</p>
<p>squid-src/errorpage.c中关于%U的注释是：</p>
<pre><code>U - URL without password
</code></pre>
<p>相关语句是：</p>
<div class="highlight"><pre><code class="c"><span class="n">p</span> <span class="o">=</span> <span class="n">r</span> <span class="o">?</span> <span class="n">urlCanonicalClean</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">err</span><span class="o">-&gt;</span><span class="n">url</span> <span class="o">?</span> <span class="n">err</span><span class="o">-&gt;</span><span class="n">url</span> <span class="o">:</span> <span class="s">&quot;[no URL]&quot;</span><span class="p">;</span>
</code></pre></div>
<p>只要把url按&rdquo;.&rdquo;分割，然后取出第二个域abc，就可以在html代码中给它加上跳转后的url了——这一步也能在src里完成，不过以后不好修改了，虽然现在这样子的定制性也强不到哪去~
从大二到现在无数年了，c已经属于忘到冥王星外的东东，于是一个一个的翻c的字符串函数，从strstr、strchr、strcat、strtok、strsep到最后终于发现sscanf。只要在src/errorpage.c的588行下加这么一句话就可以了：</p>
<div class="highlight"><pre><code class="c"><span class="mi">587</span><span class="err">    </span> <span class="k">case</span> <span class="sc">&#39;U&#39;</span>:
<span class="mi">588</span><span class="err">        </span> <span class="n">p</span> <span class="o">=</span> <span class="n">r</span> <span class="o">?</span> <span class="n">urlCanonicalClean</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">err</span><span class="o">-&gt;</span><span class="n">url</span> <span class="o">?</span> <span class="n">err</span><span class="o">-&gt;</span><span class="n">url</span> <span class="o">:</span> <span class="s">&quot;[no URL]&quot;</span><span class="p">;</span>
<span class="mi">589</span><span class="o">+</span><span class="err">     </span> <span class="n">sscanf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="s">&quot;%*[^.].%[^.]&quot;</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
<span class="mi">590</span><span class="err">        </span> <span class="k">break</span><span class="p">;</span>
</code></pre></div>
<p>然后编译安装，一路通过没有问题~~启动squid服务，测试一下%U吧~
先把ERR_ACCESS_DENIED内容修改如下：</p>
<div class="highlight"><pre><code class="html"><span class="nt">&lt;HTML&gt;</span>
<span class="nt">&lt;BODY&gt;</span>
<span class="nt">&lt;head&gt;</span>
<span class="nt">&lt;META</span> <span class="na">HTTP-EQUIV=</span><span class="s">&quot;refresh&quot;</span><span class="err">  </span> <span class="na">Content=</span><span class="s">&quot;0;URL=http://%U.cdn.21vokglb.cn/index.htm&quot;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;/HTML&gt;</span>
</code></pre></div>
<p>然后在squid.conf中增加对自己本机的访问控制如下：</p>
<div class="highlight"><pre><code class="squid"><span class="k">acl</span><span class="w"> </span>test<span class="w"> </span><span class="k">src</span><span class="w"> </span><span class="mf">222.62.104.189/255.255.255.255</span><span class="w"></span>
<span class="k">http_access</span><span class="w"> </span><span class="no">deny</span><span class="w"> </span>rao<span class="w"></span>
</code></pre></div>
<p>squid -k reconfigure生效，访问一下www.xyfunds.com.cn，果然跳转到xyfunds.cdn.21vokglb.cn/index.htm啦~~
完毕。
虽然最终还是没能达到任意定义跳转url的目标，不过就本身的出发点来说，还是完成了需求。这也是我N年来第一次重新看C，也是第一次修改squid代码，虽然只加了一句~~~不过意义还是有滴，晚上吃个鸡蛋自我犒劳一下咯。</p>
      <a href="/2010/03/28/modify-error_page-src-for-location" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/03/25/zabbix_proxy-install" title="zabbix_proxy部署" rel="bookmark">zabbix_proxy部署</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-03-25 00:00:00 +0800">25 Mar 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p><em>continue</em></p>
<p>zabbix作为分布式监控系统，不试试实在可惜。好在做起来也简单。  <br />
首先要求编译时有enable-proxy参数，这个已经有了；  <br />
然后修改zabbix_proxy.conf，和zabbix_server.conf相同的修改（DB等）就不再说了：  <br />
Server=要写最上层zabbix的ip  <br />
Hostname=要写独一无二的，在最上层zabbix的web配置上要用  <br />
ConfigFrequency=这个是配置同步时间差，设短一点，默认3600太长  <br />
TrapperTimeout=超时时间，设短一点，默认300，最好不超过30    </p>
<p>然后在最上层的zabbix的web界面上添加proxy即可。administrator-DM-proxy-Add，填入刚才独一无二的那个Hostname即可。    </p>
<p>Add Host的时候，选择proxy——host里agentd.conf的Server也必须是相应proxy的ip才行。  <br />
<em>To_be_continued</em>    </p>
      <a href="/2010/03/25/zabbix_proxy-install" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/03/25/cacti-optimization" title="cacti优化" rel="bookmark">cacti优化</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-03-25 00:00:00 +0800">25 Mar 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>首先，采用spine代替cmd.php来采集数据。
下载与cacti相应版本的spine和补丁：</p>
<div class="highlight"><pre><code class="bash">wget http://www.cacti.net/downloads/spine/cacti-spine-0.8.7e.tar.gz
tar zxvf cacti-spine-0.8.7e.tar.gz -C /tmp
<span class="nb">cd</span> /tmp/cacti-spine-0.8.7e
wget http://www.cacti.net/downloads/spine/patches/snmp_v3_fix.patch
wget http://www.cacti.net/downloads/spine/patches/mysql_client_reconnect.patch
wget http://www.cacti.net/downloads/spine/patches/ping_reliability.patch
patch -p1 -N &lt; snmp_v3_fix.patch
patch -p1 -N &lt; mysql_client_reconnect.patch
patch -p1 -N &lt; ping_reliability.patch
./configure –prefix<span class="o">=</span>/cache/data/cacti --with-mysql<span class="o">=</span>/home/mysql
make
<span class="c"># 这个时候发现报错了，spine0.8.7e编译安装要求最新版本的automake1.11，于是去下automake：</span>
wget http://ftp.gnu.org/gnu/automake/automake-1.11.tar.gz
tar zxvf automake-1.11.tar.gz -C /tmp/
<span class="nb">cd</span> /tmp/automake-1.11/
./configure --prefix<span class="o">=</span>/usr
<span class="c"># 又报错，automake1.11要求新版本的autoconf2.64，于是去下autoconf：</span>
wget http://ftp.gnu.org/gnu/autoconf/autoconf-2.65.tar.gz
tar zxvf autoconf-2.65.tar.gz -C /tmp/
<span class="nb">cd</span> /tmp/autoconf-2.65/
./configure --prefix<span class="o">=</span>/usr <span class="o">&amp;&amp;</span> make <span class="o">&amp;&amp;</span> make install
</code></pre></div>
<p>返回安装automake，即可成功；安装spine，也成功了。  <br />
修改/cache/data/cacti/etc/spine.conf里的db信息，和cacti的global.php里一致。  <br />
登陆web界面，settings中修改poller type为spine，修改Spine Specific Execution Parameters里的Maximum Threads per Process为cpu数的2倍。save~  <br />
第二、给cacti-tables建index。默认的cacti.sql里一个index索引都没有~    </p>
<div class="highlight"><pre><code class="sql"><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="o">`</span><span class="n">data_template_data_id</span><span class="o">`</span> <span class="k">ON</span> <span class="o">`</span><span class="n">data_input_data</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">data_template_data_id</span><span class="o">`</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="o">`</span><span class="n">host_id_snmp_query_id_snmp_index</span><span class="o">`</span> <span class="k">ON</span> <span class="n">data_local</span> <span class="p">(</span><span class="o">`</span><span class="n">host_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">snmp_query_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">snmp_index</span><span class="o">`</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="o">`</span><span class="n">local_data_id_data_source_name</span><span class="o">`</span> <span class="k">ON</span> <span class="n">data_template_rrd</span> <span class="p">(</span><span class="o">`</span><span class="n">local_data_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">data_source_name</span><span class="o">`</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="o">`</span><span class="n">graph_template_id_local_graph_id</span><span class="o">`</span> <span class="k">ON</span> <span class="n">graph_templates_item</span> <span class="p">(</span><span class="o">`</span><span class="n">graph_template_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">local_graph_id</span><span class="o">`</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="o">`</span><span class="n">local_graph_template_item_id</span><span class="o">`</span> <span class="k">ON</span> <span class="n">graph_templates_item</span> <span class="p">(</span><span class="o">`</span><span class="n">local_graph_template_item_id</span><span class="o">`</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="o">`</span><span class="n">host_id_snmp_query_id_snmp_index</span><span class="o">`</span> <span class="k">ON</span> <span class="n">host_snmp_cache</span> <span class="p">(</span><span class="o">`</span><span class="n">host_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">snmp_query_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">snmp_index</span><span class="o">`</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="o">`</span><span class="n">local_data_id_rrd_path</span><span class="o">`</span> <span class="k">ON</span> <span class="n">poller_item</span> <span class="p">(</span><span class="o">`</span><span class="n">local_data_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">rrd_path</span><span class="o">`</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="o">`</span><span class="n">host_id_rrd_next_step</span><span class="o">`</span> <span class="k">ON</span> <span class="n">poller_item</span> <span class="p">(</span><span class="o">`</span><span class="n">host_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">rrd_next_step</span><span class="o">`</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">host_id_snmp_query_id</span> <span class="k">ON</span> <span class="n">host_snmp_cache</span> <span class="p">(</span><span class="n">host_id</span><span class="p">,</span><span class="n">snmp_query_id</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">host_id_snmp_port</span> <span class="k">ON</span> <span class="n">poller_item</span> <span class="p">(</span><span class="n">host_id</span><span class="p">,</span><span class="n">snmp_port</span><span class="p">);</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">data_source_path</span> <span class="k">ON</span> <span class="n">data_template_data</span> <span class="p">(</span><span class="n">data_source_path</span><span class="p">);</span>
</code></pre></div>
<p>第三、重构rra目录结构。按照device分结构。  <br />
/home/php/bin/php /cache/data/cacti/cli/structure_rra_paths.php &ndash;proceed即可。  <br />
web界面中settings里的Paths可以勾选Structured RRA Path(/host_id/local_data_id.rrd)即可。    </p>
<p>最后，据这个优化的<a target="_blank" href="http://zys.8800.org/index.php/archives/391/comment-page-1#comment-22">原作者</a>说，按此步骤，710台服务器，24000个RRD文件，完成一次poller.php的时间，缩短到50 seconds。</p>
      <a href="/2010/03/25/cacti-optimization" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2010/03/24/monitor-tcp-conns-by-cacti" title="cacti自建tcp80连接数监控" rel="bookmark">cacti自建tcp80连接数监控</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2010-03-24 00:00:00 +0800">24 Mar 2010</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>同样作为提供web服务的机器，因为不同业务的关系，除了流量以外，还需要参考TCP80连接数来分析服务器性能状况。下面就试试cacti对连接数的监控。
最简单的方法，利用snmpnetstat这个命令，自动搞定一切。cactiuser.org上提供一个现成的模板，只要import就能直接用。下载地址如右：<a href="http://www.iammecn.com/wp-content/uploads/2009/12/cacti_graph_template_snmp_connections.zip" target="_blank">http://www.iammecn.com/wp-content/uploads/2009/12/cacti_graph_template_snmp_connections.zip</a></p>
<p>不过这个snmpnetstat用起来精准度不太好保证，比如我在测试机上运行如下：</p>
<pre><code>[root@BeiJingBGP-Dns-02 ~]# snmpnetstat  -c 'public' -v 2c 10.10.10.43:161
Active Internet (udp) Connections
Proto Local Address
udp   *.ntp
udp   *.snmp
udp   *.filenet-
udp   *.54927
udp   localhost.domain
udp   localhost.ntp
udp   localhost.domain
udp   localhost.ntp
udp   211.151.65.53.ntp
udp   211.151.67.80.domain
</code></pre>
<p>居然一个tcp都没显示出来。我汗~~
所以采用一个自建脚本模板的方法来完成吧~~
首先在host上新建/etc/snmp/tcpconn.sh，内容如下：</p>
<div class="highlight"><pre><code class="bash"><span class="c">#!/bin/sh</span>
<span class="nv">conn</span><span class="o">=</span><span class="sb">`</span>netstat -s -t | grep connections established |awk <span class="s1">&#39;{print $1}&#39;</span><span class="sb">`</span>
<span class="nb">echo</span> <span class="nv">$conn</span>
</code></pre></div>
<table>
  <tbody>
    <tr>
      <td>对这个脚本我个人持保留意见。因为在netstat -anpl</td>
      <td>grep :80</td>
      <td>wc -l、netstat -s -t和/proc/net/tcp中来看，netstat -s -t最省时间，但数字也最不准~</td>
    </tr>
  </tbody>
</table>
<p>三种方法测试如下：
    [root@BeiJingBGP-Dns-02 ~]# time netstat -s -t|awk &lsquo;/connections established/{print $1}&rsquo;
    3</p>
<pre><code>real    0m0.008s
user    0m0.000s
sys    0m0.008s
[root@BeiJingBGP-Dns-02 ~]# time netstat -plna|awk '/:80/{a++}END{print a}'
1
real    0m0.065s
user    0m0.000s
sys    0m0.048s
[root@BeiJingBGP-Dns-02 ~]# time awk '$4=="01"{a++}END{print a}' /proc/net/tcp
real    0m0.023s
user    0m0.000s
sys    0m0.024s
</code></pre>
<table>
  <tbody>
    <tr>
      <td>（话说顺便试了一下</td>
      <td>grep :80</td>
      <td>wc -l和</td>
      <td>awk &lsquo;/:80/{a++}END{print a}&rsquo;的time，awk快5ms，哈哈~）</td>
    </tr>
  </tbody>
</table>
<p>然后在/etc/snmp/snmpd.cong里添加如下句：</p>
<pre><code>exec .1.3.6.1.4.1.2021.18 tcpCurrEstab /etc/snmp/tcpconn.sh
</code></pre>
<p>重启snmpd服务即可。</p>
<p>回cacti服务器端，运行如下命令，可以看到相关输出即可。</p>
<pre><code>[root@BeiJingBGP-Dns-02 ~]# snmpwalk -c 'public' -v 2c 10.10.10.43 .1.3.6.1.4.1.2021.18
UCD-SNMP-MIB::ucdavis.18.1.1 = INTEGER: 1
UCD-SNMP-MIB::ucdavis.18.2.1 = STRING: "tcpCurrEstab"
UCD-SNMP-MIB::ucdavis.18.3.1 = STRING: "/etc/snmp/tcpconn.sh"
UCD-SNMP-MIB::ucdavis.18.100.1 = INTEGER: 0
UCD-SNMP-MIB::ucdavis.18.101.1 = STRING: "3"
UCD-SNMP-MIB::ucdavis.18.102.1 = INTEGER: 0
UCD-SNMP-MIB::ucdavis.18.103.1 = ""
</code></pre>
<p>这个string:&rdquo;3&rdquo;就是真正的tcp80连接数。
然后进入cacti的web页面进行设置吧：</p>
<table>
  <tbody>
    <tr>
      <td>在cacti界面中console-&gt;Templates-&gt;Data Templates，然后点击右上角的Add，Data Templates中的name是给这个数据模板的命名，Data Source中的name将来显示在Data Sources中，我这里添加“</td>
      <td>host_description</td>
      <td>– Tcp Conn. – ESTBLISHED”，选get snmp data，Internal Data Source Name也可以随便添，这个用来给rrd文件命名。设置完后就可以create了，之后会发现下面多了一些选项，在最下面那个添上我们需要的数据的OID“.1.3.6.1.4.1.2021.18.101.1”，可以save了。</td>
    </tr>
  </tbody>
</table>
<table>
  <tbody>
    <tr>
      <td>此后需要创建一个Graph Templates，好让cacti生成图片。在cacti界面中console-&gt;Templates-&gt;Graph Templates，然后点击右上角的Add，Templates中的name是给这个数据模板的命名，Graph Template中的name是将来显示在图片上面中间的内容，我这里添加“</td>
      <td>host_description</td>
      <td>– Tcp Conn. –ESTBLISHED”，其他保持默认，保存之后上面会出来一些选项。在Graph Template Items中添加一个item，Data Source选之前添加的，color选择一个图片的颜色，Graph Item Type选AREA，也就是区域，也可以选其他的线条，Text Format设置说明。然后再添加一个，Graph Item Type选GPRINT，Consolidation Function选LAST，也就是当前的值，Text Format输入current。你还可以添加一些Graph Item Type为COMMENT的注释说明等。</td>
    </tr>
  </tbody>
</table>
<p>最后，可以把graph加进host templates，或者直接在device中加graph。过一会就能看到图啦~~~</p>
      <a href="/2010/03/24/monitor-tcp-conns-by-cacti" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div id="post-pagination" class="pagination pagination-centered">
  <ul class="pages nav nav-pills">
    <li>
      <a href="/page11">Previous</a>
    </li>
    <li class="page">
      <a href="/">1</a>
    </li>
    <li class="page">
      <a href="/page2">2</a>
    </li>
    <li class="page">
      <a href="/page3">3</a>
    </li>
    <li class="page">
      <a href="/page4">4</a>
    </li>
    <li class="page">
      <a href="/page5">5</a>
    </li>
    <li class="page">
      <a href="/page6">6</a>
    </li>
    <li class="page">
      <a href="/page7">7</a>
    </li>
    <li class="page">
      <a href="/page8">8</a>
    </li>
    <li class="page">
      <a href="/page9">9</a>
    </li>
    <li class="page">
      <a href="/page10">10</a>
    </li>
    <li class="page">
      <a href="/page11">11</a>
    </li>
    <li class="page active">
      <a href="#">12</a>
    </li>
    <li class="page">
      <a href="/page13">13</a>
    </li>
    <li class="page">
      <a href="/page14">14</a>
    </li>
    <li class="page">
      <a href="/page15">15</a>
    </li>
    <li class="page">
      <a href="/page16">16</a>
    </li>
    <li class="page">
      <a href="/page17">17</a>
    </li>
    <li>
      <a href="/page13">Next</a>
    </li>
  </ul>
</div>
</div>
      </div>
      <div class="span4">
          <div class="well sidebar-nav">
             <ul id="relate_blog" class="nav nav-list">
               <li class="nav-header">最近文章</li>
            </ul>
          </div>
        <div class="well sidebar-nav">
          <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=0&skin=2&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1035836154&verifier=a26926d5&dpc=1"></iframe>
        </div>
        <div class="well sidebar-nav">
            <div id="uyan_list_time_frame"></div>
            <script type="text/javascript" id="UYScriptTime" src="http://v1.uyan.cc/js/iframe_time_list.js?UYUserId=1589850&rankType=time" async=""></script>
        </div>
        <div class="well sidebar-nav">
          <ul id="linklists" class="nav nav-list">
            <li class="nav-header">友情链接(英文)</li>
              <li><a href="http://codeascraft.com/" title="Etsy 运维团队博客">Code as Craft</a></li>
              <li><a href="http://blog.dotcloud.com/" title="dotCloud 官方博客">dotCloud-Blog</a></li>
              <li><a href="http://devopsanywhere.blogspot.jp/" title="">devopsanywhere</a></li>
              <li><a href="http://www.jedi.be/blog/" title="">Jong En Dynamische Informatica</a></li>
              <li><a href="http://www.planetdevops.net/" title="">planetdevops</a></li>
              <li><a href="http://www.kitchensoap.com/" title="《网站运维》作者，Etsy 运维">Kitchen Soap</a></li>
              <li><a href="http://blog.johngoulah.com" title="Musings of linux, open source, cloud computing and systems">John Goulah</a></li>
              <li><a href="http://serverfault.com/" title="stackexchange下属的系统工程师问答网站">serverfault</a></li>
              <li><a href="http://www.thegeekstuff.com/" title="各种超酷Linux命令用法">TheGeekStuff</a></li>
              <li><a href="http://neilb.org/" title="The good,the bad,and the beautiful">neilb</a></li>
              <li><a href="http://blog.aka-cool.net/" title="">Aka.Why</a></li>
              <li><a href="http://www.reddit.com/r/perl/" title="">reddit perl 频道</a></li>
              <li><a href="http://jpetazzo.github.io/" title="">~jpetazzo</a></li>
              <li><a href="http://www.perfplanet.com/" title="News and views from the web performance blogosphere">Performance Planet</a></li>
              <li><a href="http://cuddletech.com/blog/" title="Use UNIX or die">Cuddle Tech</a></li>
              <li><a href="http://showmetheco.de/" title="Viacheslav Tykhanovskyi(PocketIO/Text::Haml)">No time to wait</a></li>
              <li><a href="http://blog.dataloop.io/" title="A new SaaS monitoring tool for DevOps & Operations">Dataloop.IO</a></li>
              <li><a href="http://www.ducea.com/" title="">MDLog:/sysadmin</a></li>
              <li><a href="http://www.thegeekstuff.com/" title="各种超酷Linux命令用法">TheGeekStuff</a></li>
              <li><a href="http://planeteria.org/perl6/" title="Perl6 文集">Planet Perl 6</a></li>
          </ul>
        </div>
        <div class="well sidebar-nav">
          <ul id="linklists" class="nav nav-list">
            <li class="nav-header">友情链接(中文)</li>
              <li><a href="http://www.nginxs.com/" title="">eric</a></li>
              <li><a href="http://www.hellodb.net/" title="Ali DBA 张瑞">Hello DBA</a></li>
              <li><a href="http://blog.nosqlfan.com/" title="not only sql信息集散地">NoSQLfan</a></li>
              <li><a href="http://ourmysql.com/" title="">OurMySQL</a></li>
              <li><a href="http://zauc.wordpress.com/" title="">Timo</a></li>
              <li><a href="http://julyclyde.org/" title="新浪系统工程师">七月的夏天</a></li>
              <li><a href="http://www.liurongxing.com/" title="">刘荣星</a></li>
              <li><a href="http://blog.s135.com/" title="金山·张宴">回忆未来</a></li>
              <li><a href="http://www.cnadn.net/" title="F5工程师">应用交付学习之路</a></li>
              <li><a href="http://scmbob.org/" title="杭州NSN工程师，shell高人~">扛一肩记忆</a></li>
              <li><a href="http://www.php-oa.com/" title="音悦台技术经理">扶凯</a></li>
              <li><a href="http://www.wenzizone.cn/" title="">蚊子世界</a></li>
              <li><a href="http://blog.liuts.com/" title="前天涯SA 刘天斯">运维进行时</a></li>
              <li><a href="http://www.lark.net.cn/" title="lark's cloud">lark's cloud</a></li>
              <li><a href="http://log.heartoutside.com/" title="HeartOutSide">HeartOutside</a></li>
              <li><a href="http://blog.liulantao.com/" title="刘兰涛">Lax</a></li>
              <li><a href="http://niubie.me/" title="莫言">莫言</a></li>
              <li><a href="http://noops.me/" title="小米运维部">NoOps</a></li>
              <li><a href="http://www.searchtech.pro/" title="">云端分布式搜索技术</a></li>
              <li><a href="http://www.usefulshare.com" title="当当网安全运维">UsefulShare</a></li>
              <li><a href="http://junqili.com/" title="深入研究puppet">纸飞机</a></li>
              <li><a href="http://www.chinaxing.org/" title="">ChinaXing</a></li>
              <li><a href="http://blog.sectop.org/" title="">kindle</a></li>
              <li><a href="http://bubbyroom.com/" title="守住每一天">Liuyu's blog</a></li>
          </ul>
        </div>
        <div class="well sidebar-nav">
          <ul id="booklists" class="nav nav-list">
          <li class="nav-header">我写的第一本技术书籍</li>
          <li><a href='http://product.china-pub.com/3769604'><img src='http://images.china-pub.com/ebook3765001-3770000/3769604/shupi.jpg' border='0' alt='网站运维技术与实践'/></a></li>
        </div>
      </div>
    </div> <!-- row -->
      <footer>
        <p>&copy; 陈子 2012 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>
    </div> <!-- /container -->
    <!-- JiaThis Button BEGIN -->
    <script type="text/javascript">var jiathis_config = {data_track_clickback:true};</script>
    <script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=1589850" charset="utf-8"></script>
    <!-- JiaThis Button END -->
    <!-- UJian Button BEGIN -->
    <script type="text/javascript" src="http://v1.ujian.cc/code/ujian.js?type=slide&uid=1589850"></script>
    <!-- UJian Button END -->
  </body>
</html>
