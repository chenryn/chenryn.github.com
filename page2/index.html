<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>三斗室</title>
    <meta name="author" content="陈子">
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/pygments/default.css" rel="stylesheet" type="text/css">
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">三斗室</a>
          <ul class="nav">
      	<li><a href="/tags.html">Tags</a></li>
      	<li><a href="/archive.html">Archive</a></li>
      	<li><a href="/categories.html">Categories</a></li>
      	<li><a href="/pages.html">Pages</a></li>
            <li><link title="RSS 2.0" type="application/rss+xml" href="http://chenlinux.com/feed.xml" rel="alternate" /><a href="http://chenlinux.com/feed.xml" target="_blank">RSS订阅</a></li>
            <li><a href="/projects.html">学习记录</a></li>
          </ul>
          <ul class="nav pull-right"><li><a href="/about.html">有关我</a></li></ul>
        </div>
      </div>
    </div>
    <div class="container">
    <div class="row">
      <div class="span7">
<div class="row">
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/06/24/who-to-calculate-days-between-two-date" title="计算两个时间点之间隔了几天" rel="bookmark">计算两个时间点之间隔了几天</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-06-24 00:00:00 +0800">24 Jun 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>两个时间点字符串，像这样：<code>2013-06-21</code>，怎么计算相距多少天呢？</p>
<p>有两种办法。</p>
<h2 id="datetime-">DateTime 模块</h2>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="n">DateTime</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">List::</span><span class="n">MoreUtils</span> <span class="sx">qw(zip)</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">Data::</span><span class="n">Dumper</span><span class="p">;</span>
<span class="k">print</span> <span class="n">Dumper</span><span class="p">(</span>
    <span class="n">DateTime</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span> <span class="n">zip</span> <span class="nv">@</span><span class="p">{</span> <span class="p">[</span><span class="sx">qw/year month day/</span><span class="p">]</span> <span class="p">},</span>
        <span class="nv">@</span><span class="p">{</span> <span class="p">[</span> <span class="nb">split</span> <span class="sr">/-/</span><span class="p">,</span> <span class="s">&#39;2013-06-21&#39;</span> <span class="p">]</span> <span class="p">}</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">subtract_datetime</span><span class="p">(</span>
        <span class="n">DateTime</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span>
            <span class="n">zip</span> <span class="nv">@</span><span class="p">{</span> <span class="p">[</span><span class="sx">qw/year month day/</span><span class="p">]</span> <span class="p">},</span>
            <span class="nv">@</span><span class="p">{</span> <span class="p">[</span> <span class="nb">split</span> <span class="sr">/-/</span><span class="p">,</span> <span class="s">&#39;2012-05-20&#39;</span> <span class="p">]</span> <span class="p">}</span>
        <span class="p">)</span>
        <span class="p">)</span><span class="o">-&gt;</span><span class="n">deltas</span>
<span class="p">);</span>
</code></pre></div>
<p>缺点是 <code>DateTime::Duration</code> 的 <code>days()</code> 只能返回进位 <code>months()</code> 之后剩余的天数。所以这里只能输出整个 <code>deltas()</code> 来看。</p>
<h2 id="timestamp-">timestamp 时间戳</h2>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="n">POSIX</span> <span class="sx">qw(mktime)</span><span class="p">;</span>
<span class="k">sub </span><span class="nf">trans</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">@str</span> <span class="o">=</span> <span class="nb">split</span> <span class="sr">/-/</span><span class="p">,</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="n">mktime</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">$str</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="nv">$str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nv">$str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1900</span><span class="p">,</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="k">my</span> <span class="nv">$dt1</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="s">&#39;1999-05-21&#39;</span><span class="p">);</span>
<span class="k">my</span> <span class="nv">$dt2</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="s">&#39;2013-06-26&#39;</span><span class="p">);</span>
<span class="k">print</span><span class="p">(</span> <span class="p">(</span> <span class="nv">$dt2</span> <span class="o">-</span> <span class="nv">$dt1</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span> <span class="p">)</span> <span class="p">);</span>
</code></pre></div>
<p>这里就是要注意，<code>mktime</code> 里的 <code>month</code> 是以 0 开始的，<code>year</code> 是从 1900 开始的。</p>
      <a href="/2013/06/24/who-to-calculate-days-between-two-date" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/06/21/remove-auto-deps-from-rpmbuild" title="如何去除 rpmbuild 自动发现的依赖关系" rel="bookmark">如何去除 rpmbuild 自动发现的依赖关系</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-06-21 00:00:00 +0800">21 Jun 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#linux-ref" title="linux" rel="category tag">linux</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>同事在用简单的 SPEC 配置打包 nagios 套件的时候，发现最后生成的 RPM 包附加了很多依赖关系。其中 <code>perl-Net-SNMP</code> 这个包，是服务器默认安装中没有的。这也不是什么大问题。不过这个出现还是蛮奇怪的。值得研究一下。</p>
<p>后来在 <code>/usr/lib/rpm/</code> 目录下发现了一系列脚本，诸如<code>javadeps</code>/<code>perl.req</code>/<code>pythondeps</code>/<code>find-requires</code>/<code>mono-find-requires</code>等等。</p>
<p>这些脚本的作用是，用 <code>file</code> 命令判断文件，如果是二进制的，用ldd判断依赖；如果是脚本，过滤文件中对应的 <code>use</code>/<code>requires</code>/<code>import</code> 语句。这样就可以找出来源代码的内部依赖了。</p>
<p>那么怎么才能跳过这段逻辑呢？</p>
<p>最暴力的办法，这些文件都是 bash 或者 perl 脚本，直接修改。</p>
<p>但是还可以文明一点，像下面这段，添加在 SPEC 文件中：</p>
<div class="highlight"><pre><code class="bash">    %setup
    %prep
    cat <span class="s">&lt;&lt; \EOF &gt; %{name}-req</span>
<span class="s">    #!/bin/sh</span>
<span class="s">    %{__perl_requires} $* |\</span>
<span class="s">    sed -e &#39;/perl(Net::SNMP)/d&#39;</span>
<span class="s">    EOF</span>
    %define __perl_requires %<span class="o">{</span>_builddir<span class="o">}</span>/%<span class="o">{</span>name<span class="o">}</span>-%<span class="o">{</span>version<span class="o">}</span>/%<span class="o">{</span>name<span class="o">}</span>-req
    chmod 755 %<span class="o">{</span>__perl_requires<span class="o">}</span>
</code></pre></div>
<p>这里重定义了一个脚本，原先的定义在 <code>/usr/lib/rpm/macros</code> 中，是：</p>
<div class="highlight"><pre><code class="bash">    <span class="c">#%__find_provides       /usr/lib/rpm/rpmdeps --provides</span>
    <span class="c">#%__find_requires       /usr/lib/rpm/rpmdeps --requires</span>
    %__find_provides        /usr/lib/rpm/find-provides
    %__find_requires        /usr/lib/rpm/find-requires
    <span class="c">#%__perl_provides       /usr/lib/rpm/perldeps.pl --provides</span>
    <span class="c">#%__perl_requires       /usr/lib/rpm/perldeps.pl --requires</span>
    %__perl_provides        /usr/lib/rpm/perl.prov
    %__perl_requires        /usr/lib/rpm/perl.req
    %__python_provides      /usr/lib/rpm/pythondeps.sh --provides
    %__python_requires      /usr/lib/rpm/pythondeps.sh --requires
    %__mono_provides        /usr/lib/rpm/mono-find-provides %<span class="o">{</span>_builddir<span class="o">}</span>/%<span class="o">{</span>?buildsubdir<span class="o">}</span> %<span class="o">{</span>buildroot<span class="o">}</span> %<span class="o">{</span>_libdir<span class="o">}</span>
    %__mono_requires        /usr/lib/rpm/mono-find-requires %<span class="o">{</span>_builddir<span class="o">}</span>/%<span class="o">{</span>?buildsubdir<span class="o">}</span> %<span class="o">{</span>buildroot<span class="o">}</span> %<span class="o">{</span>_libdir<span class="o">}</span>
</code></pre></div>
<p>然后将加入了 <code>sed</code> 命令的新脚本定位为新的 MACROS 变量给 <code>rpmbuild</code> 后续使用。</p>
      <a href="/2013/06/21/remove-auto-deps-from-rpmbuild" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/06/20/rex-task-params-for-dynamic-server-group" title="通过 Rex 命令行参数向动态服务器组发起任务" rel="bookmark">通过 Rex 命令行参数向动态服务器组发起任务</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-06-20 00:00:00 +0800">20 Jun 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>Rex 默认的服务器组定义方式有三种，直接写在 <code>Rexfile</code> 文件中；每行一个写成 IP 列表保存成文件，然后通过 <code>lookup_file</code> 读取；把组名和 IP 写成 <code>.ini</code> 格式文件，通过 <code>groups_file "$name.ini"</code> 一次性获取。</p>
<p>如果服务器信息存在数据库里，那么可以通过 <code>Rex::Commands::DB</code> 来快速读取数据库信息，构建服务器组。不过，如果我们是想从数据库中根据查询条件，动态获取服务器列表完成指定任务的话，就没法提前定义好 <code>group</code> 了。这个时候，怎么办呢？</p>
<p>我们可以利用 <code>task</code> 可以接受命令行参数这个特点，完成这个功能：</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="nn">Rex::Commands::</span><span class="n">DB</span> <span class="p">{</span>
    <span class="n">dsn</span>      <span class="o">=&gt;</span> <span class="s">&quot;dbi:SQLite:dbname=/etc/puppet/webui/node.db&quot;</span><span class="p">,</span>
    <span class="n">user</span>     <span class="o">=&gt;</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
    <span class="n">password</span> <span class="o">=&gt;</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">task</span> <span class="s">&quot;sqlite&quot;</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$param</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$role</span>  <span class="o">=</span> <span class="nv">$param</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">role</span><span class="p">};</span>
    <span class="k">my</span> <span class="nv">$class</span> <span class="o">=</span> <span class="nv">$param</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">class</span><span class="p">};</span>
    <span class="k">my</span> <span class="nv">$todo</span>  <span class="o">=</span> <span class="nv">$param</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">todo</span><span class="p">};</span>
    <span class="nb">grep</span> <span class="p">{</span> <span class="n">run_task</span> <span class="nv">$todo</span><span class="p">,</span> <span class="n">on</span> <span class="o">=&gt;</span> <span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">ip</span><span class="p">}</span> <span class="p">}</span> <span class="n">db</span> <span class="nb">select</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">fields</span> <span class="o">=&gt;</span> <span class="s">&quot;ip&quot;</span><span class="p">,</span>
        <span class="n">from</span>   <span class="o">=&gt;</span> <span class="s">&quot;node_info&quot;</span><span class="p">,</span>
        <span class="n">where</span>  <span class="o">=&gt;</span> <span class="s">&quot;role like &#39;$role\%&#39; and classes like &#39;\%${class}\%&#39;&quot;</span><span class="p">,</span>
    <span class="p">};</span>
<span class="p">};</span>
<span class="n">task</span> <span class="s">&#39;hello&#39;</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
    <span class="n">say</span> <span class="n">run</span> <span class="s">&quot;w&quot;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>然后这样运行命令即可：</p>
<div class="highlight"><pre><code class="bash">rex sqlite --role<span class="o">=</span>cdn --class<span class="o">=</span>nginx --todo<span class="o">=</span>hello
</code></pre></div>
      <a href="/2013/06/20/rex-task-params-for-dynamic-server-group" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/06/19/skyline-algorithms-intro" title="【Etsy 的 Kale 系统】skyline 的过滤算法" rel="bookmark">【Etsy 的 Kale 系统】skyline 的过滤算法</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-06-19 00:00:00 +0800">19 Jun 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>监控大户 Etsy 最近有公布了一个全新的监控分析系统，叫 Kale，博客地址：<a href="http://codeascraft.com/2013/06/11/introducing-kale/">http://codeascraft.com/2013/06/11/introducing-kale/</a>。</p>
<p>上一篇博客介绍了安装部署和数据导入的方法。但是对 <code>skyline</code> 组件的过滤原理没有做研究。今天花了点时间看 wiki 和源码，大概搞清楚了 <code>skyline</code> 的工作方式。很有趣，值得记录一下。</p>
<p>同样作为时间序列存储的 <code>rrdtool</code> 和 <code>graphite</code>，都偏重在预测算法，也就是说根据现有数据推测下一个数据应该是多少；而 <code>skyline</code> 则是根据现有数据统计最新数据是否异常。</p>
<p>目前，<code>skyline</code> 一共提供了 7  个异常检测算法，如果有 5 个以上认为是异常，那么 <code>skyline</code> 就认为这个序列异常了。(当然，这都是可以修改的)</p>
<p>异常检测算法实际写在了 <code>src/analyzer/algorithms.py</code> 里，包括有：</p>
<h3 id="firsthouraverage">first_hour_average</h3>
<p>这是最简单的。先求本周期内最前面的第一个小时的平均值和标准差，然后和最新的三个值的平均值(<code>tail_avg()</code>，这是后面多数算法都通用的做法)做比较。如果 <code>tail_avg</code> 和 第一小时平均值的差距大于 3 倍的标准差，那么认定为异常。</p>
<h3 id="simplestddevfrommovingaverage">simple_stddev_from_moving_average</h3>
<p>把上面算法的范围扩大化，求的是整个周期内全部数据的平均值和标准差。</p>
<h3 id="stddevfrommovingaverage">stddev_from_moving_average</h3>
<p>在上面算法的基础上，采用指数加权移动平均值。对周期内采点数量较少的情况更好一些。</p>
<h3 id="meansubtractioncumulation">mean_subtraction_cumulation</h3>
<p>做法是这样的：</p>
<ol>
  <li>排除最后一个值；</li>
  <li>求剩余序列的平均值；</li>
  <li>全序列减去上面这个平均值；</li>
  <li>求剩余序列的标准差；</li>
  <li>判断全序列最后一个值是否大于 3 倍的标准差</li>
</ol>
<p>在代码中本来还计算了一次序列的指数加权移动平均值，但是算完了却没用，感觉怪怪的。</p>
<h3 id="leastsquares">least_squares</h3>
<p>采用最小二乘法拟近时间序列，然后用实际值减去拟近值得到新序列。然后判断新序列的最后三个值的平均值是否大于 3 倍的新序列标准差。</p>
<p>所谓最小二乘法，简单说就是对一个 [x, y] 序列，会有一对常数 [m, c]，让 <code>Y = mx + c</code> 等式中的 Y 和 y 在全序列上最接近。</p>
<h3 id="histogrambins">histogram_bins</h3>
<p>将整个周期序列的数据按照直方图统计法归入 15 个直方中，然后看最后三个值的平均值属于这 15 个直方的具体哪个。如果这个直方中包含的数据小于 20 个，判断为异常。</p>
<p>从算法中可以知道，如果周期内数据量不够，很容易被判断为异常的。</p>
<h3 id="grubbs">grubbs</h3>
<p>将整个周期序列的数据按照格拉布斯法求异常值。</p>
<p>标准的格拉布斯法是这样的：</p>
<ol>
  <li>从小到大排序；</li>
  <li>求序列的平均值和标准差；</li>
  <li>计算最小值和最大值与平均值的差距，更大的那个为可疑值；</li>
  <li>可疑值减去平均值，再除以标准差，如果大于格拉布斯临界值，那么就是异常值；</li>
  <li>排除异常值，对剩余序列循环做 1-5 步骤。</li>
</ol>
<p>这里只用判断时间序列的最后是否异常，所以直接将最后三个值的平均值作为可疑值判断是否异常即可。</p>
<p><strong>2013 年 07 月 23 日更新</strong></p>
<p>新增了一个异常算法，现在有 8 个了，要通过 6 个才算真异常。</p>
<p>新增的是&rdquo;绝对中值偏差法&rdquo;</p>
<h3 id="medianabsolutedeviation">median_absolute_deviation</h3>
<p>具体实现是：序列的最后一个值，比该序列的绝对中值大 6 倍以上，即判断为异常。</p>
<p>注意这里是中值，不是平均值。</p>
<p><strong>2013 年 08 月 14 日更新</strong></p>
<p>新增一个异常算法，现在有 9 个了。</p>
<p>新增的是&rdquo;柯尔莫诺夫-斯米尔诺夫检验法&rdquo;</p>
<h3 id="kolmogorov-smirnovtest">Kolmogorov-Smirnov_test</h3>
<p>具体实现是：计算序列内最近十分钟的数值的ks测试分布，然后计算序列中最近一个小时前到十分钟前这 50 分钟的数值的ks测试分布；如果两个分布相差较大，即判断为异常。</p>
      <a href="/2013/06/19/skyline-algorithms-intro" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/06/18/etsy-kale-intro" title="【Etsy 的 Kale 系统】简介、部署和应用" rel="bookmark">【Etsy 的 Kale 系统】简介、部署和应用</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-06-18 00:00:00 +0800">18 Jun 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>监控大户 Etsy 最近有公布了一个全新的监控分析系统，叫 Kale，博客地址：<a href="http://codeascraft.com/2013/06/11/introducing-kale/">http://codeascraft.com/2013/06/11/introducing-kale/</a>。</p>
<p>目前的介绍内容比较简单。两个组件 <code>skyline</code> 和 <code>oculus</code> 之间的关系也还没搞清楚。大概上， <code>skyline</code> 是一个 python 程序，接受 <code>cPickle</code> 和 <code>MessagePack</code> 两种数据包，解压后的数据格式类似 <code>graphite</code> 接收的，然后存在 <code>Redis-server</code> 中。在 webapp 上提供一个类似 <code>rrdtool</code> 的功能，显示触发阈值线的趋势图(不触发的不会显示，自动过滤了)。</p>
<p>安装步骤：</p>
<div class="highlight"><pre><code class="bash">    pip install -r requirements.txt
    apt-get install -y numpy scipy
    pip install pandas patsy statsmodels msgpack_python
    cp src/settings.py.example src/settings.py
    mkdir /var/log/skyline
    mkdir /var/run/skyline
    mkdir /var/log/redis
    <span class="c"># 必须用最新版的 redis-server 才能正常存储</span>
    wget http://redis.googlecode.com/files/redis-2.6.13.tar.gz
    tar zxvf redis-2.6.13.tar.gz
    <span class="nb">cd </span>redis-2.6.13
    make
    ./src/redis-server ../bin/redis.conf
    <span class="nb">cd</span> ../src
    <span class="c"># 这里会启动 UDP 2024 端口接受 cpickle 包，2025 端口接受 msgpack 包</span>
    ../bin/horizon.d start
    ../bin/analyzer.d start
    <span class="c"># 这里会启动 TCP 1500 端口接受 web 访问</span>
    ../bin/webapp.d start
    <span class="c"># 测试是否正常</span>
    <span class="nb">cd</span> ../utils
    ./seed_data.py
</code></pre></div>
<p><code>oculus</code> 是一个 rack 应用，需要定时从 <code>skyline</code> 中导入数据到 <code>ElasticSearch</code> 中。同时，<code>oculus</code> 还提供了一个 <code>ElasticSearch</code> 分析器插件，可以在 ES 中完成 <code>FastDTW</code> 和 <code>Euclidian</code> 两种位移算法（用来给不同时间序列的近似度打分）。在rack 页面上，提供搜索框，你可以提交一个 metric 名称——经过测试，目前应该是采用完全匹配的方式搜索——然后展示这个 metric 的图形，以及按照 score 打分排序的近似时间序列。</p>
<ul>
  <li>欧几里德算法原理：根据两点的坐标系计算直线距离；</li>
  <li>动态时间归整原理：将时间序列进行延伸或者缩短，然后再计算。
<a href="http://www.cnblogs.com/kemaswill/archive/2013/04/18/3028610.html">http://www.cnblogs.com/kemaswill/archive/2013/04/18/3028610.html</a></li>
</ul>
<p>安装步骤：</p>
<div class="highlight"><pre><code class="bash">    <span class="c"># 只能用 0.20.5 版，0.90 版目前不支持</span>
    wget https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-0.20.5.tar.gz
    tar zxvf elasticsearch-0.20.5.tar.gz
    mv elasticsearch-0.20.5 /opt/elasticsearch
    <span class="c"># 编译插件</span>
    cp -r resources/elasticsearch-oculus-plugin /opt/elasticsearch/
    <span class="nb">pushd</span> /opt/elasticsearch/elasticsearch-oculus-plugin
    rake build
    cp OculusPlugins.jar /opt/elasticsearch/lib/OculusPlugins.jar
    <span class="c"># 加载分析器和脚本</span>
    cat &gt;&gt;/opt/elasticsearch/config/elasticsearch.yml<span class="s">&lt;&lt;EOF</span>
<span class="s">    script.native:</span>
<span class="s">      oculus_euclidian.type: com.etsy.oculus.tsscorers.EuclidianScriptFactory</span>
<span class="s">      oculus_dtw.type: com.etsy.oculus.tsscorers.DTWScriptFactory</span>
<span class="s">    EOF</span>
    <span class="c"># 启动</span>
    /opt/elasticsearch/bin/elasticsearch
    <span class="nb">popd</span>
<span class="nb">    </span>bundle install
    mkdir /var/run/oculus
    mkdir /var/log/oculus
    <span class="c"># 启动 worker 进程，这是import.rb 和 ES 交流的渠道</span>
    rake resque:start_workers
    <span class="c"># 编辑 config/config.yml，注意里面ES一定要提供两台，哪怕写一个127.0.0.1一个localhost，后面 import 会验证数目</span>
    vi config/config.yml
    <span class="c"># 从 skyline 导入数据</span>
    ./scripts/import.rb
    <span class="nb">echo</span> <span class="s1">&#39;*/2 * * * * ~/oculus/scripts/import.rb &amp;&gt; /var/log/oculus/import.log&#39;</span> &gt;&gt; cron.list
    crontab -u root cron.list
    <span class="c"># 启动web</span>
    thin start
    <span class="c"># 默认用户密码都是admin，需要先点击初始化</span>
    gnome-open localhost:3000/admin
</code></pre></div>
<p><code>oculus</code> 的测试我是做出来了。如图：</p>
<p><img src="/images/uploads/oculus.png" alt="oculus" /></p>
<p>这个数据我是通过 perl 生成的随机数，所以也没什么近似队列了。展示一下脚本，这样说明我们可以通过其他脚本扩展 Kale 系统的用途。</p>
<div class="highlight"><pre><code class="perl">    <span class="c1">#!/usr/bin/env perl</span>
    <span class="k">use</span> <span class="n">strict</span><span class="p">;</span>
    <span class="k">use</span> <span class="n">warnings</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">Data::</span><span class="n">MessagePack</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">AnyEvent::Handle::</span><span class="n">UDP</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$mp</span> <span class="o">=</span> <span class="nn">Data::</span><span class="n">MessagePack</span><span class="o">-&gt;</span><span class="k">new</span><span class="o">-&gt;</span><span class="n">utf8</span><span class="o">-&gt;</span><span class="n">prefer_integer</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$cv</span>   <span class="o">=</span> <span class="n">AnyEvent</span><span class="o">-&gt;</span><span class="n">condvar</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$sock</span> <span class="o">=</span> <span class="nn">AnyEvent::Handle::</span><span class="n">UDP</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">(</span>
        <span class="nb">connect</span>   <span class="o">=&gt;</span> <span class="p">[</span> <span class="s">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="s">&#39;2025&#39;</span> <span class="p">],</span>
        <span class="n">on_recv</span>   <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span> <span class="p">},</span>
        <span class="n">autoflush</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">);</span>
    <span class="k">my</span> <span class="nv">$timer</span> <span class="o">=</span> <span class="n">AnyEvent</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">(</span>
        <span class="n">after</span>    <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">interval</span> <span class="o">=&gt;</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">cb</span>       <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
            <span class="k">print</span> <span class="s">&quot;send...\n&quot;</span><span class="p">;</span>
            <span class="k">my</span> <span class="nv">$data</span> <span class="o">=</span> <span class="p">[</span> <span class="s">&#39;localhost.loadavg&#39;</span><span class="p">,</span> <span class="p">[</span> <span class="nb">time</span><span class="p">(),</span> <span class="nb">rand</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">]</span> <span class="p">];</span>
            <span class="k">my</span> <span class="nv">$packed</span> <span class="o">=</span> <span class="nv">$mp</span><span class="o">-&gt;</span><span class="nb">pack</span><span class="p">(</span><span class="nv">$data</span><span class="p">);</span>
            <span class="nv">$sock</span><span class="o">-&gt;</span><span class="n">push_send</span><span class="p">(</span><span class="s">&quot;$packed&quot;</span><span class="p">);</span>
        <span class="p">},</span>
    <span class="p">);</span>
    <span class="nv">$cv</span><span class="o">-&gt;</span><span class="nb">recv</span><span class="p">;</span>
</code></pre></div>
<p>从源码中，看到还有 <code>ganglia_to_skyline.rb</code> 脚本。目前看，<code>Kale</code> 应该是想着用 <code>skyline</code> 代替 <code>graphite-web</code>，得用 <code>redis</code> 来代替 <code>graphite-whisper</code>，不过我觉得似乎意义不是很大，还不如直接把数据存入 <code>ElasticSearch</code>，形成一套类似 <code>openTSDB</code> 的，但是完全基于 ES 的高扩展分布式方案。</p>
      <a href="/2013/06/18/etsy-kale-intro" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/06/12/translate-85-operational-rules" title="【翻译】运维的85条规则" rel="bookmark">【翻译】运维的85条规则</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-06-12 00:00:00 +0800">12 Jun 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>2007 年，时任虚拟世界游戏公司 Vivaty 运维副总裁的 Jon Prall 在他的个人博客上发表过一篇<a href="http://jprall.typepad.com/blog/2010/10/85-operational-rules.html">《运维的85条规则》</a>。2010 年他跳槽到视频电话公司 Tango 之初，做了两处更新，兹翻译如下：</p>
<ol>
  <li>
    <p>容量第一，优化第二——这条规则在故障发生时生效。在宕机的时候别研究什么优化，先恢复设备。</p>
  </li>
  <li>
    <p>保留所有可以捕获的记录——以 PostgresQL 为例，包括有 WAL 文件，Slony 复制，快照技术，基于硬盘的 DB 版本(快照附带的)</p>
  </li>
  <li>
    <p>不要因为优化引入更多问题。通常我们解决问题时做出来的东西都会转变成之后运维工作的负担。请确认为运维工作开发的那些工具已经完全交付使用。这些东西经常无法正常运行结果要返回开发组重来。更重要的，这种变更请求通常会打破团队原本安排好的工作计划。</p>
  </li>
  <li>
    <p>保持简单，不要让事情变得太复杂，聪明的你一定可以做到的。</p>
  </li>
  <li>
    <p>谨慎使用缓存以保护那些难以水平扩展的资源。当然，如果你可以水平扩展它，那么给他加缓存层就不用考虑太多。一旦用上了缓存层，它的目的应该是提高最终用户的访问性能，而不是增加网站的容量。否则，你不过是给自己加上了一个新的非常不可靠的瓶颈。他们潜在的负面影响可能危及整个系统。事实上缓存层失效带来的，经常是雪崩式的级联故障。</p>
  </li>
  <li>
    <p>不要什么都自己写代码实现，也不要什么都从厂家买——要在适当的时候采用适当的工具。</p>
  </li>
  <li>
    <p>谈判——和真正有实力的厂家谈判的唯一办法就是提前做好功课，准备好一切可行项。这样一旦有必要，你可以从你的首选厂家里选择离开。不用搞虚张声势那套了。</p>
  </li>
  <li>
    <p>永远要准备好 N+1 的服务器。如果 N 等于 1，那么不管什么情况都不要动用这个 +1 的设备，专职等待 N 失效后的接管。当你使用冗余的服务器来均衡负载的时候，就只有49%或者更少的容量可管理了。通常我们会获得 N+2 的机会——一定要好好利用起来。</p>
  </li>
  <li>
    <p>数据丢失是任何一家公司都不敢冒的风险——这是一条普遍真理。丢失数据造成的损耗远远超过用于保证数据不丢失的花费。</p>
  </li>
  <li>
    <p>随时随地的并行化——这是一种很重要的思维方式。比如，如果 MogileFS 设置为位置感知的方式并且需要实时复制，那么每个 MogileFS 服务器都必须可以复制自己的数据到负载均衡器指定的另一端。只要有可能，尽量实现这种多对多的方式。</p>
  </li>
  <li>
    <p>RTFM——就在今天我还要阅读一对 RAID 卡的说明书来比较他们微妙的差异。魔鬼在于细节。像做家庭作业一样读文档吧！</p>
  </li>
  <li>
    <p>了解每一层上的瓶颈以及如何发现瓶颈。必须要知道你是在磁盘，内存，还是 CPU 上受限制了，搞清楚这个其实挺简单的。</p>
  </li>
  <li>
    <p>要有一个固定的容量管理流程——而且是主动式的，不是被动式的。要知道系统的弱点在哪里，让实际负荷曲线跑到容量曲线之上是极度危险的。</p>
  </li>
  <li>
    <p>不促成失败，也不惧怕改变。</p>
  </li>
  <li>
    <p>不要吸进你自己的废气。别以为你现在的工作结果会变成未来你如何工作的动力。</p>
  </li>
  <li>
    <p>运维人员要写的代码是运维工具，而不是应用软件。</p>
  </li>
  <li>
    <p>不要低估运维团队中项目经理、技术作者、金融分析师的价值。这些人通常比你给的工资值钱多了。</p>
  </li>
  <li>
    <p>监控所有的东西——报警只用在异动的时候，其他的都记录下来供趋势分析。</p>
  </li>
  <li>
    <p>要有一个固定的流程来查看每个地方的趋势数据。</p>
  </li>
  <li>
    <p>不要让监控太吵闹，那样很快就变得没作用了。</p>
  </li>
  <li>
    <p>确保你的监控系统简单易用到公司里每个人都能上手。监控数据指标转换成为业务指标、市场指标和销售指标等等的频率可能高的让你吃惊。</p>
  </li>
  <li>
    <p>只在可以做出相应改变的地方做总结，否则就是白白浪费时间。</p>
  </li>
  <li>
    <p>总结要公开，同时附上事件相关的数据。这样大家可以很容易的找到总结的关键点并且跳转到对应数据。</p>
  </li>
  <li>
    <p>要让技术的每一个点都有人员在负责。</p>
  </li>
  <li>
    <p>同时为这些负责人准备好备份人员。</p>
  </li>
  <li>
    <p>不断发招聘——哪怕没有名额了。</p>
  </li>
  <li>
    <p>做自己最严厉的批评者。不管自己或者自认多聪明，总有可以提高的地方。</p>
  </li>
  <li>
    <p>多往外看，拿自身的水平和尽量多的公司的职位需求做对比。</p>
  </li>
  <li>
    <p>每年参加一个技术交流大会。如果一年有好几个，那选最好的那一个去就够了。</p>
  </li>
  <li>
    <p>买你需要的而不是你想要的。绝不摘下你公司的帽子换上那个写着“对我来说什么最简单最安全”的。</p>
  </li>
  <li>
    <p>只做对业务最好的事情，哪怕这件事是让你滚蛋……</p>
  </li>
  <li>
    <p>问责制度正规化——记录承诺，事后追究没有完成者。</p>
  </li>
  <li>
    <p>不允许重复失败。听起来有些过于苛责了。不过要区分不可挽回的失误和失误的差别。</p>
  </li>
  <li>
    <p>无情——因为对手都是无情的。</p>
  </li>
  <li>
    <p>工作是你要在完成的时候亲自署名的东西。署名同时也意味着完成任务。</p>
  </li>
  <li>
    <p>保持对外的可用联络。</p>
  </li>
  <li>
    <p>创业的伙伴——告诉他们你的专长和能力范围。你会得到免费的产品回报，有时候是生活中的。</p>
  </li>
  <li>
    <p>容量是一个业务/产品问题。也就是说每个页面、上传或者登录等请求的网络消耗，都必须是可见的，以协助完成正确的业务/产品决策。</p>
  </li>
  <li>
    <p>一定要打败预算！运维团队总是预算金额最大的挥霍者。公司的收入目标经常达不到，运维团队应该有很多办法来推迟自己的花费。</p>
  </li>
  <li>
    <p>过去的经验不一定适用于现在乃至将来——多尝试没错，而且要有恰当的测试工具来做这件事。</p>
  </li>
  <li>
    <p>文档——所有事情都应该好好记录成文档。避免团队的新成员绕着圈的找遍全团队逐一了解工作内容。</p>
  </li>
  <li>
    <p>画一张超大尺寸的网络拓扑图，描绘你的数据中心。</p>
  </li>
  <li>
    <p>为你的每个产品都画一个逻辑流程图。</p>
  </li>
  <li>
    <p>维基——让大家可以很容易的发布“如何修复这个问题”的文档并且容易查找。这是技术作者发挥作用的地方，不过维基可以让哪怕非正式的文档或者增增改改的小段落也更好查看。</p>
  </li>
  <li>
    <p>确保团队的每个成员，对，是每一个，都是可以替换的。</p>
  </li>
  <li>
    <p>有些人在家里干活比在公司的时候还好，但有些人却不行。</p>
  </li>
  <li>
    <p>订单打包签订——把硬件需求打包成大订单后再去咨询最大的折扣合同，记得订单里要包括所有一切，比如备件包，租赁条件等等。</p>
  </li>
  <li>
    <p>和供应商保持长期联系，哪怕你换到下一份工作的时候也能联系上他们。</p>
  </li>
  <li>
    <p>给运维团队每个人都配上一切他们可以远程操控的东西——掌上电脑， 3G 网卡，24 寸 LCD 屏幕……你为有才华的人付出得到的回报，远超过在远程雇佣的现场工程师。记住，运维工程师都是电力狂人，他们知道并且能充分利用屏幕上每个像素。</p>
  </li>
  <li>
    <p>除非 Mac 可以运行 office 2007 和 outlook，否则团队里总需要几个 windows。这事很破坏团队的会议安排，联系人管理和邮件列表等等。</p>
  </li>
  <li>
    <p>要有一个简化的采购流程——前提是你要了解自己的预算，并且能够管理好。我们可以从财务报告中得到实际。技术驱动的报告和财务驱动的报告之间通常存在差距。一个好的运维经理可以创建一些模型，将这些差别计入销售总成本中。而理解这些的 CFO 才可以帮助推动业务决策。</p>
  </li>
  <li>
    <p>周会一定要持续举行，对上周的事件逐一总结和问责。</p>
  </li>
  <li>
    <p>创建一个独立的升级系统，来管理那些对运维产生负面影响的代码开发工程。这个想法的来源是：一个同时涉及运维和开发的问题，在运维或者开发的跟踪系统里大多被湮没无视，最后没人理睬，所以给这些问题单独创建一个跟踪系统反而更加简单清楚。</p>
  </li>
  <li>
    <p>产品开发从设计开始的每个阶段都要和运维技术相结合。这样，扩展性，监控和可靠性都融入到产品里。这样同时也可以确保运维负责的硬件采购、监控系统按时到位，运行手册即时更新，最后产品按照预计时间上线运行并且都符合运维标准。</p>
  </li>
  <li>
    <p>像一个真正的公司一样运作——萨班斯法案，WebTrust 安全审计认证，SAS 70 审计标准，Visa 组织和银行等等。如果你真的成功了，这些都是你不得不打交道的。早点开始这些准备其实很简单，不需要太多的知识。不过就是开发一个工单/任务跟踪工具，然后好好使用。把变更控制和管理放进同样的系统里，好好使用。其他信息也放进来。系统就可以帮助我们找出像“上周变更了什么”这类信息。</p>
  </li>
  <li>
    <p>给冗余留空间。一开始或许很难，但是一个没有真正的扩展性和可靠性的系统，才会真正耽误你获得成功的时间。</p>
  </li>
  <li>
    <p>买个 Oracle 标准版(或者微软 SQL Server 标准版)是值得的。如果你可以限制住自己不超过标准版的需求，那就绝对值得买，哪怕你刚刚开始创业。</p>
  </li>
  <li>
    <p>Postgres 和 MySQL 的免费不错。如果你不是特别在意事务完整性，MySQL 其实挺好的。</p>
  </li>
  <li>
    <p>容量设计应该按照每日峰值再上抛 20% 到 30% 的冗余。除非你是个 vmotion(译注：VMWare 的热迁移技术)达人。</p>
  </li>
  <li>
    <p>尽量多读一些贸易杂志。它们通常是免费的，只要你填写一些调查问卷就好了。新闻的价值是巨大的。对了，记得让他们投递到你家里，工作的时候读杂志的机会趋近于零。</p>
  </li>
  <li>
    <p>注意安全。开发人员不应该有生产线的权限，而应该去做代码复核。这是和运维之间的职责分离。然后运维中应该有人控制设置其他运维人员权限的权限。创建一个员工手册，警告大家违反安全条例会有很严重的后果。从一开始就要记住从物理的、逻辑的、功能的各个方面来保护客户的数据安全和隐私。万一有客户要和你对簿公堂，你回忆起来发现自己只是靠勇气和勤奋来保护客户数据，这感觉可不怎么好。</p>
  </li>
  <li>
    <p>控制好访问入口。首先要保证大家可以正常完成工作；其次要确保你知道他们是从哪里进来的。快去实现双因素身份验证方法吧。</p>
  </li>
  <li>
    <p>对于人们访问生产环境必经之路的堡垒机和网关，键盘记录是至关重要的。对于 Windows 可能稍微有点难度，不过有些网关可以提供自动截屏功能。</p>
  </li>
  <li>
    <p>确保有多种办法登录生产环境。不要期望公司的 VPN 在网络中断的时候还能起作用。直接把 VPN 架设在生产环境里。</p>
  </li>
  <li>
    <p>使用 LDAP 做认证，哪怕你只有 10 台机器，通过复制 passwd 和 shadow 文件的方式来管理，你也要 LDAP 认证。</p>
  </li>
  <li>
    <p>不要低估在 UNIX 环境中一台 Windows Server 2008 设备是多么有用。如果只是因为不懂 Windows，那么去学，而不是贬低它。</p>
  </li>
  <li>
    <p>不要用那些无效的无线方案浪费大家的时间。公司里所有人都在移动，沙发上，会议室里，门口，到处都要上网。千万维护好你的无线路由。</p>
  </li>
  <li>
    <p>总有些人把额外的精力和时间都投入到工作上——直接通过他们的请假单好了。而另一些人恰恰相反只把注意力放在怎么通过自己的请假单。在个人时间安排上，运维人员总是做出巨大的牺牲，他们随时准备凌晨3点爬起床快速响应排障需求。</p>
  </li>
  <li>
    <p>通过集中式的 RDBMS 管理你所有的设备资产。然后复制资产，人员，网络，合同等所有数据到异地。没错，要的是一个在线的实时可用的复制，而不是每天晚上备份到磁带。</p>
  </li>
  <li>
    <p>自动使用多进程以确认安全，包括操作系统或者产品的上线，文件的推送，日志的分析等。</p>
  </li>
  <li>
    <p>自动化操作必须和运维的 RDBMS 数据相关联。</p>
  </li>
  <li>
    <p>设备通常有三种状态——离线，服务中，预备。预备状态就是说正在通过 cfengine、rsync 或者其他你在使用的工具完成配置。服务中就是已经运行着流量了。同时还需要一个状态，这个状态下的设备可以在不提供生产服务的情况下收集或者测试数据。</p>
  </li>
  <li>
    <p>尊重日志数据。在设备下线或者重建之前，一定要先导出日志。</p>
  </li>
  <li>
    <p>如果业务飞速发展让你没有太多时间来做优化，那就尽力锁定一切——进程还能工作，就不要改变它，直到后来有了绝对必要的理由。总之，锁定默认值，等待成长到必要时再审视。</p>
  </li>
  <li>
    <p>你永远无法避免运维工程师在你基础设施最关键的地方犯点啥错——比如在哪台机器上不小心执行 <code>rm -rf /</code> 命令。</p>
  </li>
  <li>
    <p>为团队保持好玩和有趣的气氛——如果他们不再享受他们的工作，他们就会找别的事情来消遣。要让团队有主人翁意识，运维不是哪个经理的个人任务。</p>
  </li>
  <li>
    <p>提供 99.999% 可用性的真正价值在于让我们有能力保持灵活。这意味着当你需要的时候可以充分利用系统冗余。物理变更、设备迁移、代码修改和回退等等都游刃有余。这个对于公司本身价值巨大，甚至比对客户还大。</p>
  </li>
  <li>
    <p>如果你能做到 99.999%，那就给客户一个 100% 的SLA承诺。</p>
  </li>
  <li>
    <p>不要湮没软件热更新的能力。应该被湮没的是你自己回滚或者转移到旧版本代码的能力。压根就不应该“处理”这种徒劳的失败转移。当事情变得不如人意的时候，你更应该做的是找个大玩意儿来挡住你的肥屁股。CYA（译注：Cover Your Ass，就是前面说的盖屁股） = 保持敏捷 = 成功的公司。</p>
  </li>
  <li>
    <p>记住你为客户构建产品的思路里每一步的原因和目的——不管你部署给最终用户的是什么，把这些放在最先考虑，即你所有（基础设施、流程和人员）的设计都是为了提供最好的服务和产品。</p>
  </li>
  <li>
    <p>第一次就要成功。很少有机会让你回去重新开始的。重做是对公司资源的巨大浪费。</p>
  </li>
  <li>
    <p>多联系业内的合作伙伴、盟友和类似的企业，看看他们的运维是怎么做的。很可能他们碰到了跟你一样的挑战，而解决的更为巧妙。不要害怕分享自己的经验和处理过程，因为别人也会回馈的。</p>
  </li>
  <li>
    <p>招人就要招那些足以让自己担心会被挤掉目前工作的，招那些你欣赏和可以学习的榜样，招那些你愿意和他一起工作的。这感觉甚至超过你招聘一个工作考评为A的员工。</p>
  </li>
  <li>
    <p>IT 和运维是完全不同的两个概念。一个不错的运维经理应该可以管理好企业 IT，但是一个传统的 IT 工程师很难有能力处理互联网运维任务。</p>
  </li>
  <li>
    <p>当你开始一份新工作或者在每年的起始，都应该去争取预算。这不是说滚着那个滋滋响的轮子往前走(应该是指循规蹈矩照本宣科)，而是要一个基于历史数据做出的优秀的文案。如果你正在评估一份新工作，请确认你完完全全的知道预算以及预算的来源。同时，还应该有的是改善这份预算的权利。</p>
  </li>
</ol>
      <a href="/2013/06/12/translate-85-operational-rules" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/05/28/compare-dsl-of-puppet-with-rex" title="puppet和rex的常用资源写法类比" rel="bookmark">puppet和rex的常用资源写法类比</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-05-28 00:00:00 +0800">28 May 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>首先要申明，rex 和 puppet 本质上是不同的，puppet 追求的是状态，rex 追求的是操作。puppet 用户经常关心的是 agent 运行了没，而 rex 用户关心的是怎么写 Rexfile 能让中控运行 rex 时的命令参数更简洁漂亮(个人感受==!)。所以哪怕在本文中列举的这些资源写法很类似，也请读者们注意：rex 的资源关键词命名，都是带有动作性的，比如 <code>create</code>，<code>add</code>，<code>install</code>，<code>upload</code>，<code>download</code>，<code>sync</code> 等等。甚至精确的说，rex 里这些不是资源(<code>Puppet::Types::***</code>)，他们是 <code>Rex::Commands::***</code>。</p>
<p>因为 rex 基于并发 ssh 连接，所以它有一些操作是 puppet 所没有的，比如 <code>tail</code>，<code>file_append</code>，<code>fdisk</code>，<code>sysctl</code> 和 <code>iptables</code> 等等，这里暂时不列举。总的来说，本文目的是总结类似的部分，而不是不同的用法……</p>
<h1 id="cron-">Cron 资源</h1>
<h3 id="puppet-">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="n">cron</span> <span class="p">{</span> <span class="s1">&#39;check_starttime&#39;</span><span class="p">:</span>
        <span class="k">ensure</span>  <span class="o">=&gt;</span> <span class="n">present</span><span class="p">,</span>
        <span class="n">minute</span>  <span class="o">=&gt;</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">hour</span>    <span class="o">=&gt;</span> <span class="s1">&#39;*/2&#39;</span><span class="p">,</span>
        <span class="n">user</span>    <span class="o">=&gt;</span> <span class="s1">&#39;root&#39;</span><span class="p">,</span>
        <span class="n">command</span> <span class="o">=&gt;</span> <span class="s1">&#39;sh /usr/local/bin/check_start_time.sh&#39;</span><span class="p">,</span>
        <span class="nb">require</span> <span class="o">=&gt;</span> <span class="no">File</span><span class="o">[</span><span class="s1">&#39;/usr/local/bin/check_start_time.sh&#39;</span><span class="o">]</span><span class="p">,</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex-">rex 写法</h3>
<div class="highlight"><pre><code class="perl">    <span class="n">cron</span> <span class="n">add</span> <span class="o">=&gt;</span> <span class="s">&quot;root&quot;</span><span class="p">,</span> <span class="p">{</span>
        <span class="n">minute</span>       <span class="o">=&gt;</span> <span class="s">&#39;5&#39;</span><span class="p">,</span>
        <span class="n">hour</span>         <span class="o">=&gt;</span> <span class="s">&#39;*&#39;</span><span class="p">,</span>
        <span class="n">day_of_month</span> <span class="o">=&gt;</span> <span class="s">&#39;*&#39;</span><span class="p">,</span>
        <span class="n">month</span>        <span class="o">=&gt;</span> <span class="s">&#39;*&#39;</span><span class="p">,</span>
        <span class="n">day_of_week</span>  <span class="o">=&gt;</span> <span class="s">&#39;*&#39;</span><span class="p">,</span>
        <span class="n">command</span>      <span class="o">=&gt;</span> <span class="s">&#39;/path/to/your/cronjob&#39;</span><span class="p">,</span>
    <span class="p">};</span>
</code></pre></div>
<h1 id="file-">File 资源</h1>
<h3 id="puppet--1">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="n">file</span> <span class="p">{</span> <span class="s1">&#39;/etc/squid/squid.conf&#39;</span><span class="p">:</span>
        <span class="k">ensure</span>    <span class="o">=&gt;</span> <span class="n">file</span><span class="p">,</span>
        <span class="n">mode</span>      <span class="o">=&gt;</span> <span class="s1">&#39;0755&#39;</span><span class="p">,</span>
        <span class="n">content</span>   <span class="o">=&gt;</span> <span class="n">template</span><span class="p">(</span><span class="s1">&#39;squid/squid.conf.erb&#39;</span><span class="p">),</span>
        <span class="nb">require</span>   <span class="o">=&gt;</span> <span class="no">Package</span><span class="o">[</span><span class="s1">&#39;squid&#39;</span><span class="o">]</span><span class="p">,</span>
        <span class="n">subscribe</span> <span class="o">=&gt;</span> <span class="no">Service</span><span class="o">[</span><span class="s1">&#39;squid&#39;</span><span class="o">]</span><span class="p">,</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex--1">rex 写法</h3>
<div class="highlight"><pre><code class="perl">    <span class="n">file</span> <span class="s">&quot;/etc/squid/squid.conf&quot;</span><span class="p">,</span>
        <span class="n">content</span>   <span class="o">=&gt;</span> <span class="n">template</span><span class="p">(</span><span class="s">&quot;templates/squid.tpl&quot;</span><span class="p">,</span> <span class="n">vars</span> <span class="o">=&gt;</span> <span class="o">\</span><span class="nv">%var</span> <span class="p">),</span>
        <span class="n">owner</span>     <span class="o">=&gt;</span> <span class="s">&quot;root&quot;</span><span class="p">,</span>
        <span class="n">group</span>     <span class="o">=&gt;</span> <span class="s">&quot;root&quot;</span><span class="p">,</span>
        <span class="n">mode</span>      <span class="o">=&gt;</span> <span class="mi">700</span><span class="p">,</span>
        <span class="n">needs</span>     <span class="o">=&gt;</span> <span class="n">SquidPkgTask</span><span class="p">,</span>
        <span class="n">on_change</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span> <span class="n">service</span> <span class="n">squid</span> <span class="o">=&gt;</span> <span class="s">&#39;restart&#39;</span> <span class="p">};</span>
</code></pre></div>
<p>这里的 <code>on_change</code> 是 File 资源独有的。</p>
<p><strong>通用资源方面，rex 中在同一个 task 内，是按照书写顺序执行；在 task 之间，通过 <code>needs</code> 可以定义依赖。</strong></p>
<p>另外 rex 还有 <code>before</code>，<code>after</code>，<code>around</code> 三个关键字作用于 task 上。不过这三个是在 rex 控制端执行，不是在远端主机上执行。</p>
<p>注意这里，这个 file 看起来没有使用操作性的动词，但其实他是下面这个写法的简写而已：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">install</span> <span class="n">file</span>  <span class="o">=&gt;</span> <span class="s">&#39;templates/etc/hosts.tpl&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="n">source</span>    <span class="o">=&gt;</span> <span class="s">&quot;/etc/hosts&quot;</span><span class="p">,</span>
        <span class="n">owner</span>     <span class="o">=&gt;</span> <span class="s">&quot;root&quot;</span><span class="p">,</span>
        <span class="n">group</span>     <span class="o">=&gt;</span> <span class="s">&quot;root&quot;</span><span class="p">,</span>
        <span class="n">mode</span>      <span class="o">=&gt;</span> <span class="mi">700</span><span class="p">,</span>
        <span class="n">on_change</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span> <span class="n">say</span> <span class="s">&quot;Something was changed.&quot;</span> <span class="p">},</span>
        <span class="n">template</span>  <span class="o">=&gt;</span> <span class="p">{</span>
                        <span class="n">greeting</span> <span class="o">=&gt;</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span>
                        <span class="n">name</span>     <span class="o">=&gt;</span> <span class="s">&quot;Ben&quot;</span><span class="p">,</span>
                     <span class="p">},</span>
    <span class="p">};</span>
</code></pre></div>
<p>另外，还有一个通过 SFTP 接口上传的写法：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">upload</span> <span class="s">&quot;hosts&quot;</span> <span class="o">=&gt;</span> <span class="s">&quot;/etc/&quot;</span><span class="p">;</span>
</code></pre></div>
<h1 id="package-">Package 资源</h1>
<h3 id="puppet--2">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="n">package</span> <span class="p">{</span> <span class="s1">&#39;ganglia-gmond-modules-python-plugin&#39;</span><span class="p">:</span>
        <span class="k">ensure</span>  <span class="o">=&gt;</span> <span class="n">installed</span><span class="p">,</span>
        <span class="nb">require</span> <span class="o">=&gt;</span> <span class="no">Class</span><span class="o">[</span><span class="s1">&#39;repos&#39;</span><span class="o">]</span><span class="p">,</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex--2">rex 写法</h3>
<div class="highlight"><pre><code class="perl">    <span class="n">repository</span> <span class="n">add</span> <span class="o">=&gt;</span> <span class="n">myrepo</span><span class="p">,</span>
        <span class="n">url</span> <span class="o">=&gt;</span> <span class="s">&#39;http://rex.linux-files.org/CentOS/$releasever/rex/$basearch/&#39;</span><span class="p">;</span>
    <span class="n">update_package_db</span><span class="p">;</span>
    <span class="n">install</span> <span class="nb">package</span> <span class="o">=&gt;</span> <span class="s">&#39;vim&#39;</span><span class="p">;</span>
</code></pre></div>
<h1 id="class-">Class 定义</h1>
<h3 id="puppet--3">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="k">class</span> <span class="n">squid</span> <span class="p">{</span>
        <span class="kp">include</span> <span class="ss">squid</span><span class="p">:</span><span class="ss">:install</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex--3">rex 写法</h3>
<p>rex 执行的 Rexfile 其实就是 perl 的模块文件，所以写法就是标准的 perl 写法。</p>
<div class="highlight"><pre><code class="perl">    <span class="nb">package</span> <span class="n">Squid</span> <span class="p">{</span>
        <span class="nb">require</span> <span class="nn">Squid::</span><span class="n">Install</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>呼呼，新版本的 Perl 中可以用 <code>{}</code> 来包裹 package 定义的内容，看起来是不是更像一些？不过 CentOS6 的 5.10 版还不支持，所以通用起见，还是这样写吧：</p>
<div class="highlight"><pre><code class="perl">    <span class="nb">package</span> <span class="n">Squid</span><span class="p">;</span>
    <span class="nb">require</span> <span class="nn">Squid::</span><span class="n">Install</span><span class="p">;</span>
    <span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<h1 id="directory-">Directory 资源</h1>
<h3 id="puppet--4">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="n">file</span> <span class="p">{</span> <span class="s1">&#39;murder-client&#39;</span><span class="p">:</span>
        <span class="k">ensure</span>  <span class="o">=&gt;</span> <span class="s1">&#39;directory&#39;</span><span class="p">,</span>
        <span class="n">path</span>    <span class="o">=&gt;</span> <span class="s1">&#39;/usr/local/murder&#39;</span><span class="p">,</span>
        <span class="n">recurse</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
        <span class="n">purge</span>   <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
        <span class="n">source</span>  <span class="o">=&gt;</span> <span class="s1">&#39;puppet:///modules/murder/dist&#39;</span><span class="p">,</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex--4">rex 写法</h3>
<p>rex 中采用 rsync 来完成目录文件的同步：</p>
<div class="highlight"><pre><code class="perl">    <span class="nb">mkdir</span><span class="p">(</span><span class="s">&#39;/usr/local/murder&#39;</span><span class="p">);</span>
    <span class="n">sync</span> <span class="s">&#39;dist/*&#39;</span> <span class="o">=&gt;</span> <span class="s">&#39;/usr/local/murder&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="n">exclude</span>    <span class="o">=&gt;</span> <span class="s">&quot;*.sw*&quot;</span><span class="p">,</span>
        <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="s">&#39;--backup --delete&#39;</span><span class="p">,</span>
    <span class="p">};</span>
</code></pre></div>
<h1 id="shell-">Shell 资源</h1>
<h3 id="puppet--5">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="nb">exec</span> <span class="p">{</span><span class="s1">&#39;init-reload&#39;</span><span class="p">:</span>
        <span class="n">command</span>     <span class="o">=&gt;</span> <span class="s1">&#39;/sbin/initctl reload-configuration &amp;&amp; /sbin/initctl start svscan&#39;</span><span class="p">,</span>
        <span class="n">subscribe</span>   <span class="o">=&gt;</span> <span class="no">File</span><span class="o">[</span><span class="s1">&#39;/etc/init/svscan.conf&#39;</span><span class="o">]</span><span class="p">,</span>
        <span class="n">refreshonly</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex--5">rex 写法</h3>
<div class="highlight"><pre><code class="perl">    <span class="n">run</span> <span class="s">&quot;cmd&quot;</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$out</span><span class="p">,</span> <span class="nv">$err</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="p">};</span>
</code></pre></div>
<p>这个回调函数可以不要，那么 <code>run</code> 命令返回输出到变量。这种用法在单行命令中最常用，比如这样：</p>
<div class="highlight"><pre><code class="bash">    rex -H <span class="s1">&#39;192.168.0.[10..30]&#39;</span> -e <span class="s1">&#39;say run &quot;df -h&quot;&#39;</span>
</code></pre></div>
<h1 id="usergroup-">User/Group 资源</h1>
<h3 id="puppet--6">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="n">group</span> <span class="p">{</span><span class="s1">&#39;puppet&#39;</span><span class="p">:</span>
        <span class="k">ensure</span> <span class="o">=&gt;</span> <span class="n">present</span><span class="p">,</span>
        <span class="n">gid</span>    <span class="o">=&gt;</span> <span class="mi">501</span><span class="p">,</span>
        <span class="nb">system</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">user</span> <span class="p">{</span><span class="s1">&#39;puppet&#39;</span><span class="p">:</span>
        <span class="k">ensure</span> <span class="o">=&gt;</span> <span class="n">present</span><span class="p">,</span>
        <span class="n">uid</span>    <span class="o">=&gt;</span> <span class="mi">501</span><span class="p">,</span>
        <span class="nb">system</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
        <span class="n">groups</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;puppet&#39;</span><span class="p">,</span> <span class="s1">&#39;...&#39;</span><span class="o">]</span><span class="p">,</span>
        <span class="n">expiry</span> <span class="o">=&gt;</span> <span class="s1">&#39;2013-05-30&#39;</span><span class="p">,</span>
        <span class="n">managehome</span> <span class="o">=&gt;</span> <span class="kp">false</span><span class="p">,</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex--6">rex 写法</h3>
<div class="highlight"><pre><code class="perl">    <span class="n">create_group</span> <span class="s">&#39;puppet&#39;</span><span class="p">,</span> <span class="p">{</span>
        <span class="n">gid</span>    <span class="o">=&gt;</span> <span class="mi">501</span><span class="p">,</span>
        <span class="nb">system</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">create_user</span> <span class="s">&#39;puppet&#39;</span><span class="p">,</span>
       <span class="n">uid</span> <span class="o">=&gt;</span> <span class="mi">501</span><span class="p">,</span>
       <span class="n">home</span> <span class="o">=&gt;</span> <span class="s">&#39;/etc/puppet&#39;</span><span class="p">,</span>
       <span class="n">expire</span> <span class="o">=&gt;</span> <span class="s">&#39;2013-05-30&#39;</span><span class="p">,</span>
       <span class="n">groups</span>  <span class="o">=&gt;</span> <span class="p">[</span><span class="s">&#39;puppet&#39;</span><span class="p">,</span> <span class="s">&#39;...&#39;</span><span class="p">],</span>
       <span class="n">password</span> <span class="o">=&gt;</span> <span class="s">&#39;blahblah&#39;</span><span class="p">,</span>
       <span class="nb">system</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
       <span class="n">no_create_home</span> <span class="o">=&gt;</span> <span class="n">TRUE</span><span class="p">,</span>
       <span class="n">ssh_key</span> <span class="o">=&gt;</span> <span class="s">&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQChUw...&quot;</span><span class="p">;</span>
</code></pre></div>
<h1 id="service-">Service 资源</h1>
<h3 id="puppet--7">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="n">service</span> <span class="p">{</span><span class="s1">&#39;nginx&#39;</span><span class="p">:</span>
        <span class="k">ensure</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
        <span class="n">enable</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex--7">rex 写法</h3>
<div class="highlight"><pre><code class="perl">    <span class="n">service</span> <span class="n">apache2</span> <span class="o">=&gt;</span> <span class="n">ensure</span> <span class="o">=&gt;</span> <span class="s">&quot;started&quot;</span><span class="p">;</span>
    <span class="n">service</span> <span class="n">apache2</span> <span class="o">=&gt;</span> <span class="s">&quot;start&quot;</span><span class="p">;</span>
</code></pre></div>
<p>再次可见，rex 认为 <code>service</code> 命令和 <code>chkconfig</code>/<code>update-rc.d</code> 命令是两件事情，所以要分开两个写法。</p>
<h1 id="mount-">Mount 资源</h1>
<h3 id="puppet--8">puppet 写法</h3>
<div class="highlight"><pre><code class="ruby">    <span class="n">mount</span> <span class="p">{</span><span class="s1">&#39;/mnt/sda6&#39;</span><span class="p">:</span>
        <span class="k">ensure</span>  <span class="o">=&gt;</span> <span class="n">present</span><span class="p">;</span>
        <span class="n">device</span>  <span class="o">=&gt;</span> <span class="s1">&#39;/dev/sda6&#39;</span><span class="p">,</span>
        <span class="n">fstype</span>  <span class="o">=&gt;</span> <span class="s1">&#39;ext3&#39;</span><span class="p">,</span>
        <span class="n">options</span> <span class="o">=&gt;</span> <span class="s1">&#39;noatime,async&#39;</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="rex--8">rex 写法</h3>
<div class="highlight"><pre><code class="perl">    <span class="n">mount</span> <span class="s">&quot;/dev/sda6&quot;</span><span class="p">,</span> <span class="s">&quot;/mnt/sda6&quot;</span><span class="p">,</span>
       <span class="n">fs</span> <span class="o">=&gt;</span> <span class="s">&quot;ext3&quot;</span><span class="p">,</span>
       <span class="n">options</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="sx">qw/noatime async/</span><span class="p">];</span>
</code></pre></div>
<h1 id="facts-">Facts 变量和模板</h1>
<h3 id="puppet--9">puppet 写法</h3>
<p>在 puppet 中，Facts 变量有两种用法，一个是 <code>*.pp</code> 里的写法：</p>
<div class="highlight"><pre><code class="ruby">    <span class="vg">$:</span><span class="ss">:lsbdistid</span>
</code></pre></div>
<p>另一种是在 <code>*.erb</code> 里的写法，值得注意的是变量的作用域：</p>
<div class="highlight"><pre><code class="ruby">    <span class="o">&lt;</span><span class="sx">%= scope::lookupvar(&#39;ipaddress&#39;) %&gt;</span>
<span class="sx">    &lt;%=</span> <span class="ss">scope</span><span class="p">:</span><span class="ss">:lookupvar</span><span class="p">(</span><span class="s1">&#39;nginx::name&#39;</span><span class="p">)</span> <span class="o">%&gt;</span>
</code></pre></div>
<h3 id="rex--9">rex 写法</h3>
<p>在 rex 中，远端主机的系统状态有多种获取方式，比如：</p>
<div class="highlight"><pre><code class="perl">    <span class="c1"># 全部，这些变量默认会传递给 template</span>
    <span class="k">my</span> <span class="nv">$sysinfo</span> <span class="o">=</span> <span class="nn">Rex::Helper::System::</span><span class="n">info</span><span class="p">;</span>
    <span class="c1"># 实际就是从上面info里取具体的变量</span>
    <span class="k">my</span> <span class="nv">$lsd</span> <span class="o">=</span> <span class="n">get_operating_system</span><span class="p">;</span>
    <span class="c1"># 这个慎用，会死人的</span>
    <span class="k">my</span> <span class="nv">@ns</span> <span class="o">=</span> <span class="n">netstat</span><span class="p">;</span>
</code></pre></div>
<p>也可以使用 <code>set</code> 指令，这种变量和使用 perl 标准 <code>my $name</code> 方式不同的是它可以直接在模板中读取：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">set</span> <span class="n">name</span> <span class="o">=&gt;</span> <span class="s">&#39;CDN&#39;</span><span class="p">;</span>
</code></pre></div>
<p>至于 rex 的模板，它默认没有使用 CPAN 上任何一种现成的模块，而是自己实现了一个，写法如下：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">template</span><span class="p">(</span><span class="s">&#39;your.tpl&#39;</span><span class="p">,</span> <span class="n">yourvars</span> <span class="o">=&gt;</span> <span class="o">\</span><span class="nv">%hash</span> <span class="p">);</span>
</code></pre></div>
<p>然后在模板中这样引用：</p>
<div class="highlight"><pre><code class="perl">    <span class="n">My</span> <span class="n">variable</span> <span class="n">is</span> <span class="o">&lt;</span><span class="nv">%</span><span class="err">=</span> <span class="err">$</span><span class="nv">::yourvars</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">key</span><span class="p">}</span> <span class="nv">%</span><span class="err">&gt;</span>
    <span class="nv">My</span> <span class="n">name</span> <span class="n">is</span> <span class="o">&lt;</span><span class="nv">%</span><span class="err">=</span> <span class="err">$</span><span class="nv">::name</span> <span class="nv">%</span><span class="err">&gt;</span>
    <span class="nv">My</span> <span class="n">lsd</span> <span class="n">is</span> <span class="o">&lt;</span><span class="nv">%</span><span class="err">=</span> <span class="err">$</span><span class="nv">::operatingsystem</span> <span class="nv">%</span><span class="err">&gt;</span>
</code></pre></div>
<p>明显有模仿 puppet 的痕迹，传递进模版的变量以 <code>$::</code> 开头，个人比较汗……</p>
<p>所以个人建议还是更换成 CPAN 上的流行模板，比如 <code>Text::Xslate</code> 或者 <code>Text::MicroTemplate</code> 等等，使用 <code>set_template_option</code> 即可。</p>
      <a href="/2013/05/28/compare-dsl-of-puppet-with-rex" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/05/27/use-rex-box-replace-vagrant" title="使用 Rex::Box 代替 Vagrant 的工作" rel="bookmark">使用 Rex::Box 代替 Vagrant 的工作</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-05-27 00:00:00 +0800">27 May 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>Vagrant 是近来 devops 界内非常流行和火爆的工具，它和 puppet/chef 的结合，成为运维开发和测试，甚至预热部署的重要手段。比如在 cloudfoundry 官方放弃使用 <code>vcap_setup</code> 脚本部署后，社区大多对其 <code>BOSH</code> 不买账，转而研究使用 vagrant 部署了。</p>
<p>对于 perl 运维人员，使用 Rex 工具做集群管理的话，其实完全不用再使用 vagrant 了。因为 Rex 自带有 Box 功能。完全可以一体化工作。下面从 Rex 官网上半翻译半截取两篇文章，展示 Rex::Box 的使用。两篇原文分别是：</p>
<ol>
  <li><a href="http://box.rexify.org/guide">http://box.rexify.org/guide</a></li>
  <li><a href="http://www.rexify.org/howtos/use_boxes_with_any_box_provider.html">http://www.rexify.org/howtos/use_boxes_with_any_box_provider.html</a></li>
</ol>
<h1 id="section">环境准备</h1>
<div class="highlight"><pre><code class="bash">rexify <span class="nv">$project</span>-name --template box
<span class="nb">cd</span> <span class="nv">$project</span>-name
rex init --name<span class="o">=</span><span class="nv">$vm</span>-name --url<span class="o">=</span><span class="nv">$url</span>-to-prebuild-vm-image
</code></pre></div>
<h1 id="section-1">虚拟机定义</h1>
<p>这里有两种方式，一种是类似 Vagrantfile 定义的 Rexfile 写法：</p>
<div class="highlight"><pre><code class="perl"><span class="n">set</span> <span class="n">box</span> <span class="o">=&gt;</span> <span class="s">&quot;VBox&quot;</span><span class="p">;</span>
<span class="n">task</span> <span class="n">mytask</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span>
   <span class="n">box</span> <span class="p">{</span>
      <span class="k">my</span> <span class="p">(</span><span class="nv">$box</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
      <span class="nv">$box</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;boxname&quot;</span><span class="p">);</span>
      <span class="nv">$box</span><span class="o">-&gt;</span><span class="n">url</span><span class="p">(</span><span class="s">&quot;http://box.rexify.org/box/base-image.box&quot;</span><span class="p">);</span>
      <span class="nv">$box</span><span class="o">-&gt;</span><span class="n">network</span><span class="p">(</span><span class="mi">1</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">type</span> <span class="o">=&gt;</span> <span class="s">&quot;bridged&quot;</span>      <span class="c1"># 默认是 &quot;nat&quot;,</span>
        <span class="n">bridge</span> <span class="o">=&gt;</span> <span class="s">&quot;eth0&quot;</span><span class="p">,</span>
      <span class="p">});</span>
      <span class="nv">$box</span><span class="o">-&gt;</span><span class="n">forward_port</span><span class="p">(</span><span class="n">ssh</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">2222</span><span class="p">,</span> <span class="mi">22</span><span class="p">]);</span>
      <span class="nv">$box</span><span class="o">-&gt;</span><span class="n">share_folder</span><span class="p">(</span><span class="n">boxhome</span> <span class="o">=&gt;</span> <span class="s">&quot;/path/to/myuser&quot;</span><span class="p">);</span>
      <span class="nv">$box</span><span class="o">-&gt;</span><span class="n">auth</span><span class="p">(</span>
        <span class="n">user</span> <span class="o">=&gt;</span> <span class="s">&quot;root&quot;</span><span class="p">,</span>
        <span class="n">password</span> <span class="o">=&gt;</span> <span class="s">&quot;box&quot;</span><span class="p">,</span>
      <span class="p">);</span>
      <span class="nv">$box</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">(</span><span class="sx">qw/setup_frontend/</span><span class="p">);</span>
   <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
<p>另一种是采用 YAML 配置：</p>
<div class="highlight"><pre><code class="yaml"><span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">VBox</span>
<span class="l-Scalar-Plain">vms</span><span class="p-Indicator">:</span>
   <span class="l-Scalar-Plain">fe01</span><span class="p-Indicator">:</span>
      <span class="l-Scalar-Plain">url</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">http://box.rexify.org/box/ubuntu-server-12.10-amd64.ova</span>
      <span class="l-Scalar-Plain">network</span><span class="p-Indicator">:</span>
         <span class="l-Scalar-Plain">1</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">bridged</span>
            <span class="l-Scalar-Plain">bridge</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">eth0</span>
      <span class="l-Scalar-Plain">setup</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">setup_frontend</span>
   <span class="l-Scalar-Plain">db01</span><span class="p-Indicator">:</span>
      <span class="l-Scalar-Plain">url</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">http://box.rexify.org/box/ubuntu-server-12.10-amd64.ova</span>
      <span class="l-Scalar-Plain">network</span><span class="p-Indicator">:</span>
         <span class="l-Scalar-Plain">1</span><span class="p-Indicator">:</span>
            <span class="l-Scalar-Plain">type</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">bridged</span>
            <span class="l-Scalar-Plain">bridge</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">eth0</span>
      <span class="l-Scalar-Plain">setup</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">setup_db</span>
</code></pre></div>
<h1 id="section-2">虚拟机初始化</h1>
<p>在 Vagrant 中有一个概念叫 provision，也就是在虚拟机第一次运行时，通过 shell/puppet/chef 等进行初始化操作。Rex::Box 自然是通过 Rex 本身来进行这个任务。也就是上例中的 <code>setup</code> 定义的 task 名称。</p>
<div class="highlight"><pre><code class="perl"><span class="n">task</span> <span class="s">&#39;setup_frontend&#39;</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
    <span class="n">install</span> <span class="n">nginx</span><span class="p">;</span>
    <span class="n">file</span> <span class="s">&#39;/etc/nginx.conf&#39;</span><span class="p">,</span>
        <span class="n">content</span>   <span class="o">=&gt;</span> <span class="n">template</span><span class="p">(</span><span class="s">&#39;template/httpd.conf.tpl&#39;</span><span class="p">),</span>
        <span class="n">owner</span>     <span class="o">=&gt;</span> <span class="s">&quot;root&quot;</span><span class="p">,</span>
        <span class="n">group</span>     <span class="o">=&gt;</span> <span class="s">&quot;root&quot;</span><span class="p">,</span>
        <span class="n">on_change</span> <span class="o">=&gt;</span> <span class="k">sub </span><span class="p">{</span> <span class="n">service</span> <span class="n">nginx</span> <span class="o">=&gt;</span> <span class="s">&quot;restart&quot;</span><span class="p">;</span> <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
<p>因为 rex 本身是通过 ssh 管理，所以在 setup 之前，必须定义好如何 auth，自己做的镜像不说了，通过 rexify.org 下载的默认镜像，就是默认的 root/box 了。</p>
<p>说到镜像，其实 vagrant 的 <code>.box</code> 也就是 <code>.ova</code> ，都是把 virtualbox 的 <code>.vmdk</code> 和 <code>.ovf</code> 打了个包而已。</p>
<p>当然，也可以在 task 写 shell，通过 <code>run</code> 的方式，其实 run 应该也是 Rex 最常用的 task 了。</p>
<div class="highlight"><pre><code class="perl"><span class="n">task</span> <span class="s">&#39;setup_frontend&#39;</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
    <span class="n">run</span> <span class="s">&quot;echo Hello, world&quot;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<h1 id="section-3">虚拟机使用</h1>
<p>定义完成后，就可以使用 init 配置虚拟机环境，然后 start/stop 管理虚拟机。</p>
<p>比如在使用 YAML 配置的时候，配置环境的 Rexfile 最后是这样的：</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="nn">Rex::Commands::</span><span class="n">Box</span> <span class="n">init_file</span> <span class="o">=&gt;</span> <span class="s">&quot;box.yml&quot;</span><span class="p">;</span>
<span class="n">group</span> <span class="n">myboxes</span> <span class="o">=&gt;</span> <span class="nb">map</span> <span class="p">{</span> <span class="n">get_box</span><span class="p">(</span><span class="nv">$_</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">name</span><span class="p">})</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">ip</span><span class="p">}</span> <span class="p">}</span> <span class="n">list_boxes</span><span class="p">;</span>
<span class="n">task</span> <span class="s">&quot;box&quot;</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
   <span class="n">boxes</span> <span class="s">&quot;init&quot;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>像要做成命令行管理也比较简单，比如启动和停止虚拟机的 task 这样写：</p>
<div class="highlight"><pre><code class="perl"><span class="n">task</span> <span class="s">&quot;stop&quot;</span><span class="p">,</span> <span class="k">sub </span><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$param</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="n">boxes</span> <span class="n">stop</span> <span class="o">=&gt;</span> <span class="nv">$param</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">name</span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
<p>就可以在命令行直接这样启动某个虚拟机了：</p>
<div class="highlight"><pre><code class="bash">rex stop --name<span class="o">=</span>myvbox
</code></pre></div>
<p>事实上，本文最开头的默认 box 模板生成的命令，就是通过前一步生成的 Rexfile 里定义的 <code>task "init", sub {...};</code> 实现的。</p>
<p><strong>2013 年 07 月 23 日附注：</strong></p>
<p>虽然如此，但是 Vagrant 目前已经成为开源社区风头正劲的一个产品，其开放的 plugin 机制导致周边产品大量出现，已经形成了一个不错的社区氛围。还是建议大家了解 Vagrant 。目前 vagrant-plugin 列表见：<a href="https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins">https://github.com/mitchellh/vagrant/wiki/Available-Vagrant-Plugins</a>。</p>
      <a href="/2013/05/27/use-rex-box-replace-vagrant" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/05/14/mojo-and-gocr-for-buildhr-telephone" title="用mojo抓取数据并gocr替换图片内容" rel="bookmark">用mojo抓取数据并gocr替换图片内容</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-05-14 00:00:00 +0800">14 May 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>现在的网站越来越狡猾，连招聘网站的信息都懂的把公司的联系方式动态图片化了。还好为了观看方便，没加什么干扰。所以写个脚本来识别还是可以的。虽然到目前为止没发现比较好的 OCR 工具——我指的是可以直接apt-get安装的，有朋友知道哪个比较好的话，欢迎告诉我~</p>
<p>尝试了一下 tesseract-ocr 和 gocr ，还是 gocr 靠谱一点点。所以 <code>apt-get install gocr</code> 安装然后运行下面这个 Perl 脚本：</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="n">ojo</span><span class="p">;</span>
<span class="k">use</span> <span class="mf">5.010</span><span class="p">;</span>
<span class="n">g</span><span class="p">(</span><span class="s">&quot;http://search.buildhr.com/job/581968.html&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dom</span><span class="o">-&gt;</span><span class="n">charset</span><span class="p">(</span><span class="s">&quot;UTF-8&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;div .postjob .padding&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">each</span><span class="p">(</span><span class="n">sub</span><span class="p">{</span>
    <span class="k">my</span> <span class="nv">$line</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$img_element</span> <span class="o">=</span> <span class="nv">$line</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="s">&#39;img&#39;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">defined</span> <span class="nv">$img_element</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$img_url</span> <span class="o">=</span> <span class="nv">$img_element</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">src</span><span class="p">};</span>
        <span class="n">g</span><span class="p">(</span><span class="nv">$img_url</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">content</span><span class="o">-&gt;</span><span class="n">asset</span><span class="o">-&gt;</span><span class="n">move_to</span><span class="p">(</span><span class="s">&quot;test.jpg&quot;</span><span class="p">);</span>
        <span class="k">my</span> <span class="nv">$seem_str</span> <span class="o">=</span> <span class="sb">`gocr test.jpg`</span><span class="p">;</span>
        <span class="nb">chomp</span><span class="p">(</span><span class="nv">$seem_str</span><span class="p">);</span>
        <span class="n">say</span> <span class="nb">join</span><span class="p">(</span><span class="nv">$seem_str</span><span class="p">,</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/ /</span><span class="p">,</span> <span class="nv">$line</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>不过老是把 <code>7</code> 识别成 <code>_</code>。</p>
<p>真是越来越觉得 ojo 好用啊~</p>
      <a href="/2013/05/14/mojo-and-gocr-for-buildhr-telephone" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/04/19/something-dive-to-perl" title="Newbie::Gift 所用知识总结" rel="bookmark">Newbie::Gift 所用知识总结</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-04-19 00:00:00 +0800">19 Apr 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>通过 <a href="https://github.com/chenryn/Newbie-Gift">Newbie::Gift</a> 项目的开发过程，学习和深入了解了不少 Perl 知识，虽然这个模块估计短期内不会再继续开发和更新了，不过还是值得记录一下这段过程中的心得。</p>
<h3 id="gensym">gensym</h3>
<p>封装 <code>IPC::Open3</code> 模块时，通过 <code>smokeping</code> 代码中学到了 <code>Symbol</code> 模块的 <code>gensym</code> 指令的使用。</p>
<p>通过 <code>gensym</code> 指令可以直接返回一个临时文件句柄来使用。</p>
<h3 id="cb-">$cb-&gt;()</h3>
<p>在 SPEC 设计中，所有导出指令都采用回调的方式。在 Perl 中实现起来其实特别简单。像下面这样就好了：</p>
<div class="highlight"><pre><code class="perl"><span class="k">sub </span><span class="nf">keyword</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span> <span class="nv">$str</span><span class="p">,</span> <span class="nv">$cb</span> <span class="p">)</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$res</span> <span class="o">=</span> <span class="n">do_some_func</span><span class="p">(</span><span class="nv">$str</span><span class="p">);</span>
    <span class="nv">$cb</span><span class="o">-&gt;</span><span class="p">(</span><span class="nv">$res</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="selectortoxpath">selector_to_xpath</h3>
<p>之前一直有使用 <code>Mojo::UserAgent</code> 配合 <code>Mojo::DOM</code> 完成网页抓取工作，这次自己实践，参考的是另一个 <a href="https://metacpan.org/module/Web::Query">Web::Query</a> 模块。其中最关键的两步，第一是通过 <a href="https://metacpan.org/module/HTML::Selector::XPath">selector_to_xpath</a> 指令把选择器的写法转换成 XPath 语言；第二是通过 XPath 操作网页的 <a href="https://metacpan.org/module/HTML::TreeBuilder::XPath">HTML::Tree</a>。</p>
<p>不过 <code>Mojo</code> 里对象化的很完整，返回的数组和字符串都是对象，所以可以一直反复调用方法连接起来处理，写的会很爽。用 <code>Web::Query</code> 没有这个效果。</p>
<h3 id="filestat">File::stat</h3>
<p>stat 是 perl 默认的函数，不过返回的数组在 mode 和 time 方面可读性都不好，所以封装一下，提供更加可读的 0644 这样的 mode 格式，直接用 <code>sprintf</code> 就可以做到：</p>
<div class="highlight"><pre><code class="perl">    <span class="nb">sprintf</span><span class="p">(</span> <span class="s">&quot;%04o&quot;</span><span class="p">,</span> <span class="nv">$ret</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mo">07777</span> <span class="p">);</span>
</code></pre></div>
<h3 id="datetime">DateTime</h3>
<p>Perl 的 <a href="https://metacpan.org/module/DateTime">DateTime</a> 模块太重，CPAN 上其实也有很多人提交简化版的 DT，其实就是利用 <code>localtime</code>，<code>strftime</code> 和 <code>mktime</code> 几个默认函数做出来的对象调用。</p>
<h3 id="exporter">Exporter</h3>
<p><code>import</code> 和 <code>export_to_level</code> 都是 <code>Exporter</code> 模块的方法，所有继承自 <code>Exporter</code> 的模块可以用。比如下面示例，启用该模块，就相当于启用了 <code>strict</code>，<code>warnings</code>，<code>utf8</code> 和 Perl5.10 版的新特性，同时导出了 keywords 关键字。</p>
<div class="highlight"><pre><code class="perl">    <span class="k">use</span> <span class="n">base</span> <span class="s">&#39;Exporter&#39;</span><span class="p">;</span>
    <span class="k">our</span> <span class="nv">@EXPORT</span> <span class="o">=</span> <span class="sx">qw/keywords/</span><span class="p">;</span>
    <span class="k">sub </span><span class="nf">keywords</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
    <span class="k">sub </span><span class="nf">import</span> <span class="p">{</span>
        <span class="k">my</span> <span class="nv">$class</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
        <span class="n">strict</span><span class="o">-&gt;</span><span class="nb">import</span><span class="p">;</span>
        <span class="n">warnings</span><span class="o">-&gt;</span><span class="nb">import</span><span class="p">;</span>
        <span class="n">utf8</span><span class="o">-&gt;</span><span class="nb">import</span><span class="p">;</span>
        <span class="n">feature</span><span class="o">-&gt;</span><span class="nb">import</span><span class="p">(</span><span class="s">&#39;:5.10&#39;</span><span class="p">);</span>
        <span class="nn">Try::</span><span class="n">Tiny</span><span class="o">-&gt;</span><span class="nb">import</span><span class="p">;</span>
        <span class="nv">$class</span><span class="o">-&gt;</span><span class="n">export_to_level</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">$class</span><span class="p">,</span> <span class="nv">@EXPORT</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<h3 id="zip">zip</h3>
<p>多数组可以通过 <code>zip</code> 命令逐一对位融合到一起。这个在 <a href="https://metacpan.org/module/List::MoreUtils">List::MoreUtils</a> 中有，这次用 <code>NG::Array</code> 对象实现了一边，其原理是先记录每个数组的长度，然后以最长的那个数组为标杆，循环一遍即可。</p>
<h3 id="autobox">autobox</h3>
<p>CPAN 上 Rubyish、Perl6::<em>、Perl5i::</em> 等模块都利用了 <a href="https://metacpan.org/module/autobox">autobox</a> 实现完全的对象化。autobox 是一个库，本身不提供对象方法，而是要自己自己实现针对某个类型的对象方法后，通过 autobox 关联到 Perl 的数据类型上去。</p>
<p>比如想要实现一个 <code>"Hello World"-&gt;lc-&gt;words</code> 的语法，显然就是要针对 Perl 中的 STRING 数据类型实现 lc 和 words 两个方法。那么先实现一个自己的 string 对象：</p>
<div class="highlight"><pre><code class="perl">    <span class="nb">package</span> <span class="nn">your::</span><span class="n">string</span><span class="p">;</span>
    <span class="k">sub </span><span class="nf">lc</span>    <span class="p">{</span> <span class="nn">CORE::</span><span class="n">lc</span>           <span class="nv">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
    <span class="k">sub </span><span class="nf">words</span> <span class="p">{</span> <span class="nn">CORE::</span><span class="n">split</span> <span class="sr">/\s+/</span><span class="p">,</span> <span class="nv">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
    <span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>然后开始关联：</p>
<div class="highlight"><pre><code class="perl">    <span class="nb">package</span> <span class="nn">your::</span><span class="n">autobox</span><span class="p">;</span>
    <span class="k">use</span> <span class="n">base</span> <span class="sx">qw(autobox)</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">your::</span><span class="n">string</span><span class="p">;</span>
    <span class="k">sub </span><span class="nf">import</span> <span class="p">{</span>
        <span class="nb">shift</span><span class="o">-&gt;</span><span class="nn">SUPER::</span><span class="n">import</span><span class="p">(</span>
            <span class="n">STRING</span> <span class="o">=&gt;</span> <span class="s">&#39;your::string&#39;</span><span class="p">,</span>
            <span class="nv">@_</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>最后在前面提到过的 <code>Exporter</code> 的 <code>import</code> 函数里加上一行：</p>
<div class="highlight"><pre><code class="perl">    <span class="nn">your::</span><span class="n">autobox</span><span class="o">-&gt;</span><span class="nb">import</span><span class="p">;</span>
</code></pre></div>
<p>autobox 可以关联的数据类型还有很多，绝对是值得一看的模块。</p>
<h3 id="evalclassnew">eval(&lsquo;*&rsquo;.$class.&rsquo;::new&rsquo;)</h3>
<p>实现 <code>def_class</code> 关键词的过程中学习颇多，首先是符号表。实现中完成模块代码几乎全靠符号表来绑定一个个函数和变量。像这样：</p>
<div class="highlight"><pre><code class="perl">    <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="o">.</span><span class="nv">$class</span><span class="o">.</span><span class="s">&#39;::ISA&#39;</span><span class="p">);</span>
    <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="nv">$parent</span><span class="p">];</span>
    <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="o">.</span><span class="nv">$class</span><span class="o">.</span><span class="s">&#39;::new&#39;</span><span class="p">);</span>
    <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="k">sub </span><span class="p">{</span>
        <span class="k">my</span> <span class="p">(</span><span class="nv">$class</span><span class="p">,</span> <span class="nv">@args</span><span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
        <span class="nb">push</span> <span class="nv">@args</span><span class="p">,</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="nv">$#args</span> <span class="nv">%</span> <span class="nv">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$o</span> <span class="o">=</span> <span class="nb">bless</span> <span class="p">{</span><span class="nv">@args</span><span class="p">},</span> <span class="nb">ref</span> <span class="nv">$class</span> <span class="o">||</span> <span class="nv">$class</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">defined</span> <span class="nv">$methods</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">build</span><span class="p">}){</span>
            <span class="nv">$o</span><span class="o">-&gt;</span><span class="n">build</span><span class="p">(</span><span class="nv">@args</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nv">$o</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>不过这个实现有个问题，就是对象只能是基于哈希的引用，不能是数组的了。</p>
<h3 id="section">对象的元数据</h3>
<p>实现 <code>def_class</code> 的时候比 spec 多新增了一个默认属性叫meta，所有用 <code>def_class</code> 实现的类，会自动记录他们(包括他们的用 <code>def_class</code> 实现的父类)的属性和方法到meta属性里。</p>
<p>为此阅读了一下 <code>Moo</code> 和 <code>Moos</code> 的代码。
<strong>原来他们都是把属性和方法也实现为类。然后再有 <code>*::Meta</code> 类来记录这些属性和方法的类。</strong></p>
<p>而 <code>Newbie::Gift</code> 计划中没打算把对象化搞得这么彻底，所以就只是存了一个 hash 到 默认 meta 属性里。</p>
<h3 id="lvalue">:lvalue</h3>
<p>对象除了方法还要有属性，<code>def_class</code> 里也有实现，同样是用符号表绑定的。</p>
<p>不过这里用到了 Perl5.10 的一个新东西，函数属性，这里绑定的不是普通变量而是函数，但是函数只会读写一个变量值，具体的说就是使用 <code>sub :lvalue {}</code> 定义。使用方法如下所示：</p>
<div class="highlight"><pre><code class="perl">    <span class="k">my</span> <span class="nv">$val</span><span class="p">;</span>
    <span class="k">sub </span><span class="nf">canmod</span> <span class="p">:lvalue {</span>
        <span class="c1"># return $val; this doesn&#39;t work, don&#39;t say &quot;return&quot;</span>
        <span class="nv">$val</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">sub </span><span class="nf">nomod</span> <span class="p">{</span>
        <span class="nv">$val</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">canmod</span><span class="p">()</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   <span class="c1"># assigns to $val</span>
    <span class="n">nomod</span><span class="p">()</span>  <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   <span class="c1"># ERROR</span>
</code></pre></div>
<p>lvalue 的说明见 <code>perldoc perlsub</code> 文档。在这里还是个比较有趣的用法的，这个用法来自 <code>Newbie::Gift</code> 项目另一位参与者 <a href="https://github.com/fmpdceudy">fmpdceudy</a>。</p>
      <a href="/2013/04/19/something-dive-to-perl" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/04/16/install-foreman" title="使用 Foreman 来监控统计 puppet 的 reports 信息" rel="bookmark">使用 Foreman 来监控统计 puppet 的 reports 信息</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-04-16 00:00:00 +0800">16 Apr 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>foreman 是社区比较推荐的一款 puppet 辅助工具。可以用来实现 ENC 控制，class 编写，Facts 变量统计和 reports 分析查询等等。</p>
<p>鉴于我一直以来都是用 gem 安装 puppet，所以这里也就没法通过 yum/apt 来安装 foreman，只能源码操作了：</p>
<div class="highlight"><pre><code class="bash">    git clone https://github.com/theforeman/foreman.git -b develop
    <span class="nb">cd </span>foreman
    bundle install --without postgresql mysql mysql2 
    cp config/settings.yaml.example config/settings.yaml
    cp config/database.yml.example config/database.yml
    <span class="nv">RAILS_ENV</span><span class="o">=</span>production bundle <span class="nb">exec </span>rake db:migrate
    rake puppet:import:hosts_and_facts <span class="nv">RAILS_ENV</span><span class="o">=</span>production
    ./script/rails server -p 3333 -e production -d
</code></pre></div>
<p>然后就可以通过3333端口访问并查看刚才导入的 Facts 变量了，默认的用户名密码是 admin/changeme。</p>
<p>新版本的 foreman，必须使用 smart-proxy 才能接收 reports。所以还要继续安装：</p>
<div class="highlight"><pre><code class="bash">    git clone git://github.com/theforeman/smart-proxy.git
    <span class="nb">cd </span>smart-proxy
    sed -i <span class="s1">&#39;s/^#:puppet:.*/:puppet: true/&#39;</span> config/settings.yml
    ./bin/smart-proxy.rb
</code></pre></div>
<p>foreman 提供了一个 <a href="https://raw.github.com/theforeman/puppet-foreman/master/templates/foreman-report.rb.erb">ruby 脚本</a>，用来扩充 puppet 的 reports 功能。下载放到对应的 <code>${GEM_PATH}/gems/puppet-${version}/lib/puppet/reports/</code> 下，然后修改其中的 <code>$foreman_url</code> 变量即可。</p>
<p>我们也可以在 puppet 自带的 http.rb 基础上稍微修改得到相同效果，总的来说，就是通过 POST 方法，提交 <code>report =&gt; self.to_yaml</code> 到 <code>$foreman_url/reports/create?format=yml</code> 就可以了。</p>
<p>然后在 foreman 页面上配置 smart-proxy 地址。注意这里有个小坑：__如果你填写的是域名，那么解析出来的 ip 还要被反解验证一次。__我当初为了 puppet master 迁移方便，给 master 配置了一个单独的域名，包括 <code>puppet cert</code> 生成证书时也特意指定用这个域名，但是默认的 hostname 其实是另一个域名的。于是在此悲剧了很久。。。</p>
<p>错误的现象是：采用 <code>puppet master</code> 启动时，功能一切正常；采用 <code>rackup</code> + Nginx 代理的方式启动时，默认的 store 功能正常，而采用 foreman 接收 reports 的话，可以在 <code>rackup</code> 的访问日志中看到 POST 200 的记录，<code>foreman</code> 里却没有接到请求。</p>
<p>目前还不清楚为什么两种不同方式启动 puppet 的 master 会对 smart-proxy 造成什么区别影响，但是修改 foreman 里配置的 smart-proxy 地址为默认 hostname 而不是单独的域名后，就成功了。</p>
<p>另外一个使用上的小问题。foreman 页面上的 Reports 标签的 <code>&lt;a href=""&gt;</code> 属性默认是带搜索参数 eventful 的。也就是说优先展示的是有事件发生的日志，比如 failed，restart 等等；而不是直接以日期排序。</p>
      <a href="/2013/04/16/install-foreman" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/04/03/install-graphite" title="Graphite 安装" rel="bookmark">Graphite 安装</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-04-03 00:00:00 +0800">03 Apr 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>Graphite 是近来比较流行的类 rrd tool 系统。不过官网的安装文档真的很烂，特记录一下自己的步骤。</p>
<p>由于是事后追忆，同样不保证好用……</p>
<div class="highlight"><pre><code class="bash">apt-get install python-pip libapache2-mod-wsgi subversion git
git clone https://github.com/graphite-project/graphite-web.git
git clone https://github.com/graphite-project/carbon.git
git clone https://github.com/graphite-project/whisper.git
<span class="c"># 这两个是直接通过 pip 安装的不顶用，只能另外下非标准的包安装</span>
git clone https://github.com/graphite-project/ceres.git
svn checkout http://django-tagging.googlecode.com/svn/trunk/ tagging-trunk
<span class="nb">cd </span>whisper
sudo python setup.py install
<span class="nb">cd</span> ../carbon
python setup.py install 
<span class="nb">cd</span> ../graphite-web
python check-dependencies.py
<span class="c"># 很奇怪 python 居然不自动解决依赖，check 出来一个列表还得自己来</span>
apt-get install python-memcache python-txamqp python-rrdtool python-pyparsing python-django
python setup.py install
<span class="nb">cd</span> ../ceres
python setup.py install
<span class="nb">cd</span> ../tagging-trunk
python setup.py install
groupadd graphite
ln -s /opt/graphite/examples/example-graphite-vhost.conf /etc/apache2/conf.d/graphite.conf
<span class="c"># 默认的 run/wsgi 会在 /etc/apache2/ 目录下，权限有问题</span>
sed -i <span class="s1">&#39;s!^\(WSGISocketPrefix\) \(run/wsgi\)$!\1 /var/\2$!&#39;</span> /etc/apache2/conf.d/graphite.conf
chown -R www-data:graphite /opt/graphite/storage/
service apache2 restart
<span class="nb">cd</span> /opt/graphite/webapp/graphite
cp local_settings.py.example local_settings.py
<span class="c"># 默认的 database 配置是针对 python2.4 的，需要开启针对 python2.5 以上版本的配置:</span>
<span class="c"># DATABASES = {</span>
<span class="c">#     &#39;default&#39;: {</span>
<span class="c">#         &#39;NAME&#39;: &#39;/opt/graphite/storage/graphite.db&#39;,</span>
<span class="c">#         &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,</span>
<span class="c">#         &#39;USER&#39;: &#39;&#39;,</span>
<span class="c">#         &#39;PASSWORD&#39;: &#39;&#39;,</span>
<span class="c">#         &#39;HOST&#39;: &#39;&#39;,</span>
<span class="c">#         &#39;PORT&#39;: &#39;&#39;</span>
<span class="c">#     }</span>
<span class="c"># }</span>
sed -i <span class="s1">&#39;167,176s/^#//&#39;</span> local_settings.py
python manage.py syncdb
<span class="nb">cd</span> /opt/graphite/conf
rename <span class="s1">&#39;s/.example//&#39;</span> *.example
<span class="nb">cd</span> /opt/graphite/
<span class="c"># 会监听 2003 端口</span>
./bin/carbon-cache.py start
<span class="c"># 通过 socket 发送本机的 loadavg 到 2003 端口</span>
python /opt/graphite/examples/example-client.py
</code></pre></div>
<p>效果如下：</p>
<p><img src="/images/uploads/graphite-auto-refresh.png" alt="graphite" /></p>
<p>还可以点击 plot 成下面这样，并且添加 event 以供查看：</p>
<p><img src="/images/uploads/graphite-graphlot.png" alt="graphlot" /></p>
      <a href="/2013/04/03/install-graphite" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/04/02/parse-puppet-dsl-using-perl6" title="用 Perl6 解析 puppet 的配置语法" rel="bookmark">用 Perl6 解析 puppet 的配置语法</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-04-02 00:00:00 +0800">02 Apr 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>前段时间看到报道说，puppet 的作者本来是用 perl 完成的原型设计，后来改用的 ruby。所以我想，目前这个 puppet 的 DSL 设计，用 perl 来完成的话，应该如何做。</p>
<p>这里碰到一个问题，就是 puppet 中 <code>resource_type</code> 的 <code>title</code> 后面有个冒号，这事儿比较麻烦，不过这时候我突然想到了 Perl6 ，稍微翻了一下文档，发现这事用 Perl6 来实现很容易：</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="n">v6</span><span class="p">;</span>
<span class="k">sub </span><span class="nf">infix</span><span class="p">:&lt;:&gt;($a, %b){</span>
    <span class="k">return</span> <span class="nv">$a</span><span class="p">,</span> <span class="nv">%b</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">sub </span><span class="nf">service</span><span class="p">(&amp;service) {</span>
    <span class="k">my</span> <span class="nv">@res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">service</span><span class="o">.</span><span class="p">();</span>
    <span class="n">say</span> <span class="nv">@res</span><span class="o">.</span><span class="nb">shift</span> <span class="o">=&gt;</span> <span class="nv">@res</span><span class="o">.</span><span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">class</span> <span class="nn">nginx::</span><span class="n">install</span> <span class="p">{</span>
	<span class="k">my</span> <span class="nv">$nginxparams</span> <span class="o">=</span> <span class="s">&quot;nginx&quot;</span><span class="p">;</span>
	<span class="n">service</span> <span class="p">{</span> <span class="s">&quot;$nginxparams&quot;</span><span class="p">:</span>
        <span class="n">conf</span> <span class="o">=&gt;</span> <span class="s">&quot;#&quot;</span><span class="p">,</span>
        <span class="n">source</span> <span class="o">=&gt;</span> <span class="s">&quot;http&quot;</span> 
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>运行结果如下：</p>
<div class="highlight"><pre><code class="perl"><span class="n">perl6</span> <span class="sr">/data/</span><span class="n">perl6</span><span class="sr">/script/</span><span class="n">puppet</span><span class="o">-</span><span class="n">style</span><span class="o">.</span><span class="n">pl</span>
<span class="s">&quot;nginx&quot;</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s">&quot;conf&quot;</span> <span class="o">=&gt;</span> <span class="s">&quot;#&quot;</span><span class="p">,</span> <span class="s">&quot;source&quot;</span> <span class="o">=&gt;</span> <span class="s">&quot;http&quot;</span><span class="p">}</span>
</code></pre></div>
<p>当然实际上 puppet 要复杂很多，这里其实更多是为了说明 Perl6 如何自定义操作符~</p>
      <a href="/2013/04/02/parse-puppet-dsl-using-perl6" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/04/01/use-mojo-commandline-for-rpmbuild" title="用 Mojo 命令行抓取数据完成自动更新 rpm 构建" rel="bookmark">用 Mojo 命令行抓取数据完成自动更新 rpm 构建</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-04-01 00:00:00 +0800">01 Apr 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>我一直很喜欢 <code>Dancer</code> 里的 keyword 方式，所以很少使用 <code>Mojolicious</code> 框架来写网站，不过 <code>Mojo::UserAgent</code> 和 <code>Mojo::DOM</code> 在一起作为爬虫工具使用，真是太方便了。这两天需要自己打包 <code>tengine</code> ，考虑自动化因素，需要从 <code>tengine</code> 和 其他第三方模块的 <code>github</code> 托管网页上定期查询其更新，都是一行代码就搞定了。整个 <code>Build.PL</code> 如下：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/env perl</span>
<span class="k">use</span> <span class="nn">Modern::</span><span class="n">Perl</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">IPC::</span><span class="n">Run</span> <span class="sx">qw(run)</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">File::</span><span class="n">Slurp</span><span class="p">;</span>
<span class="k">use</span> <span class="n">POSIX</span> <span class="sx">qw(strftime)</span><span class="p">;</span>
<span class="k">use</span> <span class="n">Template</span><span class="p">;</span>
<span class="k">use</span> <span class="n">ojo</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">@ModuleList</span> <span class="o">=</span> <span class="sx">qw(</span>
<span class="sx">    renren/ngx_http_accounting_module</span>
<span class="sx">    agentzh/echo-nginx-module</span>
<span class="sx">    agentzh/chunkin-nginx-module</span>
<span class="sx">    simpl/ngx_devel_kit</span>
<span class="sx">    calio/form-input-nginx-module</span>
<span class="sx">    chaoslawful/lua-nginx-module</span>
<span class="sx">    renren/ngx_http_consistent_hash</span>
<span class="sx">)</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$TengineMD5</span> <span class="o">=</span> <span class="p">(</span><span class="nb">split</span><span class="p">(</span><span class="sr">/ /</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="s">&quot;http://tengine.taobao.org/download_cn.html&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dom</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;.one_col li span&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="n">write_file</span><span class="p">(</span><span class="s">&quot;md5.txt&quot;</span><span class="p">,</span> <span class="s">&quot;firstimetorun&quot;</span><span class="p">)</span> <span class="k">unless</span> <span class="o">-</span><span class="n">f</span> <span class="s">&quot;md5.txt&quot;</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$TengineOldMD5</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span> <span class="s">&quot;md5.txt&quot;</span> <span class="p">);</span>
<span class="n">say</span> <span class="nv">$TengineOldMD5</span><span class="p">;</span>
<span class="n">say</span> <span class="nv">$TengineMD5</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="nv">$TengineMD5</span> <span class="ow">ne</span> <span class="nv">$TengineOldMD5</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">gettarball</span><span class="p">(</span><span class="o">\</span><span class="nv">@ModuleList</span><span class="p">);</span>
    <span class="n">write_file</span><span class="p">(</span><span class="s">&quot;md5.txt&quot;</span><span class="p">,</span> <span class="nv">$TengineMD5</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">sub </span><span class="nf">gettarball</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$ModuleList</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$TengineUrl</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="s">&quot;http://tengine.taobao.org/download_cn.html&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dom</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;.one_col li a&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">{</span><span class="n">href</span><span class="p">};</span>
    <span class="k">my</span> <span class="nv">$TengineVersion</span> <span class="o">=</span> <span class="nv">$1</span> <span class="k">if</span> <span class="nv">$TengineUrl</span> <span class="o">=~</span> <span class="sr">m!download/tengine-(.*).tar.gz!</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$TengineRelease</span> <span class="o">=</span> <span class="n">strftime</span><span class="p">(</span><span class="s">&quot;%Y%m%d%H%M&quot;</span><span class="p">,</span><span class="nb">localtime</span><span class="p">);</span>
    <span class="n">run</span><span class="p">(</span><span class="s">&#39;wget&#39;</span><span class="p">,</span> <span class="s">&quot;http://tengine.taobao.org/${TengineUrl}&quot;</span><span class="p">,</span> <span class="s">&#39;-O&#39;</span><span class="p">,</span> <span class="s">&quot;SOURCES/tengine-${TengineVersion}.tar.gz&quot;</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">@ModuleFile</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">for</span> <span class="k">my</span> <span class="nv">$Module</span> <span class="p">(</span> <span class="nv">@</span><span class="p">{</span> <span class="nv">$ModuleList</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{;</span>
        <span class="k">my</span> <span class="nv">$GitUrl</span> <span class="o">=</span> <span class="s">&quot;https://github.com/${Module}&quot;</span><span class="p">;</span>
        <span class="n">say</span> <span class="nv">$GitUrl</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$GitCommit</span> <span class="o">=</span> <span class="nb">substr</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="s">&quot;${GitUrl}&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dom</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="s">&quot;.sha&quot;</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
        <span class="p">(</span> <span class="k">my</span> <span class="nv">$StoreName</span> <span class="o">=</span> <span class="nv">$Module</span> <span class="p">)</span> <span class="o">=~</span> <span class="sr">s!/!-!</span><span class="p">;</span>
        <span class="k">my</span> <span class="nv">$StoreFile</span> <span class="o">=</span> <span class="s">&quot;${StoreName}-${GitCommit}.tar.gz&quot;</span><span class="p">;</span>
        <span class="nb">push</span> <span class="nv">@ModuleFile</span><span class="p">,</span> <span class="p">[</span> <span class="s">&quot;Source${i}&quot;</span> <span class="o">=&gt;</span> <span class="s">&quot;${StoreName}-${GitCommit}&quot;</span> <span class="p">];</span>
        <span class="n">run</span><span class="p">(</span><span class="s">&#39;wget&#39;</span><span class="p">,</span> <span class="s">&quot;${GitUrl}/tarball/master&quot;</span><span class="p">,</span> <span class="s">&#39;-O&#39;</span><span class="p">,</span> <span class="s">&quot;SOURCES/$StoreFile&quot;</span><span class="p">);</span>
        <span class="nv">$i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nb">unlink</span><span class="p">(</span><span class="s">&#39;SPECS/tengine.spec&#39;</span><span class="p">);</span>
    <span class="k">my</span> <span class="nv">$template</span> <span class="o">=</span> <span class="n">Template</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">;</span>
    <span class="nv">$template</span><span class="o">-&gt;</span><span class="n">process</span><span class="p">(</span><span class="s">&quot;tengine.spec.tt&quot;</span><span class="p">,</span> <span class="p">{</span>
        <span class="n">TengineVersion</span> <span class="o">=&gt;</span> <span class="nv">$TengineVersion</span><span class="p">,</span>
        <span class="n">TengineRelease</span> <span class="o">=&gt;</span> <span class="nv">$TengineRelease</span><span class="p">,</span>
        <span class="n">TengineAddons</span>  <span class="o">=&gt;</span> <span class="o">\</span><span class="nv">@ModuleFile</span><span class="p">,</span>
    <span class="p">},</span> <span class="s">&quot;SPECS/tengine.spec&quot;</span><span class="p">);</span>
    <span class="n">buildrpm</span><span class="p">(</span><span class="nv">$TengineVersion</span><span class="p">,</span> <span class="nv">$TengineRelease</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">sub </span><span class="nf">buildrpm</span> <span class="p">{</span>
    <span class="k">my</span> <span class="p">(</span> <span class="nv">$TengineVersion</span><span class="p">,</span> <span class="nv">$TengineRelease</span> <span class="p">)</span> <span class="o">=</span> <span class="nv">@_</span><span class="p">;</span>
    <span class="k">my</span> <span class="p">(</span> <span class="nv">$out</span><span class="p">,</span> <span class="nv">$err</span> <span class="p">);</span>
    <span class="n">run</span> <span class="p">[</span><span class="s">&#39;rpmbuild&#39;</span><span class="p">,</span> <span class="s">&#39;-bb&#39;</span><span class="p">,</span> <span class="s">&#39;SPECS/tengine.spec&#39;</span><span class="p">],</span> <span class="nb">undef</span><span class="p">,</span> <span class="o">\</span><span class="nv">$out</span><span class="p">,</span> <span class="nv">$err</span><span class="p">;</span>
    <span class="n">mail2author</span><span class="p">(</span><span class="nv">$err</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">sub </span><span class="nf">mail2author</span> <span class="p">{</span>
    <span class="k">my</span> <span class="nv">$output</span> <span class="o">=</span> <span class="nb">shift</span><span class="p">;</span>
    <span class="k">my</span> <span class="nv">$body</span> <span class="o">=</span> <span class="nv">$output</span> <span class="p">?</span> <span class="s">&quot;Build Error: $output&quot;</span> <span class="p">:</span> <span class="s">&quot;Build OK&quot;</span><span class="p">;</span>
    <span class="n">p</span><span class="p">(</span><span class="s">&quot;http://email.notify.d.xiaonei.com/eml/tengine-build/chenlin.rao&quot;</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">DNT</span> <span class="o">=&gt;</span> <span class="mi">1</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="nv">$body</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>直接 <code>g</code> 就是 GET 方法， <code>p</code> 就是 POST 方法。然后 <code>-&gt;dom-&gt;at()</code> 后采用类似 <code>jQuery</code> 的写法就可以直接定位，然后还可以用 <code>-&gt;text</code> 来获取内容，或者 <code>-&gt;{attr}</code> 来获取属性值。</p>
<p>顺带，今天刚知道原来 <code>Template</code> 模块也有 <code>filter</code> 可用。<code>tengine.spec.tt</code> 中就用了一个大写过滤：</p>
<div class="highlight"><pre><code class="bash">Summary:    a HTTP and reverse proxy server
Name:       tengine
Version:    <span class="o">[</span>% TengineVersion %<span class="o">]</span>
Release:    <span class="o">[</span>% TengineRelease %<span class="o">]</span>
Source0:    %<span class="o">{</span>name<span class="o">}</span>-%<span class="o">{</span>version<span class="o">}</span>.tar.gz
Source1:    init.nginx
Source2:    logrotate.nginx
Source3:    nginx-renren-conf.tar.gz
<span class="o">[</span>% FOREACH Module IN TengineAddons -%<span class="o">]</span>
<span class="o">[</span>% Module.0 %<span class="o">]</span>:    <span class="o">[</span>% Module.1 %<span class="o">]</span>.tar.gz
<span class="o">[</span>% END %<span class="o">]</span>
Group:      System Environment/Daemons
License:    BSD
BuildRoot:  %<span class="o">{</span>_tmppath<span class="o">}</span>/%<span class="o">{</span>name<span class="o">}</span>-%<span class="o">{</span>version<span class="o">}</span>-%<span class="o">{</span>release<span class="o">}</span>
Requires:      pcre,zlib,lua
BuildRequires: pcre-devel,zlib-devel,lua-devel
Requires<span class="o">(</span>post<span class="o">)</span>:    chkconfig
Conflicts:     nginx
%description
Nginx with modules: 1<span class="o">)</span> ngx_http_consistent_hash; 2<span class="o">)</span> ngx_http_accounting_module; 3<span class="o">)</span> agentzh-chunkin-nginx-module. 
%prep
<span class="c">#%setup -q </span>
%setup -n tengine-%<span class="o">{</span>version<span class="o">}</span>
tar zxvf %<span class="o">{</span>SOURCE3<span class="o">}</span>
<span class="o">[</span>% FOREACH Module IN TengineAddons -%<span class="o">]</span>
tar zxvf %<span class="o">{[</span>% Module.0 FILTER upper %<span class="o">]}</span>
<span class="o">[</span>% END %<span class="o">]</span>
...;
</code></pre></div>
      <a href="/2013/04/01/use-mojo-commandline-for-rpmbuild" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/03/28/intro-haml" title="Haml 简介" rel="bookmark">Haml 简介</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-03-28 00:00:00 +0800">28 Mar 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>Haml 是 Ruby 社区的一种 HTML 标记语言，它利用强制缩进和类似 jQuery 属性标签的风格，简化书写 HTML 的工作。文档见：<a href="http://haml.info/docs.html">http://haml.info/docs.html</a>。</p>
<p>下面是一段官网上的快速入门，从标准的 erb 模板转变成 haml 模板：</p>
<div class="highlight"><pre><code class="ruby"><span class="o">&lt;</span><span class="n">div</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;content&#39;</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">div</span> <span class="n">class</span><span class="o">=</span><span class="s1">&#39;left column&#39;</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="no">Welcome</span> <span class="n">to</span> <span class="n">our</span> <span class="n">site!</span><span class="o">&lt;</span><span class="sr">/h2&gt;</span>
<span class="sr">    &lt;p&gt;&lt;%= print_infomation %&gt;&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="sr">/div&gt;</span>
<span class="sr">  &lt;div class=&#39;right&#39; id=&#39;item&lt;%= item.id %&gt;&#39;&gt;</span>
<span class="sr">    &lt;%= render :partial =&gt; &quot;item&quot; %&gt;</span>
<span class="sr">  &lt;/</span><span class="n">div</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="sr">/div&gt;</span>
</code></pre></div>
<p>用 haml 只用这么写：</p>
<div class="highlight"><pre><code class="ruby"><span class="c1">#content</span>
  <span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">column</span>
    <span class="o">%</span><span class="n">h2</span> <span class="no">Welcome</span> <span class="n">to</span> <span class="n">our</span> <span class="n">site!</span>
    <span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">print_information</span>
  <span class="o">.</span><span class="n">right</span><span class="p">{</span><span class="ss">:id</span> <span class="o">=&gt;</span> <span class="s2">&quot;item</span><span class="si">#{</span><span class="n">item</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>
    <span class="o">=</span> <span class="n">render</span> <span class="ss">:partial</span> <span class="o">=&gt;</span> <span class="s2">&quot;sidebar&quot;</span>
</code></pre></div>
<p>看起来相当 cool，回头在 CPAN 上一翻，原来 perl 社区也有 port 过来的 <a href="https://metacpan.org/module/Text::Haml">Text::Haml</a> 了。根据 perl 的特点有所改变，但是省键盘的特点依然在。</p>
<p>下面是一个例子：</p>
<div class="highlight"><pre><code class="perl"><span class="k">use</span> <span class="nn">Text::</span><span class="n">Haml</span><span class="p">;</span>
<span class="k">my</span> <span class="nv">$haml</span> <span class="o">=</span> <span class="nn">Text::</span><span class="n">Haml</span><span class="o">-&gt;</span><span class="k">new</span><span class="p">();</span>
<span class="k">my</span> <span class="nv">$hash</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">title</span> <span class="o">=&gt;</span> <span class="s">&#39;my title&#39;</span><span class="p">,</span>
    <span class="n">content</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">line1</span> <span class="o">=&gt;</span> <span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">line2</span> <span class="o">=&gt;</span> <span class="s">&quot;test2&quot;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">print</span> <span class="nv">$haml</span><span class="o">-&gt;</span><span class="n">render_file</span><span class="p">(</span><span class="s">&#39;test.haml&#39;</span><span class="p">,</span> <span class="nv">%$hash</span><span class="p">);</span>
</code></pre></div>
<p><code>test.haml</code> 如下：</p>
<div class="highlight"><pre><code class="perl"><span class="nv">%html</span><span class="p">{</span> <span class="p">:</span><span class="n">xmlns</span> <span class="o">=&gt;</span> <span class="s">&quot;http://www.w3.org/1999/xhtml&quot;</span><span class="p">,</span> <span class="p">:</span><span class="n">lang</span> <span class="o">=&gt;</span> <span class="s">&quot;zh&quot;</span><span class="p">}</span>
  <span class="nv">%head</span>
    <span class="nv">%title</span><span class="o">=</span> <span class="nv">$title</span>
  <span class="nv">%body</span>
    <span class="c1">#content</span>
      <span class="o">.</span><span class="n">container</span>
        <span class="nv">%strong</span><span class="o">=</span> <span class="nv">$title</span>
        <span class="o">-</span> <span class="k">for</span> <span class="k">my</span> <span class="nv">$line</span> <span class="p">(</span> <span class="nb">keys</span> <span class="nv">%$content</span> <span class="p">)</span> <span class="p">{</span>
            <span class="o">.</span><span class="n">row</span><span class="o">-</span><span class="n">fluid</span><span class="o">=</span> <span class="nv">$content</span><span class="o">-&gt;</span><span class="p">{</span><span class="nv">$line</span><span class="p">}</span>
        <span class="o">-</span> <span class="p">}</span>
</code></pre></div>
<p>生成的 HTML 内容如下：</p>
<div class="highlight"><pre><code class="html"><span class="nt">&lt;html</span> <span class="na">xmlns=</span><span class="s">&#39;http://www.w3.org/1999/xhtml&#39;</span> <span class="na">lang=</span><span class="s">&#39;zh&#39;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>my title<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&#39;content&#39;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&#39;container&#39;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;strong&gt;</span>my title<span class="nt">&lt;/strong&gt;</span>
          <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&#39;row-fluid&#39;</span><span class="nt">&gt;</span>test<span class="nt">&lt;/div&gt;</span>
          <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&#39;row-fluid&#39;</span><span class="nt">&gt;</span>test2<span class="nt">&lt;/div&gt;</span>
      <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div>
<p>Text::Haml 还提供了一个初始化参数 <code>vars_as_subs</code>，可以把变量变成同名函数，这样写起来就更像 ruby 了。不过目前只能是纯变量，复杂语句还是不行，所以好看不中用……</p>
<p>Text::Haml 向 Text::Xslate 学习，也提供了  <code>cache_dir</code>, <code>filter</code> 等等功能，所以性能和功能方面应该也不差。</p>
<p><a href="https://metacpan.org/module/Template::Tookit">Template::Tookit</a> 也有插件 <a href="https://metacpan.org/module/Template::Plugin::Haml">Template::Plugin::Haml</a> 可以参看。</p>
<h3 id="wrappertt">wrapper.tt</h3>
<div class="highlight"><pre><code class="perl"><span class="o">!!!</span> <span class="mi">5</span>
<span class="nv">%html</span>
<span class="p">[</span><span class="nv">%</span> <span class="nv">content</span> <span class="nv">%</span><span class="err">]</span>
</code></pre></div>
<h3 id="hellott">hello.tt</h3>
<div class="highlight"><pre><code class="perl"><span class="p">[</span><span class="nv">%</span><span class="err">-</span> <span class="nv">message</span><span class="o">=</span><span class="s">&#39;Hello World&#39;</span> <span class="nv">%</span><span class="err">]</span>
<span class="err">[%-</span> <span class="nv">USE</span> <span class="n">Haml</span> <span class="o">-</span><span class="nv">%</span><span class="err">]</span>
<span class="err">[%-</span> <span class="nv">WRAPPER</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">tt</span> <span class="o">|</span> <span class="n">haml</span> <span class="o">-</span><span class="nv">%</span><span class="err">]</span>
<span class="err">[%-</span> <span class="nv">FILTER</span> <span class="n">haml</span> <span class="o">-</span><span class="nv">%</span><span class="err">]</span>
 <span class="err">%</span><span class="nv">head</span>
  <span class="nv">%meta</span><span class="p">{:</span><span class="n">charset</span> <span class="o">=&gt;</span> <span class="s">&quot;utf-8&quot;</span><span class="p">}</span>
  <span class="nv">%title</span> <span class="n">hello</span>
 <span class="nv">%body</span>
  <span class="nv">%p</span> <span class="p">[</span><span class="nv">%</span> <span class="nv">message</span> <span class="nv">%</span><span class="err">]</span>
  <span class="err">%</span><span class="nv">ul</span>
  <span class="p">[</span><span class="nv">%</span><span class="err">-</span> <span class="nv">total</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">WHILE</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="nv">%</span><span class="err">]</span>
   <span class="err">%</span><span class="nv">li</span> <span class="p">[</span><span class="nv">%</span> <span class="nv">total</span><span class="o">=</span><span class="n">total</span><span class="o">+</span><span class="mi">1</span> <span class="nv">%</span><span class="err">][%</span> <span class="nv">total</span> <span class="nv">%</span><span class="err">]</span>
  <span class="err">[%-</span> <span class="nv">END</span> <span class="o">-</span><span class="nv">%</span><span class="err">]</span>
<span class="err">[%-</span> <span class="nv">END</span> <span class="o">-</span><span class="nv">%</span><span class="err">]</span>
</code></pre></div>
<p>perl 三大 web 框架 Catalyst/Mojo/Dancer也都有对应的模板插件。</p>
      <a href="/2013/03/28/intro-haml" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/03/27/distributed-nagios-by-mod-gearman" title="用 Mod_Gearman 实现 Nagios 分布式" rel="bookmark">用 Mod_Gearman 实现 Nagios 分布式</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-03-27 00:00:00 +0800">27 Mar 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>在 2011 年年底，我曾经连续写过四篇介绍 OMD 的文章。</p>
<ol>
  <li><a href="http://chenlinux.com/2011/12/19/omd_intro_install_on_centos5/">http://chenlinux.com/2011/12/19/omd_intro_install_on_centos5/</a></li>
  <li><a href="http://chenlinux.com/2011/12/27/conf_run_mod_gearman/">http://chenlinux.com/2011/12/27/conf_run_mod_gearman/</a></li>
  <li><a href="http://chenlinux.com/2011/12/20/omd_configurations_basic/">http://chenlinux.com/2011/12/20/omd_configurations_basic/</a></li>
  <li><a href="http://chenlinux.com/2011/12/20/shinken_discovery_runner/">http://chenlinux.com/2011/12/20/shinken_discovery_runner/</a></li>
</ol>
<p>不过之前都停留在代码观摩和安装文档的阶段。这几天刚好有点需求，真正测试了一下如何利用 mod_gearman 实现 分布式的 Nagios 监测集群。</p>
<p>OMD 的安装一如既往的简单，尤其是作为中控端，不需要讲究太多通用性，可以选择使用 ubuntu 系统，直接通过 deb 安装：</p>
<div class="highlight"><pre><code class="bash">wget http://omdistro.org/attachments/download/197/omd-0.56_0.wheezy_i386.deb
dpkg -i omd-0.56_0.wheezy_i386.deb
omd create cdn-monitor
su - cdn-monitor
omd start
</code></pre></div>
<p>这就已经启动了。</p>
<p>不过要使用 mod_gearman 的话，还需要通过 <code>omd config</code> 界面开启。</p>
<p>默认开启之后，是运行在本机多 worker 的 Load Balance 状态下。我们现在要做的是把worker拆分到其他机房去变成 Distributed 状态。</p>
<p><img src="/images/uploads/sample_distributed.png" alt="distributed" /></p>
<p>图上已经列出 server 和 worker 的主要配置不同。我们只需要照着这样改就可以了。</p>
<p>不过在作为纯 worker 端的机房服务器上，我们没有必要安装完整的 OMD 了，这厮安装包都有100MB大……</p>
<p><a href="http://mod-gearman.org/download/v1.4.2/">http://mod-gearman.org/download/v1.4.2/</a> 上提供了 mod_gearman 的独立安装包，我们只需要根据服务器发行版选择下载就可以，这里以 CentOS6 为例，相信现在这个也应该是服务器的主流。</p>
<div class="highlight"><pre><code class="bash">wget http://mod-gearman.org/download/v1.4.2/rhel6/x86_64/gearmand-0.25-1.rhel6.x86_64.rpm
wget http://mod-gearman.org/download/v1.4.2/rhel6/x86_64/mod_gearman-1.4.2-1.e.rhel6.x86_64.rpm
rpm -ivh gearmand-0.25-1.rhel6.x86_64.rpm mod_gearman-1.4.2-1.e.rhel6.x86_64.rpm
</code></pre></div>
<p>除了图中列出的几行关键配置以外，还有两个地方是需要修改的：</p>
<h3 id="gearmand-">gearmand 的监听</h3>
<p>OMD 安装的 gearmand 默认是监听在 127.0.0.1 上的，需要修改<code>/omd/sites/cdn-monitor/etc/mod-gearman/port.conf</code> 文件变成可以被其他机器访问的 IP 地址并重启。</p>
<p>同样 分布式的 <code>/etc/mod_gearman/mod_gearman_worker.conf</code> 里，也需要修改 server 配置并重启服务。</p>
<h3 id="encryption-">encryption 配置</h3>
<p>OMD 默认启用 encryption 并且会在 <code>/omd/sites/cdn/etc/mod-gearman/</code> 下生成 <code>secret.key</code> 文件。</p>
<p>但是 <code>mod_gearman</code> 默认开启 encryption ，却不可能知道中控端的密码，所以默认是在配置文件中指定的 <code>key=should_be_changed</code>。这里我们需要修改一致：</p>
<div class="highlight"><pre><code class="bash">scp nagios:/omd/sites/cdn/etc/mod-gearman/secret.key /etc/mod_gearman/
sed <span class="s1">&#39;s!#keyfile.*!keyfile=/etc/mod_gearman/secret.key!&#39;</span> /etc/mod_gearman/mod_gearman_worker.conf
service mod_gearman_worker restart
</code></pre></div>
<p>事情还没完。这时候你会在 webUI 上看到分配给这个 worker 的检测全部报错，退出码 127。具体内容是：&rdquo;/omd/sites/cdn-monitor/lib/nagios/plugins/check_http do not exists&rdquo;之类的话。</p>
<p>因为，在 OMD 上，commands.cfg 上，配置的 <code>$USER1$/check_http</code> 替换为具体路径后，直接 <code>add_task</code> 到 gearmand 里，所以 worker 上收到 command 并执行也就是这样的了。目前还没有发现可以在 worker 端替换 commands 字符串的简单办法。所以，我们还得自己创建一个软链接：</p>
<div class="highlight"><pre><code class="bash">mkdir -p /omd/sites/cdn-monitor/lib/nagios/
yum install -y nagios-plugins-all --enablerepo<span class="o">=</span>epel
ln -s /usr/lib64/nagios/plugins /omd/sites/cdn-monitor/lib/nagios/plugins
</code></pre></div>
<p>OK，现在这个机房(即nagios配置中的hostgroup)的监测任务，就都分发给本机房的 worker 来进行了。比如 <code>check_http</code> 任务，可以看到原先跨机房访问带来的几十毫秒的延时，都变成了一两毫秒。</p>
      <a href="/2013/03/27/distributed-nagios-by-mod-gearman" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/03/18/logrotate-configuration-files-mode" title="logrotate 配置文件强制为 0644 属性" rel="bookmark">logrotate 配置文件强制为 0644 属性</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-03-18 00:00:00 +0800">18 Mar 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#linux-ref" title="linux" rel="category tag">linux</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>在一次包更新后，发现 Nginx 服务器的每晚日志切割不再进行了。找遍了各种地方，最后在一次偶然的<code>ls -l</code>中发现：</p>
<div class="highlight"><pre><code class="bash"><span class="c"># ll /etc/logrotate.d/</span>
total 64
-rw-r--r-- 1 root root  326 2012-08-04 06:08 apache2
-rw-r--r-- 1 root root   84 2009-02-08 05:18 apt
-rw-r--r-- 1 root root   79 2008-12-05 17:15 aptitude
-rw-r--r-- 1 root root  330 2008-03-08 05:36 atop
-rw-r--r-- 1 root root  232 2011-11-10 14:33 dpkg
-rw-r--r-- 1 root root  267 2013-01-31 13:20 foreman-proxy
-rw-r--r-- 1 root root  151 2007-09-29 19:23 iptraf
-rw-r--r-- 1 root root  880 2012-10-29 17:10 mysql-server
-rwxr-xr-x 1 root root  356 2012-08-05 00:17 nginx
-rw-r--r-- 1 root root 1061 2008-03-08 05:36 psaccs_atop
-rw-r--r-- 1 root root  512 2008-03-08 05:36 psaccu_atop
-rw-r--r-- 1 root root  260 2012-06-23 00:52 rabbitmq-server
-rw-r--r-- 1 root root  126 2012-06-09 00:22 redis-server
-rw-r--r-- 1 root root  515 2012-09-27 02:40 rsyslog
-rw-r--r-- 1 root root  285 2008-11-18 21:20 stunnel4
</code></pre></div>
<p>这里的nginx多了可执行权限。于是我尝试性的执行了<code>chmod -x nginx</code>；结果居然真的恢复了。</p>
<p>这事儿说起来蛮奇怪了。于是去 <a href="https://fedorahosted.org/logrotate">https://fedorahosted.org/logrotate</a> 找来 logrotate 的源码看，结果在<code>logrotate-3.8.3/config.c</code> 里发现这么一段：</p>
<div class="highlight"><pre><code class="c"> <span class="mi">661</span>                 <span class="nf">if</span> <span class="p">((</span><span class="n">sb</span><span class="p">.</span><span class="n">st_mode</span> <span class="o">&amp;</span> <span class="mo">07533</span><span class="p">)</span> <span class="o">!=</span> <span class="mo">0400</span><span class="p">)</span> <span class="p">{</span>
 <span class="mi">662</span>                         <span class="n">message</span><span class="p">(</span><span class="n">MESS_DEBUG</span><span class="p">,</span>
 <span class="mi">663</span>                                 <span class="s">&quot;Ignoring %s because of bad file mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
 <span class="mi">664</span>                                 <span class="n">configFile</span><span class="p">);</span>
 <span class="mi">665</span>                         <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
 <span class="mi">666</span>                         <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">667</span>                 <span class="p">}</span>
</code></pre></div>
<p>只有文件权限是 0644 的时候，配置文件才会被读取！0755 的与结果是 0511，不等于 0400。相关 <code>st_mode</code> 的内容可以通过 <code>man 2 stat</code> 查看。</p>
<p>可以写一小段 perl 代码来验证：</p>
<div class="highlight"><pre><code class="perl"><span class="c1">#!/usr/bin/perl</span>
<span class="k">my</span> <span class="nv">$mode</span> <span class="o">=</span> <span class="p">(</span><span class="nb">stat</span><span class="p">(</span><span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">2</span><span class="p">];</span>
<span class="nb">printf</span> <span class="s">&quot;Permissions are %04o\n&quot;</span><span class="p">,</span> <span class="nv">$mode</span> <span class="o">&amp;</span> <span class="mo">07533</span><span class="p">;</span>
</code></pre></div>
<p>在 <a href="https://fedorahosted.org/logrotate/browser/tags/r3-8-3/CHANGES">ChangeLog</a> 里，看到如下一段话：</p>
<pre><code>2.1 -&gt; 2.2:
    - ignore nonnormal files when reading config files from a directory
    - (these were suggested and originally implemented by
      Henning Schmiedehausen)
</code></pre>
<p>不过比较早了，就懒得从历史堆里再翻为什么当初会有这么个提议了…………</p>
      <a href="/2013/03/18/logrotate-configuration-files-mode" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/03/15/puppet-provider-development" title="Puppet 自定义 Provider" rel="bookmark">Puppet 自定义 Provider</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-03-15 00:00:00 +0800">15 Mar 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>Puppet 默认提供了相当多的资源类型，不过我们还可以更进一步的扩展这个庞大的阵营。比如在 <code>package</code> 类型的资源里，我们看到 puppet 除了系统级别的<code>yum</code>,<code>apt</code>之类意外，还提供了 <code>gem</code>,<code>pip</code> 来管理 ruby 和 python 的 package。那么很自然的，我们就可以进一步扩充 <code>package</code> 来管理 perl 的 package 。只需要新加一个 provider 就可以了。</p>
<p>关于 provider 开发的原理说明，见 <a href="http://docs.puppetlabs.com/guides/provider_development.html">http://docs.puppetlabs.com/guides/provider_development.html</a>。</p>
<p>下面是 <code>/etc/puppet/modules/production/myclass/lib/puppet/provider/package/cpan.rb</code> 的内容，他会被 puppet 以 <code>pluginsync</code> 的方式下发。</p>
<div class="highlight"><pre><code class="ruby"><span class="c1"># 加载父类，这里是扩展 package 功能</span>
<span class="nb">require</span> <span class="s1">&#39;puppet/provider/package&#39;</span>
<span class="ss">Puppet</span><span class="p">:</span><span class="ss">:Type</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="ss">:package</span><span class="p">)</span><span class="o">.</span><span class="n">provide</span> <span class="ss">:cpan</span><span class="p">,</span> <span class="ss">:parent</span> <span class="o">=&gt;</span> <span class="ss">Puppet</span><span class="p">:</span><span class="ss">:Provider</span><span class="o">::</span><span class="no">Package</span> <span class="k">do</span>
  <span class="n">desc</span> <span class="s2">&quot;CPAN modules support.  You can pass any `source` which `cpanm` support, </span>
<span class="s2">    like URL, git repos and local tar.gz. If source is not present at all,</span>
<span class="s2">    the module will be installed from the default CPAN source.</span>
<span class="s2">    You must install App::cpanminus, App::pmodinfo, App::pmuninstall before.&quot;</span>
  <span class="n">has_feature</span> <span class="ss">:versionable</span>
  <span class="c1"># 下面这个是 Puppet::Provider 提供的私有方法，用来指定类内部适用的系统命令</span>
  <span class="c1"># puppet agent 会通过对这个的运行测试来确认该 provider 是否适用于本机</span>
  <span class="c1"># 所以在使用这个 provider 之前，要先通过其他方式在 node 上安装好这三个命令</span>
  <span class="n">commands</span> <span class="ss">:cpanmcmd</span> <span class="o">=&gt;</span> <span class="s2">&quot;cpanm&quot;</span>
  <span class="n">commands</span> <span class="ss">:pmodinfocmd</span> <span class="o">=&gt;</span> <span class="s2">&quot;pmodinfo&quot;</span>
  <span class="n">commands</span> <span class="ss">:pmuninstallcmd</span> <span class="o">=&gt;</span> <span class="s2">&quot;pm-uninstall&quot;</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">pmodlist</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
    <span class="n">pmodlist_command</span> <span class="o">=</span> <span class="o">[</span><span class="n">command</span><span class="p">(</span><span class="ss">:pmodinfocmd</span><span class="p">),</span><span class="o">]</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">[</span><span class="ss">:local</span><span class="o">]</span>
      <span class="n">pmodlist_command</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;-l&quot;</span>
    <span class="k">else</span>
      <span class="n">pmodlist_command</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;-c&quot;</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="nb">name</span> <span class="o">=</span> <span class="n">options</span><span class="o">[</span><span class="ss">:justme</span><span class="o">]</span>
      <span class="n">pmodlist_command</span> <span class="o">&lt;&lt;</span> <span class="nb">name</span>
      <span class="c1"># execute 是 Puppet::Util::Execution 提供的方法，接受数组传入，输出标准输出结果字符串</span>
      <span class="n">list</span> <span class="o">=</span> <span class="o">[</span><span class="n">execute</span><span class="p">(</span><span class="n">pmodlist_command</span><span class="p">)</span><span class="o">].</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">set</span><span class="o">|</span> <span class="n">pmodsplit</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="n">reject</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">.</span><span class="n">nil?</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">list</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">pmodlist_command</span><span class="p">)</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="o">|</span><span class="n">set</span><span class="o">|</span> <span class="n">pmodsplit</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="p">}</span><span class="o">.</span><span class="n">reject</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">.</span><span class="n">nil?</span> <span class="p">}</span>
    <span class="k">end</span>
    <span class="k">if</span> <span class="nb">name</span> <span class="o">=</span> <span class="n">options</span><span class="o">[</span><span class="ss">:justme</span><span class="o">]</span>
      <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="n">shift</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">list</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">pmodsplit</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">desc</span> <span class="o">=~</span> <span class="sr">/^(\S+) version is (.+)\.(\n  Last cpan version: (.+))?/</span>
      <span class="nb">name</span> <span class="o">=</span> <span class="vg">$1</span>
      <span class="c1"># 整个rb是从gem.rb复制过来的，gem list -r所有版本列成一行，split成一个数组</span>
      <span class="c1"># 这里为了改动少点，就照样做成数组</span>
      <span class="n">versions</span> <span class="o">=</span> <span class="o">[</span><span class="vg">$2</span><span class="o">]</span>
      <span class="k">if</span> <span class="n">latest_version</span> <span class="o">=</span> <span class="vg">$3</span>
        <span class="n">versions</span><span class="o">.</span><span class="n">unshift</span><span class="p">(</span><span class="vg">$4</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="p">{</span>
        <span class="ss">:name</span>     <span class="o">=&gt;</span> <span class="nb">name</span><span class="p">,</span>
        <span class="ss">:ensure</span>   <span class="o">=&gt;</span> <span class="n">versions</span><span class="p">,</span>
        <span class="ss">:provider</span> <span class="o">=&gt;</span> <span class="ss">:cpan</span>
      <span class="p">}</span>
    <span class="k">else</span>
      <span class="no">Puppet</span><span class="o">.</span><span class="n">warning</span> <span class="s2">&quot;Could not match </span><span class="si">#{</span><span class="n">desc</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">unless</span> <span class="n">desc</span><span class="o">.</span><span class="n">chomp</span><span class="o">.</span><span class="n">empty?</span>
      <span class="kp">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="c1"># 这个 instances 方法是 provider 必须提供，在package里就是本地模块的列表</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">instances</span><span class="p">(</span><span class="n">justme</span> <span class="o">=</span> <span class="kp">false</span><span class="p">)</span>
    <span class="n">pmodlist</span><span class="p">(</span><span class="ss">:local</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span> <span class="k">do</span> <span class="o">|</span><span class="nb">hash</span><span class="o">|</span>
      <span class="kp">new</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="c1"># 往下的方法都是 package 要求提供的</span>
  <span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="n">useversion</span> <span class="o">=</span> <span class="kp">true</span><span class="p">)</span>
    <span class="n">command</span> <span class="o">=</span> <span class="o">[</span><span class="n">command</span><span class="p">(</span><span class="ss">:cpanmcmd</span><span class="p">)</span><span class="o">]</span>
    <span class="c1"># cpanm 指定安装版本的命令格式是这样： cpanm Dancer@1.000</span>
    <span class="n">resource</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span> <span class="o">+=</span> <span class="s1">&#39;@&#39;</span> <span class="o">+</span> <span class="n">resource</span><span class="o">[</span><span class="ss">:ensure</span><span class="o">]</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">resource</span><span class="o">[</span><span class="ss">:ensure</span><span class="o">].</span><span class="n">is_a?</span> <span class="no">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">useversion</span>
    <span class="n">command</span> <span class="o">&lt;&lt;</span> <span class="n">resource</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">fail</span> <span class="s2">&quot;Could not install: </span><span class="si">#{</span><span class="n">output</span><span class="o">.</span><span class="n">chomp</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="s2">&quot;failed&quot;</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">latest</span>
    <span class="n">pmodinfo_options</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:justme</span> <span class="o">=&gt;</span> <span class="n">resource</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span><span class="p">}</span>
    <span class="nb">hash</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">pmodlist</span><span class="p">(</span><span class="n">pmodlist_options</span><span class="p">)</span>
    <span class="c1"># 这里就是前面要用数组的原因了</span>
    <span class="nb">hash</span><span class="o">[</span><span class="ss">:ensure</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span>
  <span class="k">end</span>
  <span class="c1"># 请求本地是否存在具体某个包</span>
  <span class="k">def</span> <span class="nf">query</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">pmodlist</span><span class="p">(</span><span class="ss">:justme</span> <span class="o">=&gt;</span> <span class="n">resource</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span><span class="p">,</span> <span class="ss">:local</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">uninstall</span>
    <span class="n">pmuninstallcmd</span> <span class="n">resource</span><span class="o">[</span><span class="ss">:name</span><span class="o">]</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">update</span>
    <span class="nb">self</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>在一台没有安装 cpanm 等命令的主机上运行 <code>puppet agent --debug</code>，可以看到这么一行输出：</p>
<pre><code>debug: Puppet::Type::Package::ProviderCpan: file cpanm does not exist
</code></pre>
      <a href="/2013/03/15/puppet-provider-development" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/03/14/JPush-example" title="极光推送demo" rel="bookmark">极光推送demo</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-03-14 00:00:00 +0800">14 Mar 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>之前已经陆续写过很多种告警的方式。今天再稍微试验一种更新潮一些的 —— 手机推送通知。原先我的想法是移植 HTML5 的 websocket + notification 页面到手机上。但是发现手机上的浏览器都还没有 notification 功能。即便是用 PhoneGap 包装 HTML5 应用，PhoneGap 的 notification API 也不是我想象中的状态栏通知，而是类似 js 的 alert 对话框。</p>
<p>不过这个时候我发现了极光推送。嗯，本来蛮有挑战的事情顿时变成了十分钟内解决的小菜：</p>
<p>整个过程如下：</p>
<h3 id="section">注册帐号</h3>
<p>官网地址: <a href="http://jpush.cn">http://jpush.cn</a></p>
<h3 id="section-1">新建应用</h3>
<p>都是纯页面操作，填写应用名称而已。</p>
<h3 id="example-">下载 example 包</h3>
<p>在应用详情里有下载链接。</p>
<h3 id="adt-eclipse--example">用 adt eclipse 打开 example</h3>
<p>adt eclipse 直接从 android 官网下载 adt-bundle-linux-x86-20130219.tar.gz 解压即可运行。更多配置见 android 官网说明。</p>
<p>然后在 File 菜单栏选择 new -&gt; android application project 就可以新建自己的项目。然后创建自己的 workspace，把下好的 JPush example 包解压倒入workspace，然后就可以 run 了。</p>
<p>不过这里 run 会启动一个 android 虚拟机，很可能是连不上网的，原因似乎是 android vm 默认是 10.0.0.0 网段。</p>
<p>其实这时候我们会在 <code>workspace/push-example/bin/</code> 下发现一个 <code>push-example.apk</code> 文件。复制出来，通过豌豆荚或者别的什么工具直接装进自己手机就可以运行了。</p>
<h3 id="section-2">测试页面发送通知</h3>
<p>在极光的 portal 页面 <a href="http://www.jpush.cn/apps/${your app key}/notification">http://www.jpush.cn/apps/${your app key}/notification</a> 上可以直接提交通知内容。然后你就可以在手机状态栏通知上看到啦！</p>
<h3 id="section-3">测试命令行发送通知</h3>
<p>文档见<a href="http://docs.jpush.cn/pages/viewpage.action?pageId=2621796">http://docs.jpush.cn/pages/viewpage.action?pageId=2621796</a>。</p>
<p>比如通过简易通知推送接口发送如下：</p>
<div class="highlight"><pre><code class="bash">    <span class="c">#!/bin/sh</span>
    <span class="c">#下面两个是你新建应用后就分配的</span>
    <span class="nv">APP_KEY</span><span class="o">=</span><span class="nv">$1</span>
    <span class="nv">API_MasterSecret</span><span class="o">=</span><span class="nv">$2</span>
    <span class="c">#自赠序列号，这个最好是通过mysql的auto_increment管理</span>
    <span class="nv">sendno</span><span class="o">=</span>2
    <span class="c">#这里有1,2,3,4,分别对应对指定IMEI/tag/alias/all的用户推送</span>
    <span class="nv">receiver_type</span><span class="o">=</span>4
    <span class="nv">verification_code</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> -ne <span class="s2">&quot;$sendno$receiver_type$API_MasterSecret&quot;</span> | md5sum | awk <span class="s1">&#39;{print $1}&#39;</span><span class="sb">`</span>
    <span class="c">#platform包括android,ios等等，可以用逗号分开写多个</span>
    curl http://api.jpush.cn:8800/sendmsg/v2/notification -d <span class="s2">&quot;sendno=${sendno}&amp;app_key=${APP_KEY}&amp;receiver_type=${receiver_type}&amp;platform=android&amp;txt=123&amp;verification_code=${verification_code}&quot;</span>
</code></pre></div>
<p>然后收到如下响应：</p>
<div class="highlight"><pre><code class="bash">    <span class="o">{</span><span class="s2">&quot;sendno&quot;</span> :<span class="s2">&quot;2&quot;</span>, <span class="s2">&quot;errcode&quot;</span>:0,  <span class="s2">&quot;errmsg&quot;</span>:<span class="s2">&quot;Succeed&quot;</span><span class="o">}</span>
</code></pre></div>
<p>手机也同时响起~成功。</p>
      <a href="/2013/03/14/JPush-example" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/02/25/nginx-testing-10Gibps" title="Nginx 万兆网络环境测试" rel="bookmark">Nginx 万兆网络环境测试</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-02-25 00:00:00 +0800">25 Feb 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#testing-ref" title="testing" rel="category tag">testing</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <ul id="markdown-toc">
  <li><a href="#section">测试目标</a></li>
  <li><a href="#section-1">测试设备</a></li>
  <li><a href="#section-2">测试环境说明</a></li>
  <li><a href="#section-3">特别注意事项</a>    <ul>
      <li><a href="#keepalive">Keepalive</a></li>
      <li><a href="#rpspps">RPS、PPS与流量吞吐率</a></li>
      <li><a href="#section-4">压缩</a></li>
      <li><a href="#section-5">规则集</a></li>
      <li><a href="#section-6">实际网络情况</a></li>
    </ul>
  </li>
  <li><a href="#section-7">测试项目</a>    <ul>
      <li><a href="#section-8">测试一</a></li>
      <li><a href="#section-9">测试二</a></li>
      <li><a href="#section-10">测试三</a></li>
      <li><a href="#section-11">测试四</a></li>
      <li><a href="#section-12">测试五</a></li>
      <li><a href="#section-13">测试六</a></li>
      <li><a href="#section-14">测试七</a></li>
    </ul>
  </li>
  <li><a href="#section-15">术语及缩写说明</a></li>
  <li><a href="#section-16">附注</a></li>
</ul>
<h1 id="section">测试目标</h1>
<p>本次测试的目标是将nginx作为7层负载均衡软件，应用于万兆环境下，获得</p>
<ul>
  <li>
    <p>极限性能</p>
  </li>
  <li>
    <p>在服务质量保证约束条件下的极限性能</p>
  </li>
  <li>
    <p>提升极限性能的方法</p>
  </li>
  <li>
    <p>在万兆环境下部署的一般方法和特殊注意事项</p>
  </li>
</ul>
<p>同时，由于nginx还作为静态页面的提供者，附带还进行获得nginx作为静态文件服务器的</p>
<ul>
  <li>
    <p>极限性能</p>
  </li>
  <li>
    <p>在服务质量保证约束条件下的极限性能</p>
  </li>
  <li>
    <p>提升极限性能的方法</p>
  </li>
  <li>
    <p>在万兆环境下部署的一般方法和特殊注意事项</p>
  </li>
</ul>
<p>操作系统是一个很大的影响因素，在测试开始，会对操作系统版本进行选择，以确定哪个是更合适的平台。</p>
<h1 id="section-1">测试设备</h1>
<p>测试设备如下</p>
<ul>
  <li>
    <p>万兆网卡X520-DA2</p>
  </li>
  <li>
    <p>万兆交换机DCS-7124SX-F</p>
  </li>
  <li>
    <p>万兆DA线</p>
  </li>
  <li>
    <p>SNB服务器</p>
  </li>
  <li>
    <p>WSM服务器</p>
  </li>
</ul>
<h1 id="section-2">测试环境说明</h1>
<p>所有测试服务器连接在同一个万兆交换机下，处于同一个网段。</p>
<p>服务器划分为</p>
<ul>
  <li>
    <p>服务器（以S简称）：提供静态或动态页面，次要测试对象</p>
  </li>
  <li>
    <p>7层负载均衡（以LB简称）：提供负载均衡功能，主要测试对象</p>
  </li>
  <li>
    <p>客户端（以C简称）：提供测试压力</p>
  </li>
</ul>
<h1 id="section-3">特别注意事项</h1>
<h2 id="keepalive">Keepalive</h2>
<p>由于LB和S数量少，高RPS情况下，LB如果采用短连接方式连接S，LB的outgoing port会很快用尽。</p>
<p>解决的方法有两种：</p>
<ol>
  <li>
    <p>S采用多IP配置，模拟众多S的情况，减小每个S所要消耗的LB outgoing port；</p>
  </li>
  <li>
    <p>LB与S之间采用keepalive连接</p>
  </li>
</ol>
<p>短连接的方式下，CPU会有相当一部分消耗在三次握手上，这主要是操作系统开销（小包处理），以及nginx初始化会话上下文的开销。</p>
<h2 id="rpspps">RPS、PPS与流量吞吐率</h2>
<p>极限测试下，PPS考验服务器的CPU能力；而HTTP协议请求头的处理也是CPU密集型任务。</p>
<p>相同流量吞吐率下</p>
<ul>
  <li>
    <p>较小的响应意味着较高的RPS</p>
  </li>
  <li>
    <p>当响应小于一个最大TCP报文长度时，响应越小，也意味着PPS越高</p>
  </li>
</ul>
<p>极限测试中，需要测试以下三种情形</p>
<ul>
  <li>
    <p>全部是大报文。可以通过构造响应为一个最大TCP报文长度实现</p>
  </li>
  <li>
    <p>全部是小报文。可以通过构造响应为最小HTTP响应实现</p>
  </li>
  <li>
    <p>混合报文。可以通过构造响应为一个或两个TCP报文，一个是最大TCP报文长度，另外一个的长度可以控制，来满足特定的混合比例</p>
  </li>
</ul>
<p>流量吞吐率是一个表观指标，但我们更关心的是在带宽足够的条件下，RPS指标（的范围）。</p>
<h2 id="section-4">压缩</h2>
<p>在我们的实际使用中，LB是不负责压缩的。但测试中需要测试压缩对RPS的影响。需要考察压缩方面的优化方法。</p>
<h2 id="section-5">规则集</h2>
<p>负载均衡规则集大小对性能会有影响。由于规则集处理开销正比于RPS，测试中应对较大的规则集进行测试以找出影响大小和可能的优化措施。</p>
<h2 id="section-6">实际网络情况</h2>
<p>一般而言，极限性能是最理想情况。在本次测试中，我们还需要测试接近实际网络情况下的极限性能，这可以通过引入丢包率、延时来模拟。</p>
<h1 id="section-7">测试项目</h1>
<h2 id="section-8">测试一</h2>
<p>测试目标：了解nginx的带宽满载的最小文件大小 （web服务器模式），确定之后测试的文件大小上限</p>
<p>测试工具：ab</p>
<p>测试方法：</p>
<ol>
  <li>
    <p>S上Nginx做简单配置，使其成为web server；</p>
  </li>
  <li>
    <p>在C1上使用 <测试工具> 对S测试10000字节文件，每次减小1000字节，至带宽和RPS均为最高为止。</测试工具></p>
  </li>
  <li>
    <p>根据第二步测试情况调整文件大小，以逼近S的带宽恰好满载且CPU占用率最高时的情况，并记录最终的阈值大小和RPS/PPS指标。</p>
  </li>
</ol>
<p>测试结果：</p>
<table>
  <thead>
    <tr>
      <th><strong>文件大小(Bytes)</strong></th>
      <th><strong>CPU idle(%)</strong></th>
      <th><strong>带宽(MBps)</strong></th>
      <th style="text-align: right"><strong>PPS</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10K</td>
      <td>65</td>
      <td>1140</td>
      <td style="text-align: right">606K</td>
    </tr>
    <tr>
      <td>3K</td>
      <td>12</td>
      <td>1135</td>
      <td style="text-align: right">1060K</td>
    </tr>
    <tr>
      <td>2590</td>
      <td>0</td>
      <td>1088</td>
      <td style="text-align: right">1138K</td>
    </tr>
    <tr>
      <td>1K</td>
      <td>0</td>
      <td>585</td>
      <td style="text-align: right">783K</td>
    </tr>
  </tbody>
</table>
<p>在采用kernel的pktgen发包测试中，苏能达到的最大PPS为1200K。2590Bytes文件测试中的PPS已经很接近纯发包测试的极限，所以最终，最充
分利用CPU和带宽的文件大小是2590Bytes。</p>
<h2 id="section-9">测试二</h2>
<p>测试目标：了解 nginx 的大致性能（web服务器模式）</p>
<p>测试工具：ab</p>
<p>测试方法：</p>
<ol>
  <li>
    <p>S上Nginx做简单配置，使其成为web server；</p>
  </li>
  <li>
    <p>在C1上使用 <测试工具> 对S分别测试空文件、616字节文件(半个包长度)、1232字节文件（即含header字节数为1448，整TCP包长度）、1
233字节文件（超过一个TCP/IP包大小1字节）和2590字节文件；3. 测试中记录S的网络吞吐量和CPU状况；C1的RPS，PPS指标波动情况。</测试工具></p>
  </li>
</ol>
<p>测试预期：</p>
<ol>
  <li>
    <p>吞吐量应超过1Gbps；</p>
  </li>
  <li>
    <p>吞吐量接近5Gbps；</p>
  </li>
  <li>
    <p>适当调整网卡等其他配置，应使RPS超过50万（原有百兆环境下的极限值）。</p>
  </li>
</ol>
<p>初步测试：</p>
<p>1、在CentOS6.2系统上，十次测试平均结果发现空文件的RPS仅为458005，响应时间0.88715ms，S带宽121M，未能达到预期。</p>
<p>2、检查发现CentOS6.2的ixgbe驱动版本为3.4.8，与最新版本差距较大，升级ixgbe驱动至最新版3.11.33。</p>
<p>更新后原先的8核client已经无法压满server，更换Client设备，ab并发由50×8提高到50×24，测试不同的InterruptThrottle
Rate条件下数据如下：</p>
<p>1000：</p>
<p><img src="/images/Nginx-testing-10Gibps/c568fc0.png" alt="" /></p>
<p>1500：</p>
<p><img src="/images/Nginx-testing-10Gibps/m15b564f6.png" alt="" /></p>
<p>2500：</p>
<p><img src="/images/Nginx-testing-10Gibps/85b1bbd.png" alt="" /></p>
<p>3500：</p>
<p><img src="/images/Nginx-testing-10Gibps/335545b5.png" alt="" /></p>
<p>4500：</p>
<p><img src="/images/Nginx-testing-10Gibps/m25052f88.png" alt="" /></p>
<p>根据以上数据可知，在ITR1500的情况下，空文件的RPS最高，对比数据如下：</p>
<table>
  <thead>
    <tr>
      <th><strong>ITR</strong></th>
      <th><strong>RPS</strong></th>
      <th><strong>带宽(MBps)</strong></th>
      <th><strong>user%</strong></th>
      <th><strong>sys%</strong></th>
      <th style="text-align: right"><strong>irq%</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1000</td>
      <td>688425</td>
      <td>186.886</td>
      <td>30.112</td>
      <td>52.936</td>
      <td style="text-align: right">16.951</td>
    </tr>
    <tr>
      <td>1500</td>
      <td>691614</td>
      <td>187.408</td>
      <td>30.125</td>
      <td>52.208</td>
      <td style="text-align: right">17.667</td>
    </tr>
    <tr>
      <td>2500</td>
      <td>682326</td>
      <td>183.277</td>
      <td>29.191</td>
      <td>53.253</td>
      <td style="text-align: right">17.556</td>
    </tr>
    <tr>
      <td>3500</td>
      <td>650367</td>
      <td>175.477</td>
      <td>26.803</td>
      <td>56.732</td>
      <td style="text-align: right">16.382</td>
    </tr>
    <tr>
      <td>4500</td>
      <td>630178</td>
      <td>169.474</td>
      <td>26.417</td>
      <td>56.708</td>
      <td style="text-align: right">16.833</td>
    </tr>
  </tbody>
</table>
<p>（注：表格中RPS和带宽数据均为峰值，CPU数据为平稳运行期的中间时刻采样值。下同）</p>
<p>所以在新驱动ITR1500的条件下，重新测试616,1232,1233,2590字节的数据：</p>
<p>616：</p>
<p><img src="/images/Nginx-testing-10Gibps/m2c94d5e6.png" alt="" /></p>
<p>1232：</p>
<p><img src="/images/Nginx-testing-10Gibps/3bd4c0bf.png" alt="" /></p>
<p>1233：</p>
<p><img src="/images/Nginx-testing-10Gibps/m1cb568d3.png" alt="" /></p>
<p>2590</p>
<p><img src="/images/Nginx-testing-10Gibps/m73a60e04.png" alt="" /></p>
<p>测试过程出现剧烈的吞吐量波动，在原有的itr1500的条件下服务极不稳定。</p>
<p>总结ITR1500条件下各文件大小的测试数据对比如下：</p>
<table>
  <thead>
    <tr>
      <th>文件大小(Btyes)</th>
      <th>RPS</th>
      <th><strong>带宽(MBps)</strong></th>
      <th>CPU usr%</th>
      <th>CPU sys%</th>
      <th style="text-align: right">CPU irq%</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>691614</td>
      <td>187.408</td>
      <td>30.125</td>
      <td>52.208</td>
      <td style="text-align: right">17.667</td>
    </tr>
    <tr>
      <td>616</td>
      <td>586296</td>
      <td>459.435</td>
      <td>29.583</td>
      <td>54.250</td>
      <td style="text-align: right">16.083</td>
    </tr>
    <tr>
      <td>1232</td>
      <td>579103</td>
      <td>838.146</td>
      <td>29.471</td>
      <td>50.563</td>
      <td style="text-align: right">16.048</td>
    </tr>
    <tr>
      <td>1233</td>
      <td>513099</td>
      <td>772.826</td>
      <td>28.417</td>
      <td>48.875</td>
      <td style="text-align: right">22.708</td>
    </tr>
    <tr>
      <td>2590</td>
      <td>418226</td>
      <td>1173.760</td>
      <td>23.343</td>
      <td>41.934</td>
      <td style="text-align: right">18.216</td>
    </tr>
  </tbody>
</table>
<p>另经测试，ITR上调到15000后，2590字节文件测试的S吞吐量恢复成稳定满带宽运行。而且支持并发到80×24。对比ITR5000/10000/15000
条件下数据：</p>
<p>ITR5000图</p>
<p><img src="/images/Nginx-testing-10Gibps/m7333a2.png" alt="" /></p>
<p>ITR10000图：</p>
<p><img src="/images/Nginx-testing-10Gibps/m7721129e.png" alt="" /></p>
<p>ITR15000图：</p>
<p><img src="/images/Nginx-testing-10Gibps/a58a533.png" alt="" /></p>
<p>2.59KB文件在不同ITR下的测试数据对比如下：</p>
<table>
  <thead>
    <tr>
      <th>ITR</th>
      <th>RPS</th>
      <th><strong>带宽(MBps)</strong></th>
      <th>usr%</th>
      <th>sys%</th>
      <th>irq%</th>
      <th style="text-align: right">错误进程</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1500</td>
      <td>418226</td>
      <td>1173.760</td>
      <td>23.343</td>
      <td>41.934</td>
      <td>18.216</td>
      <td style="text-align: right">6</td>
    </tr>
    <tr>
      <td>5000</td>
      <td>418216</td>
      <td>1172.530</td>
      <td>24.250</td>
      <td>55.792</td>
      <td>19.667</td>
      <td style="text-align: right">3</td>
    </tr>
    <tr>
      <td>10000</td>
      <td>417989</td>
      <td>1171.960</td>
      <td>24.625</td>
      <td>52.958</td>
      <td>22.292</td>
      <td style="text-align: right">2</td>
    </tr>
    <tr>
      <td>15000</td>
      <td>404330</td>
      <td>1132.490</td>
      <td>23.802</td>
      <td>52.855</td>
      <td>23.343</td>
      <td style="text-align: right">0</td>
    </tr>
  </tbody>
</table>
<h2 id="section-10">测试三</h2>
<p>测试目标：了解nginx配置对性能的影响(access_log)</p>
<p>测试工具：ab</p>
<p>测试方法：</p>
<ol>
  <li>
    <p>S上做简单配置，关闭 access_log 后进行测试；</p>
  </li>
  <li>
    <p>再测试关闭 access_log buffer 的情况（对比测试二的 access_log buffer=1024k 的情况）</p>
  </li>
  <li>
    <p>在C1上使用 <测试工具> 对S分别测试空文件(ITR为1500)</测试工具></p>
  </li>
  <li>
    <p>测试中记录CPU占用率，网络吞吐量，RPS和平均响应时间指标</p>
  </li>
</ol>
<p>测试结果：</p>
<p>1、设置<code>access_log /data/access_log main;</code>的情况：</p>
<p>与关闭日志相比，吞吐量下降，并且无法支持相同数并发（平均有20%的ab进程退出），只能在30×24的并发数情况下完成稳定测试。</p>
<p><img src="/images/Nginx-testing-10Gibps/604d3126.png" alt="" /></p>
<p>2、将日志写入SSD磁盘，验证是否有性能提升。</p>
<p><img src="/images/Nginx-testing-10Gibps/m34c0cd58.png" alt="" /></p>
<p>由上两图对比，可见虽然将日志写入SSD对RPS稍有提升，但离关闭日志的70万差距甚远，更换SSD没有实质的意义。</p>
<p>3、普通磁盘上设置buffer=1024k参数</p>
<p><img src="/images/Nginx-testing-10Gibps/5637f0f7.png" alt="" /></p>
<p>4、设置buffer=64k参数</p>
<p><img src="/images/Nginx-testing-10Gibps/m3d18099f.png" alt="" /></p>
<p>5、设置buffer=4k参数</p>
<p><img src="/images/Nginx-testing-10Gibps/m160f2f0b.png" alt="" /></p>
<p>可见在使用buffer参数后，RPS明显提升到和关闭日志时一个数量级的水准。而buffer的大小，从4k到1024k，也可以提高10%左右。</p>
<p>测试三各项数据对比如下：</p>
<table>
  <thead>
    <tr>
      <th><strong>配置</strong></th>
      <th><strong>RPS</strong></th>
      <th><strong>带宽(MBps)</strong></th>
      <th><strong>Usr%</strong></th>
      <th><strong>Sys%</strong></th>
      <th><strong>irq%</strong></th>
      <th style="text-align: right"><strong>稳定并发</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>关闭日志</td>
      <td>691614</td>
      <td>187.408</td>
      <td>30.125</td>
      <td>52.208</td>
      <td>17.667</td>
      <td style="text-align: right">50*24</td>
    </tr>
    <tr>
      <td>打开日志</td>
      <td>180148</td>
      <td>49.074</td>
      <td>8.966</td>
      <td>21.337</td>
      <td>4.483</td>
      <td style="text-align: right">30*24</td>
    </tr>
    <tr>
      <td>使用SSD</td>
      <td>144347</td>
      <td>39.179</td>
      <td>10.875</td>
      <td>25.708</td>
      <td>5.750</td>
      <td style="text-align: right">30*24</td>
    </tr>
    <tr>
      <td>buffer4K</td>
      <td>588767</td>
      <td>159.297</td>
      <td>27.613</td>
      <td>55.352</td>
      <td>16.951</td>
      <td style="text-align: right">50*24</td>
    </tr>
    <tr>
      <td>buffer64K</td>
      <td>593022</td>
      <td>160.172</td>
      <td>26.845</td>
      <td>57.065</td>
      <td>16.048</td>
      <td style="text-align: right">50*24</td>
    </tr>
    <tr>
      <td>buffer1M</td>
      <td>659290</td>
      <td>177.959</td>
      <td>32.042</td>
      <td>51.875</td>
      <td>16.000</td>
      <td style="text-align: right">50*24</td>
    </tr>
  </tbody>
</table>
<h2 id="section-11">测试四</h2>
<p>测试目标：了解nginx配置对性能的影响(tcp_nopush off)</p>
<p>测试工具：ab</p>
<p>测试方法：</p>
<ol>
  <li>
    <p>S上做简单配置，同时关闭tcp_nopush off;</p>
  </li>
  <li>
    <p>在C1上使用 <测试工具> 对S分别测试1232字节文件和1233字节文件</测试工具></p>
  </li>
  <li>
    <p>测试中记录网络吞吐量，RPS和PPS指标</p>
  </li>
</ol>
<p>测试预期：</p>
<p>根据对TCP_NOPUSH的理解，在关闭此参数的情况下，1232字节文件的rps应该和开启状态下有较大差别。</p>
<p>测试结果：</p>
<p>1232字节文件数据：</p>
<p>当ITR为1500时：</p>
<p><img src="/images/Nginx-testing-10Gibps/51d7bf66.png" alt="" /></p>
<p>峰值带宽比测试二中的数据稍差，但是运行不稳定，CPU的波动与rps图相对应，尝试加大并发则有client进程出现connection timeout错误。</p>
<p>加大itr到15000后波动变的比较稳定。但RPS下降到40万，与测试二相差接近30%。数据如下：</p>
<p><img src="/images/Nginx-testing-10Gibps/m21d6c756.png" alt="" /></p>
<p>该项测试相关数据对比如下：</p>
<table>
  <thead>
    <tr>
      <th><strong>配置</strong></th>
      <th><strong>RPS</strong></th>
      <th><strong>带宽(MBps)</strong></th>
      <th><strong>Usr%</strong></th>
      <th><strong>Sys%</strong></th>
      <th><strong>Irq%</strong></th>
      <th style="text-align: right"><strong>退出进程</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>tcp_nopush on+ITR1500</td>
      <td>579103</td>
      <td>838.146</td>
      <td>29.471</td>
      <td>50.563</td>
      <td>16.048</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td>tcp_nopush off+ITR1500</td>
      <td>543050</td>
      <td>817.746</td>
      <td>27.095</td>
      <td>51.438</td>
      <td>21.467</td>
      <td style="text-align: right">1</td>
    </tr>
    <tr>
      <td>tcp_nopush off+ITR15000</td>
      <td>393416</td>
      <td>593.411</td>
      <td>22.458</td>
      <td>55.583</td>
      <td>21.958</td>
      <td style="text-align: right">0</td>
    </tr>
  </tbody>
</table>
<h2 id="section-12">测试五</h2>
<p>测试目标：了解nginx的大致性能（代理模式）</p>
<p>测试工具：ab</p>
<p>测试方法：</p>
<ol>
  <li>
    <p>S上nginx做简单配置，使其成为webserver，作为后端；</p>
  </li>
  <li>
    <p>LB上nginx做简单配置，使其成为L7 HTTP 代理，所有请求代理至S。LB后端keepalive在测试中测试两种情况，即打开和关闭</p>
  </li>
  <li>
    <p>在C1/C2上使用 <测试工具> 对LB分别测试空文件、1232字节文件和2590字节文件</测试工具></p>
  </li>
  <li>
    <p>测试中记录S和LB的CPU占用率，网络吞吐量，RPS三个指标</p>
  </li>
</ol>
<p>测试预期：</p>
<ol>
  <li>
    <p>Keepalive关闭时，可能需要对LB的内核参数进行调整才能够完成测试；</p>
  </li>
  <li>
    <p>Keepalive关闭时，仅调整内核参数可能不够，S需绑定多个IP地址，LB需使用S的多个IP地址；</p>
  </li>
</ol>
<p>测试结果：</p>
<p>（注：因为C1/C2的主板架构/CPU配置不一。8核的C2会先于24核的C1结束测试，后半段数据不如前半段稳定，不过单C1运行也基本可以逼近LB极限，不影响
数据采集和判断。）</p>
<p>1、空文件：</p>
<p><img src="/images/Nginx-testing-10Gibps/m45af05e8.png" alt="" /></p>
<p>2、1232字节文件</p>
<p><img src="/images/Nginx-testing-10Gibps/4687c6d4.png" alt="" /></p>
<p>3、2590字节文件</p>
<p><img src="/images/Nginx-testing-10Gibps/m449464d4.png" alt="" /></p>
<p>4、10K字节文件</p>
<p><img src="/images/Nginx-testing-10Gibps/m3622cdb6.png" alt="" /></p>
<p>根据测试二的经验，非空文件ITR为15000时表现更稳定，修改后数据如下：</p>
<p>1、1232字节：</p>
<p><img src="/images/Nginx-testing-10Gibps/9098f14.png" alt="" /></p>
<p>2、2590字节：</p>
<p><img src="/images/Nginx-testing-10Gibps/m7d14ebde.png" alt="" /></p>
<p>3、10k字节文件</p>
<p><img src="/images/Nginx-testing-10Gibps/278a77c9.png" alt="" /></p>
<p>4、100k字节文件</p>
<p><img src="/images/Nginx-testing-10Gibps/ffd255.png" alt="" /></p>
<p>关闭proxy_keepalive，使用2台Client测试，并发2400。空文件测试带宽只能压到18MBps，LB和S的CPU
idle都在85%以上。平均响应时间长达40ms。限于环境，压力测试无法继续进行。</p>
<p>本测试proxy_keepalive情况时各项数据对比如下：</p>
<table>
  <thead>
    <tr>
      <th><strong>ITR+文件大小</strong></th>
      <th><strong>RPS</strong></th>
      <th><strong>带宽(MBps)</strong></th>
      <th><strong>Usr%</strong></th>
      <th><strong>Sys%</strong></th>
      <th style="text-align: right"><strong>Irq%</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ITR1500+0Byte</td>
      <td>392406</td>
      <td>165.185</td>
      <td>39.533</td>
      <td>26.647</td>
      <td style="text-align: right">30.234</td>
    </tr>
    <tr>
      <td>ITR1500+1232Bytes</td>
      <td>369582</td>
      <td>588.209</td>
      <td>41.142</td>
      <td>28.595</td>
      <td style="text-align: right">28.929</td>
    </tr>
    <tr>
      <td>ITR1500+2590Bytes</td>
      <td>296866</td>
      <td>898.885</td>
      <td>34.250</td>
      <td>29.417</td>
      <td style="text-align: right">36.167</td>
    </tr>
    <tr>
      <td>ITR1500+10KBytes</td>
      <td>118163</td>
      <td>1167.280</td>
      <td>17.870</td>
      <td>18.319</td>
      <td style="text-align: right">15.218</td>
    </tr>
    <tr>
      <td>ITR15000+1232Bytes</td>
      <td>370590</td>
      <td>588.422</td>
      <td>41.167</td>
      <td>28.375</td>
      <td style="text-align: right">29.208</td>
    </tr>
    <tr>
      <td>ITR15000+2590Bytes</td>
      <td>297289</td>
      <td>897.755</td>
      <td>34.890</td>
      <td>28.429</td>
      <td style="text-align: right">35.682</td>
    </tr>
    <tr>
      <td>ITR15000+10KBytes</td>
      <td>118033</td>
      <td>1168.160</td>
      <td>21.137</td>
      <td>21.426</td>
      <td style="text-align: right">25.752</td>
    </tr>
    <tr>
      <td>ITR15000+100KBytes</td>
      <td>11388</td>
      <td>1168.890</td>
      <td>4.798</td>
      <td>12.542</td>
      <td style="text-align: right">10.522</td>
    </tr>
  </tbody>
</table>
<h2 id="section-13">测试六</h2>
<p>测试目标：nginx LB在多域名情况下的性能</p>
<p>测试工具：ab</p>
<p>测试方法：</p>
<p>1、S上nginx做简单配置，使其成为webserver，作为后端；</p>
<p>2、LB上nginx使用我司实际代理配置(800+域名)，使其成为L7 HTTP
代理，所有请求代理至S。LB后端keepalive在测试中测试两种情况，即打开和关闭</p>
<p>3、在C1上使用 <测试工具> 对LB分别测试单域名和随机多域名空文件请求</测试工具></p>
<p>4、测试中记录S和LB的CPU占用率，网络吞吐量，RPS三个指标</p>
<p>测试预期：</p>
<p>多域名代理情况下性能应和直接通过IP访问在一个数量级内。</p>
<p>测试结果：</p>
<p>1、单域名：</p>
<p><img src="/images/Nginx-testing-10Gibps/m76022a04.png" alt="" /></p>
<p>2、随机域名。因为测试在2台服务器上一共开启了32个ab进程，即随机选出32个域名做的测试，结果如下：</p>
<p><img src="/images/Nginx-testing-10Gibps/41f8c534.png" alt="" /></p>
<p>3、关闭keepalive的情况：</p>
<p><img src="/images/Nginx-testing-10Gibps/m6f56712d.png" alt="" /></p>
<p>可见代理模式使用多个domain和upstream配置，对性能没有太大影响。有影响的依然是keepalive是否开启。具体数据对比如下：</p>
<table>
  <thead>
    <tr>
      <th><strong>测试条件</strong></th>
      <th><strong>RPS</strong></th>
      <th><strong>带宽(MBps)</strong></th>
      <th><strong>Usr%</strong></th>
      <th><strong>Sys%</strong></th>
      <th style="text-align: right"><strong>Irq%</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IP访问</td>
      <td>392406</td>
      <td>165.185</td>
      <td>39.533</td>
      <td>26.647</td>
      <td style="text-align: right">30.234</td>
    </tr>
    <tr>
      <td>单域名</td>
      <td>377292</td>
      <td>179.832</td>
      <td>41.091</td>
      <td>26.811</td>
      <td style="text-align: right">29.559</td>
    </tr>
    <tr>
      <td>多域名</td>
      <td>384513</td>
      <td>185.632</td>
      <td>43.297</td>
      <td>27.186</td>
      <td style="text-align: right">28.185</td>
    </tr>
    <tr>
      <td>No keepalive</td>
      <td>34879</td>
      <td>28.310</td>
      <td>5.973</td>
      <td>7.341</td>
      <td style="text-align: right">9.083</td>
    </tr>
  </tbody>
</table>
<h2 id="section-14">测试七</h2>
<p>测试目标：其他常见server性能对比</p>
<p>测试工具：ab</p>
<p>测试方法：</p>
<p>Resin4pro加临时lisence，默认配置(关闭日志)，测试空文件。</p>
<p>测试结果：</p>
<p><img src="/images/Nginx-testing-10Gibps/m2e7e1790.png" alt="" /></p>
<p>与nginx的webserver模式对比如下：</p>
<table>
  <thead>
    <tr>
      <th><strong>Webserver</strong></th>
      <th><strong>RPS</strong></th>
      <th><strong>带宽(MBps)</strong></th>
      <th><strong>Usr%</strong></th>
      <th><strong>Sys%</strong></th>
      <th style="text-align: right"><strong>Irq%</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>resin4</td>
      <td>44873</td>
      <td>32.353</td>
      <td>3.884</td>
      <td>4.545</td>
      <td style="text-align: right">10.455</td>
    </tr>
    <tr>
      <td>Nginx1.2</td>
      <td>691614</td>
      <td>187.408</td>
      <td>30.125</td>
      <td>52.208</td>
      <td style="text-align: right">17.667</td>
    </tr>
  </tbody>
</table>
<h1 id="section-15">术语及缩写说明</h1>
<p>RPS: Requests per Second，每秒请求数</p>
<p>PPS: Packets per second，每秒报文数</p>
<h1 id="section-16">附注</h1>
<p>生成图片的 GNUplot 脚本见<a href="http://chenlinux.com/2012/11/22/gnuplot-to-draw-multi-graph">http://chenlinux.com/2012/11/22/gnuplot-to-draw-multi-graph</a>。</p>
      <a href="/2013/02/25/nginx-testing-10Gibps" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/02/22/setup-stf2" title="STF 2.0 安装测试" rel="bookmark">STF 2.0 安装测试</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-02-22 00:00:00 +0800">22 Feb 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#perl-ref" title="perl" rel="category tag">perl</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>STF 更新到 2.0 版本，支持使用 redis 队列做任务分发，比原先的 Q4M 容易上手多了；新增了 cluster 概念，虽然目前看没什么用，不过估计以后肯定要在这方面做文章的。</p>
<p>部署步骤如下：</p>
<div class="highlight"><pre><code class="bash">    <span class="c"># 因为 stf 要求在 Perl5.12 以上运行，CentOS6 还是 5.10 的老版本，所以直接用 Debian 测试了</span>
    apt-get install -y memcached redis-server libmysqlclient-dev libdbd-mysql-perl
    <span class="c"># 设置 mysql-server 包安装时需要的问答</span>
    <span class="nb">echo </span>mysql-server-5.5 mysql-server/root_password <span class="k">select </span>123456 | debconf-set-selections
    <span class="nb">echo </span>mysql-server-5.5 mysql-server/root_password_again <span class="k">select </span>123456 | debconf-set-selections
    apt-get install mysql-server-5.5
    <span class="c"># 系统依赖解决，开始 perl 部分</span>
    git clone git://github.com/stf-storage/stf.git
    <span class="nb">cd </span>stf
    cpanm Redis Data::Dumper::Concise
    cpanm --installdeps .
    <span class="c"># 创建 mysql 库和用户</span>
    mysql -uroot -p -e <span class="s1">&#39;create database stf&#39;</span>
    mysql -uroot -p -e <span class="s1">&#39;grant all privileges on stf.* to stf@&quot;%&quot; identified by &quot;654321&quot;&#39;</span>
    <span class="c"># 默认监听本机，分布式系统肯定是要放开这个的</span>
    sed -i <span class="s1">&#39;s/127.0.0.1/0.0.0.0/&#39;</span> /etc/mysql/my.cnf
    service mysql restart
    <span class="c"># 导入 sql 建表</span>
    mysql -ustf -p stf &lt; misc/stf.sql
    <span class="c"># 给 worker 和 dispatcher 设置队列使用 redis</span>
    <span class="nb">export </span><span class="nv">STF_QUEUE_TYPE</span><span class="o">=</span>Redis
    <span class="nb">export </span><span class="nv">STF_REDIS_HOSTPORT</span><span class="o">=</span>192.168.0.101:6379
    <span class="c"># 所有的角色都要有自己独有的 hostid</span>
    <span class="nb">export </span><span class="nv">STF_HOST_ID</span><span class="o">=</span>1
    <span class="nb">export </span><span class="nv">STF_HOME</span><span class="o">=</span>/root/stf
    <span class="c"># 启动 dispatcher，这里目前还只会用 plack，不知道怎么用 nginx/apache</span>
    <span class="nb">export </span><span class="nv">USE_PLACK_REPROXY</span><span class="o">=</span>1
    <span class="c"># 研究阶段可以打开 debug 看系统是怎么分发怎么平衡怎么确定使用哪个storage的file的过程</span>
    <span class="nb">export </span><span class="nv">STF_DEBUG</span><span class="o">=</span>1
    plackup -a etc/dispatcher.psgi
    <span class="c"># 启动 worker</span>
    ./bin/stf-worker
    <span class="c"># 启动管理界面网站，可以通过 web 添加 cluster 和 storage</span>
    plackup -a etc/admin.psgi -p 9000 &amp;
    <span class="c"># 一个 cluster 下至少需要有 3 个 storage，这里用三个目录三个端口来模拟</span>
    mkdir -p /data<span class="o">{</span>1,2,3<span class="o">}</span>
    <span class="nb">export </span><span class="nv">STF_STORAGE_ROOT</span><span class="o">=</span>/data1
    plackup -a etc/storage.psgi -p 8888 &amp;
    <span class="nb">export </span><span class="nv">STF_STORAGE_ROOT</span><span class="o">=</span>/data2
    plackup -a etc/storage.psgi -p 8889 &amp;
    <span class="nb">export </span><span class="nv">STF_STORAGE_ROOT</span><span class="o">=</span>/data3
    plackup -a etc/storage.psgi -p 8890 &amp;
</code></pre></div>
<p>然后上 9000 端口的 web 添加 cluster 和 storage，如下截图：</p>
<p><img src="/images/uploads/stf-admin1.png" alt="cluster" /></p>
<p><img src="/images/uploads/stf-admin.png" alt="storage" /></p>
<p>最后测试一下上传下载，如果上面 psgi 是 DEBUG 运行的，就可以看到详细的过程了。</p>
<div class="highlight"><pre><code class="bash">    lwp-request -m PUT http://192.168.0.101/bucket
    ^D
    lwp-request -m PUT http://192.168.0.101:5000/bucket/test.txt
    <span class="nb">test</span>
    ^D
    lwp-request http://192.168.0.101:5000/bucket/test.txt
    ls /data1/p/e/g/k/pegkuclninhsyqxftuzpwcuhgughpa.txt
    ls /data2/p/e/g/k/pegkuclninhsyqxftuzpwcuhgughpa.txt
</code></pre></div>
<p><strong>2013 年 03 月 20 日更新</strong></p>
<p>前面测试记录的，都是纯 perl 的部分。实际运用的时候，有些地方是可以用 nginx 来替代的。</p>
<p>源代码包中，apache-sample.conf 比 nginx-sample.conf 要全面的多。不过其实还是 nginx 配置起来容易，比如给 dispatcher.psgi 加上 nginx 代理，只需要这样就可以了：</p>
<div class="highlight"><pre><code class="nginx"><span class="k">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
    <span class="kn">server_name</span> <span class="s">stf</span><span class="p">;</span>
    <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
        <span class="kn">proxy_pass</span> <span class="s">http://192.168.0.101:5000/</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kn">location</span> <span class="s">/reproxy</span> <span class="p">{</span>
        <span class="kn">internal</span><span class="p">;</span>
        <span class="kn">set</span> <span class="nv">$reproxy</span> <span class="nv">$upstream_http_x_reproxy_url</span><span class="p">;</span>
        <span class="kn">proxy_pass</span> <span class="nv">$reproxy</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>然后我们就可以直接通过 <code>http://192.168.0.101/bucket/test.txt</code> 来访问了。</p>
      <a href="/2013/02/22/setup-stf2" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/01/31/puppet-define-type-and-custom-function" title="Puppet 自定义 type 和 function" rel="bookmark">Puppet 自定义 type 和 function</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-01-31 00:00:00 +0800">31 Jan 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>Puppet 除了原有 DSL 以外，还提供了不少接口方便大家开发插件来更简单的完成一些高级功能。</p>
<h1 id="define-type">Define Type</h1>
<p>比如我们要维护一个上千域名组成的 ProxyServer 集群，其域名配置是相近的。那么我们就可以提炼出 template 里会变化的部分作为参数。由此定义出一个 type 如下：</p>
<div class="highlight"><pre><code class="ruby">    <span class="n">define</span> <span class="ss">nginx</span><span class="p">:</span><span class="ss">:vhost4proxy</span><span class="p">(</span>
        <span class="vg">$iplist</span> <span class="o">=</span> <span class="o">[]</span><span class="p">,</span>
        <span class="vg">$domainlist</span> <span class="o">=</span> <span class="o">[]</span><span class="p">,</span>
        <span class="vg">$extconf</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="vg">$nginx_proxy_name</span>    <span class="o">=</span> <span class="vg">$name</span>
        <span class="vg">$nginx_proxy_servers</span> <span class="o">=</span> <span class="vg">$iplist</span>
        <span class="vg">$nginx_server_names</span>  <span class="o">=</span> <span class="vg">$domainlist</span>
        <span class="n">file</span> <span class="p">{</span> <span class="s2">&quot;${nginx_proxy_name}.server.conf&quot;</span><span class="p">:</span>
            <span class="k">ensure</span>  <span class="o">=&gt;</span> <span class="n">file</span><span class="p">,</span>
            <span class="nb">require</span> <span class="o">=&gt;</span> <span class="no">File</span><span class="o">[</span><span class="s1">&#39;/etc/nginx/conf.d&#39;</span><span class="o">]</span><span class="p">,</span>
            <span class="n">path</span>    <span class="o">=&gt;</span> <span class="s2">&quot;/etc/nginx/conf.d/${nginx_proxy_name}.server.conf&quot;</span><span class="p">,</span>
            <span class="n">content</span> <span class="o">=&gt;</span> <span class="n">template</span><span class="p">(</span><span class="s1">&#39;nginx/vhost_proxy.conf.erb&#39;</span><span class="p">),</span>
            <span class="n">notify</span>  <span class="o">=&gt;</span> <span class="no">Service</span><span class="o">[</span><span class="s1">&#39;nginx&#39;</span><span class="o">]</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>然后在 template 里使用参数来生成结果：</p>
<div class="highlight"><pre><code class="ruby">    <span class="n">upstream</span> <span class="o">&lt;</span><span class="sx">%= nginx_proxy_name %&gt; {</span>
<span class="sx">            consistent_hash $request_uri;</span>
<span class="sx">    &lt;% nginx_proxy_servers.each do |ip| -%&gt;</span>
<span class="sx">            server &lt;%=</span> <span class="n">ip</span> <span class="sx">%&gt;;</span>
<span class="sx">    &lt;% end %&gt;</span>
    <span class="p">}</span>
    <span class="n">server</span> <span class="p">{</span>
        <span class="n">listen</span> <span class="mi">80</span><span class="p">;</span>
        <span class="n">server_name</span> <span class="o">&lt;</span><span class="sx">% scope.lookupvar(&quot;nginx_server_names&quot;).each </span><span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="o">-</span><span class="sx">%&gt; &lt;%= name -%&gt;</span><span class="o">&lt;</span><span class="sx">% end %&gt;;</span>
<span class="sx">    </span>
<span class="sx">        location / {</span>
<span class="sx">            proxy_pass       http://&lt;%= scope.lookupvar(&quot;nginx_proxy_name&quot;) %&gt;</span><span class="p">;</span>
            <span class="kp">include</span>          <span class="n">conf</span><span class="o">.</span><span class="n">d</span><span class="o">/</span><span class="n">proxy</span><span class="o">.</span><span class="n">conf</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="o">&lt;</span><span class="sx">% if </span><span class="n">has_variable?</span><span class="p">(</span><span class="s2">&quot;extconf&quot;</span><span class="p">)</span> <span class="sx">%&gt;</span>
<span class="sx">        &lt;%= scope.lookupvar(&quot;extconf&quot;) %&gt;</span>
    <span class="o">&lt;</span><span class="sx">% end </span><span class="o">%&gt;</span>
    <span class="p">}</span>
</code></pre></div>
<p>这样我们只需要在 puppet 中这样调用，就可以直接生成对应的配置了：</p>
<div class="highlight"><pre><code class="ruby">    <span class="ss">nginx</span><span class="p">:</span><span class="ss">:vhost4proxy</span><span class="p">(</span><span class="s1">&#39;server1&#39;</span><span class="p">:</span>
        <span class="o">[</span><span class="s1">&#39;1.1.1.1 weight=2&#39;</span><span class="p">,</span> <span class="s1">&#39;2.2.2.2 weight=3&#39;</span><span class="o">]</span><span class="p">,</span>
        <span class="o">[</span><span class="s1">&#39;server1.domain&#39;</span><span class="p">,</span> <span class="s1">&#39;server1.alias.domain&#39;</span><span class="o">]</span><span class="p">,</span>
        <span class="s1">&#39;access_log /path/to/other_log format&#39;</span>
    <span class="p">)</span>
</code></pre></div>
<h1 id="custom-function">Custom Function</h1>
<p>不过用上面 define type 还不能完全解决我们提出的问题。因为在 puppet 配置里写几千行 nginx::vhost4proxy 也是一件很可怕的事情！</p>
<p>这时候可以更进一步，把 vhost4proxy 的调用过程隐藏成一个 function，如下：</p>
<div class="highlight"><pre><code class="ruby">    <span class="nb">require</span> <span class="s1">&#39;yaml&#39;</span>
    <span class="k">module</span> <span class="nn">Puppet::Parser::Functions</span>
      <span class="n">newfunction</span><span class="p">(</span><span class="ss">:gen_proxy_confd</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:statement</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">args</span><span class="o">|</span>
        <span class="ss">Puppet</span><span class="p">:</span><span class="ss">:Parser</span><span class="o">::</span><span class="no">Functions</span><span class="o">.</span><span class="n">autoloader</span><span class="o">.</span><span class="n">loadall</span>
        <span class="n">resource_type</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
        <span class="n">yaml_dir</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
        <span class="no">Dir</span><span class="o">.</span><span class="n">foreach</span><span class="p">(</span><span class="n">yaml_dir</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">yaml_file</span><span class="o">|</span>
          <span class="n">file_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">yaml_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">yaml_file</span><span class="si">}</span><span class="s2">&quot;</span>
          <span class="k">next</span> <span class="k">unless</span> <span class="n">file_path</span><span class="o">[-</span><span class="mi">5</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">].</span><span class="n">eql?</span><span class="p">(</span><span class="s1">&#39;.yaml&#39;</span><span class="p">)</span>
          <span class="n">res_params</span> <span class="o">=</span> <span class="no">YAML</span><span class="o">.</span><span class="n">load_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
          <span class="n">function_create_resources</span><span class="p">(</span><span class="o">[</span><span class="n">resource_type</span><span class="p">,</span> <span class="n">res_params</span><span class="o">]</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>然后只要把原先传递给 vhost4proxy 的参数写成 yaml 文件放好就行了。</p>
<div class="highlight"><pre><code class="yaml">    <span class="l-Scalar-Plain">---</span> 
    <span class="l-Scalar-Plain">server1</span><span class="p-Indicator">:</span> 
      <span class="l-Scalar-Plain">iplist</span><span class="p-Indicator">:</span> 
        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">1.1.1.1 weight=2</span>
        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">2.2.2.2 weight=3</span>
      <span class="l-Scalar-Plain">domainlist</span><span class="p-Indicator">:</span>
        <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">server1.domain</span>
        <span class="p-Indicator">-</span> <span class="s">&#39;*.server1.alias.domain&#39;</span>
      <span class="l-Scalar-Plain">extconf</span><span class="p-Indicator">:</span> <span class="p-Indicator">|-</span>
        <span class="no">chunkin on;</span>
        <span class="no">error_page 411 = @my_411_error;</span>
        <span class="no">location @my_411_error {</span>
            <span class="no">chunkin_resume;</span>
        <span class="no">}</span>
        <span class="no">access_log /path/to/other_log format;</span>
</code></pre></div>
<p>大家看起来是不是有点眼熟？没错，这个 yaml 的思路完全是借鉴了 hiera 的写法。但是 hiera 的设计是垂直继承的，不适合这里假设的平面式的情况 —— 当然，如果你觉得把这几千个 yaml 都写在一个大 yaml 文件里也不费劲的话。就不用上我这么折腾了~~</p>
<p>最后在 puppet 配置中只用一行就搞定全部：</p>
<div class="highlight"><pre><code class="ruby">    <span class="n">gen_proxy_confd</span><span class="p">(</span><span class="s1">&#39;nginx::vhost4proxy&#39;</span><span class="p">,</span><span class="s2">&quot;${modulepath}/nginx/yaml&quot;</span><span class="p">)</span>
</code></pre></div>
<h1 id="section">要点</h1>
<p>type 基本没有什么难度，因为他还是属于 puppet DSL 的运用。可以在其他配置文件内部直接写 define type，不过 puppet-lint 工具会报一个 warnings，所以建议还是单独拆分出来。</p>
<p>function 首先是路径和命名问题。</p>
<ol>
  <li>要把写 function 的文件放在 <code>${modulepath}/yourmodule/lib/puppet/parser/functions/</code> 路径下；</li>
  <li>和其他 type、class 一样，文件名必须和 function 一致，puppet 才能 autoload；</li>
  <li>格式是固定的，注意有两种:type，statement和rvalue。如果你的 function 目的是返回一个值给 puppet 继续使用，要指定好。默认是 statement；</li>
  <li>在自定义 function 里调用其他 function 有两种办法，一种写全路径 <code>Puppet::Parser::Functions.function('file')</code>；一种是使用 <code>Puppet::Parser::Functions.autoloader.loadall</code> 加载全部 function，然后用 <code>function_**</code> 的方式来调用；</li>
  <li>示例中最关键的一个是调用了 <code>function_create_resources</code> 。<code>create_resources</code> 用来批量创建资源。直接在 puppet 配置文件里使用的时候，接收的是列表参数。但是在 Ruby 里直接使用 <code>function_create_resources</code> 的话，接收的是一个匿名数组作为唯一参数。</li>
  <li>function 和 type 在 puppet 中可以认为是 class 的一种，所以它们也是有自己的作用域的。所以看到传递参数时写的是 &ldquo;nginx::vhost4proxy&rdquo;。</li>
</ol>
<h1 id="section-1">参考内容</h1>
<p>关于 Facts 在 function 中的运用，rvalue 的示例等更多内容见官网：<a href="http://docs.puppetlabs.com/guides/custom_functions.html">http://docs.puppetlabs.com/guides/custom_functions.html</a>。</p>
<p>关于 puppet 自带的各种 function 的说明，见官网(很多也没写)：<a href="http://docs.puppetlabs.com/references/latest/function.html">http://docs.puppetlabs.com/references/latest/function.html</a>。</p>
<h1 id="section-2">鸣谢</h1>
<p>感谢 <a href="http://weibo.com/liucy1983">@liu.cy</a> 童鞋提醒我变量作用域的问题。function 的调试过程很痛苦。</p>
      <a href="/2013/01/31/puppet-define-type-and-custom-function" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/01/11/systemtap-to-debug-kmsg-dump" title="用 systemtap 调试 kmsg dump" rel="bookmark">用 systemtap 调试 kmsg dump</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-01-11 00:00:00 +0800">11 Jan 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#monitor-ref" title="monitor" rel="category tag">monitor</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>google 之前推出了一个 netoops 的 patch，可以让 linux kernel 在崩溃的时候通过 udp 协议把信息发送到远端主机上。我之前在 CentOS6.2 的内核上做过测试，详细做法可以参见淘宝内核组 wiki 的<a href="http://kernel.taobao.org/index.php/Documents/Kernel_build">编译使用淘宝内核</a>和 <a href="kernel.taobao.org/index.php/Documents/Kernel_netoops_howto">netoops 使用指南</a>。唯一有区别的地方就是淘宝使用的 RedHat6 的内核在 CentOS6 上有签名问题，需要自己从 CentOS 官网 ftp 下载 src.rpm 来用 —— 当然如果要自己搞定编译那步，少不了就要自己修改 config-genaric 和 kernel.spc 文件了。</p>
<p>昨天同事升级修改到 CentOS6.3 内核( 2.6.32.220 -&gt; 2.6.32.279 )上。结果发现修改冲突代码编译通过后，再使用 soft dump 方式测试，远端主机 nc 收不到结果了。</p>
<p>稍微 grep 一下代码，发现是在 <code>kernel/printk.c</code> 里定义 <code>void kmsg_dump()</code> 的。好了，使用 systemtap 来检查这里： </p>
<div class="highlight"><pre><code class="c">    <span class="n">stap</span> <span class="o">-</span><span class="n">ve</span> <span class="err">&#39;</span><span class="n">probe</span> <span class="n">kernel</span><span class="p">.</span><span class="n">function</span><span class="p">(</span><span class="s">&quot;kmsg_dump&quot;</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="err">$$</span><span class="n">vars</span><span class="err">$$</span><span class="p">)}</span><span class="err">&#39;</span>
</code></pre></div>
<p>结果发现在 soft dump 的时候有输出，也就是说调用了 <code>kmsg_dump()</code>。</p>
<p>比较 2.6.32.220 和 2.6.32.279 的代码，发现在 <code>kmsg_dump()</code> 里，新内核多了一点判断，如果reason 低于 <code>KERNEL_OOPS</code> 而且没有设置 <code>always_kmsg_dump</code> 变量，那么直接返回不再 <code>dumper-&gt;dump()</code> 了。</p>
<div class="highlight"><pre><code class="c"><span class="mi">1546</span>    <span class="k">if</span> <span class="p">((</span><span class="n">reason</span> <span class="o">&gt;</span> <span class="n">KMSG_DUMP_OOPS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">always_kmsg_dump</span><span class="p">)</span>
<span class="mi">1547</span>            <span class="k">return</span><span class="p">;</span> 
</code></pre></div>
<p>我们验证一下是不是这个原因：</p>
<div class="highlight"><pre><code class="c">    <span class="n">stap</span> <span class="o">-</span><span class="n">gve</span> <span class="err">&#39;</span><span class="n">probe</span> <span class="n">kernel</span><span class="p">.</span><span class="n">statement</span><span class="p">(</span><span class="s">&quot;*@kernel/printk.c:1548&quot;</span><span class="p">)</span>  <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="err">$$</span><span class="n">parms</span><span class="err">$$</span><span class="p">)</span> <span class="p">}</span><span class="err">&#39;</span>
</code></pre></div>
<p>显然测试的时候 reason 是 <code>KERNEL_SOFT</code>，这个是不好调的，那么我们可以调整这个变量，找了一下没发现这个可以在 sysctl 什么的里面，所以继续用 systemtap 搞定：</p>
<div class="highlight"><pre><code class="c">    <span class="n">stap</span> <span class="o">-</span><span class="n">gve</span> <span class="err">&#39;</span><span class="n">probe</span> <span class="n">kernel</span><span class="p">.</span><span class="n">statement</span><span class="p">(</span><span class="s">&quot;*@kernel/printk.c:1545&quot;</span><span class="p">)</span>  <span class="p">{</span> <span class="err">$</span><span class="n">always_kmsg_dump</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="err">$</span><span class="n">always_kmsg_dump</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="err">$$</span><span class="n">parms</span><span class="err">$$</span><span class="p">)</span> <span class="p">}</span><span class="err">&#39;</span>
</code></pre></div>
<p>果然搞定。</p>
      <a href="/2013/01/11/systemtap-to-debug-kmsg-dump" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/01/10/update-puppet-to-3.0" title="升级 Puppet 到 3.0 及其他附件简介" rel="bookmark">升级 Puppet 到 3.0 及其他附件简介</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-01-10 00:00:00 +0800">10 Jan 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>今天把 puppet 从2.7 升级到了 3.0。同时放弃了之前通过 ENC 定义所有 top scope variable 的做法，改成只定义一个 role 变量，然后在各个 module 里根据 $role 加载不同的module::role ，把变量都写在 module::role 里。</p>
<p>经历过上次事故后，我对全局变量已经大大的有不安全感，包括 puppet 3.0 新进内核的 hiera (<a href="http://docs.puppetlabs.com/puppet/3/reference/lang_classes.html#using-hierainclude">官网介绍文档</a>中也说是&rdquo;like a lightweight ENC&rdquo;)。虽然 module::role 看起来很多是重复内容，还是让人工的操作多经过一些检测才放心。</p>
<p>从 2.7 升级到 3.0 没有太多的不适应。官网上列了很多<a href="http://docs.puppetlabs.com/puppet/3/reference/release_notes.html">不同</a>。不过实际上基本没改动什么。</p>
<ul>
  <li>运行命令统一成 <code>puppet command</code> 的形式，2.7的时候还保留的一堆命令都没有了。</li>
  <li><code>--apply</code> 改成 <code>--catalog</code>  了。不过这个其实我没用过。</li>
  <li><code>pluginsync</code> 默认开启了。这个是替代 <code>factsync</code> 的。2.7 的时候默认还是关闭。给 facter 写插件应该是很容易而且很必要的事情。</li>
  <li>master 内置 webserver 取消了。也就是说原先各种优化文档里的 <code>--servertype=mongrel</code> 没用了。但是 3.0 变成了标准 Rack 应用。直接在 <code>/etc/puppet/rack</code> 下运行 <code>rackup -s thin -p 18140 -D -P /tmp/puppetmaster.pid</code> 就可以了。</li>
  <li>自然对应的 rack 配置文件 <code>config.ru</code> 改了，看 example 就好。</li>
  <li><code>include</code> 可以传递数组</li>
  <li>agent 的 lockfile 把 fork running 和 disabled 区分成两个文件了。不知道能不能消灭掉原先 agent 跑着跑着僵死的情况。</li>
</ul>
<p>以上是官网列举的主要内容。以下还有我__实际测试中发现的问题__：</p>
<ul>
  <li>agent 的 puppet.conf 里需要添加一行 <code>preferred_serialization_format = yaml</code>，否则默认使用 pson 会直接报错。</li>
</ul>
<hr />
<p>今天重温了一下 github 在 puppetconf 上的讲演<a href="https://speakerdeck.com/jnewland/chatops">《chatops》</a>。当然对其中的 hubot 不是重点关注。主要是其中提到的 rodjek 的几个 puppet 相关的项目觉得蛮有用的。</p>
<ul>
  <li>puppet-lint </li>
</ul>
<p>地址：<a href="https://github.com/rodjek/puppet-lint.git">https://github.com/rodjek/puppet-lint.git</a></p>
<p>这是一个语法格式检查器，如果 ERROR 会 <code>exit 1</code>。之前两天我还刚在 CPAN 上发现过一个 <a href="https://metacpan.org/module/Puppet::Tidy">Puppet::Tidy</a> 模块。不过目前为止，这两个都不是很满意：</p>
<ol>
  <li>puppet-lint 只能检查格式而不会替你修改格式。</li>
  <li>puppet-tidy 可以修改格式但是它对格式的检查太简陋了。</li>
</ol>
<p>当然比 puppet-tidy 稍微好一些的 puppet-lint 也不是很精准，比如他会对所有用双引号定义的变量报 &ldquo;WARNING: double quoted string containing no variables&rdquo;；而 puppet-tidy 更奇怪的给我 ip 地址的最后一段再加上了一个单引号变成了下面这个样子：</p>
<div class="highlight"><pre><code class="perl">    <span class="nv">$iplist</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;192.168.1.&#39;2&#39;&quot;</span><span class="p">,</span><span class="s">&quot;192.168.1.&#39;3&#39;&quot;</span><span class="p">]</span>
</code></pre></div>
<p>只能说规范化任重道远。</p>
<ul>
  <li>puppet-profiler</li>
</ul>
<p>地址：<a href="https://github.com/rodjek/puppet-profiler.git">https://github.com/rodjek/puppet-profiler.git</a></p>
<p>这是一个 agent 执行的调试器，不过至今为止功能也还很简单：就是执行一次 </p>
<div class="highlight"><pre><code class="bash">    puppet agent --test --evaltrace --nocolor
</code></pre></div>
<p>排序各个 Resource 的执行耗时，并打印前十名。</p>
<ul>
  <li>rspec-puppet</li>
</ul>
<p>地址：<a href="https://github.com/rodjek/rspec-puppet">https://github.com/rodjek/rspec-puppet</a></p>
<p>这是一个 puppet 的 rspec 测试工具扩展。注意他依赖于 <code>puppetlabs_spec_helper</code> 但是 gem 里却没写。。。</p>
<p>使用方法看 github 上的说明比较详细了，稍后我再单写一篇介绍。</p>
      <a href="/2013/01/10/update-puppet-to-3.0" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div class="full" style='background-color: #FFF;'>
    <h1 class="entry-title">
      <a href="/2013/01/10/rspec-puppet-intro" title="给 puppet 写 Rspec 测试用例" rel="bookmark">给 puppet 写 Rspec 测试用例</a>
    </h1>
    <p class="alt-font tight">
      <span class="date full-date">
        <abbr class="published" title="2013-01-10 00:00:00 +0800">10 Jan 2013</abbr>
      </span>
      <span>
      </span>
      Posted in&nbsp;
      <a href="/categories.html#devops-ref" title="devops" rel="category tag">devops</a>
    </p>
    <div class="entry-content full-content" style='background-color: #FFF; margin-left: 24px; padding: 10px;'>
      <p>上文提到 github 给 puppet 开发的几个附件。其中有扩展 rspec 的 rubygems 模块叫做 rspec-puppet。官网见：<a href="http://rspec-puppet.com">http://rspec-puppet.com</a></p>
<p>照着官网 <a href="http://rspec-puppet.com/tutorial/">Tutorial</a>，很容易能写出来测试用例。我这样ruby入门没看完的水准，从发现这个gem到写完第一个测试用例，也就花了不到半个小时。</p>
<h1 id="section">安装</h1>
<div class="highlight"><pre><code class="bash">    gem install puppetlabs_spec_helper rspec_puppet
</code></pre></div>
<h1 id="section-1">创建测试用例环境</h1>
<p>以测试 nginx 模块为例：</p>
<div class="highlight"><pre><code class="bash">    <span class="nb">cd</span> /etc/puppet/modules/nginx
    rspec-puppet-init
</code></pre></div>
<p>这个 init 脚本其实就是执行了一串 <code>mkdir -p</code> 和 <code>ln -s</code> 命令，最后生成一个总的 Rakefile 。详情见官网<a href="http://rspec-puppet.com/setup/">Setup</a>。</p>
<h1 id="section-2">编写测试用例</h1>
<p>扩展给 Rspec 增加的方法其实不多，官网 <a href="http://rspec-puppet.com/matchers/">Matchers</a> 页面上有说。主要就是下面几个：</p>
<ul>
  <li><code>include_class()</code></li>
  <li><code>contain_&lt;resource&gt;()</code></li>
  <li><code>run()</code></li>
  <li><code>.with()</code></li>
  <li><code>.without()</code></li>
</ul>
<p>现在来写我们的第一个测试用例 <code>/etc/puppet/modules/nginx/spec/classes/common_spec.rb</code> 吧：</p>
<div class="highlight"><pre><code class="ruby">    <span class="c1"># 这个文件被 init 自动生成在 /etc/puppet/modules/nginx/spec/ 下了</span>
    <span class="c1"># 其内容就是加入这个目录下所有的文件</span>
    <span class="nb">require</span> <span class="s1">&#39;spec_helper&#39;</span>
    <span class="c1"># 这里定义你要测试的 puppet module</span>
    <span class="n">describe</span> <span class="s1">&#39;nginx&#39;</span> <span class="k">do</span>
        <span class="n">it</span> <span class="k">do</span>
            <span class="n">should</span> <span class="n">include_class</span><span class="p">(</span><span class="s1">&#39;nginx::sysctl&#39;</span><span class="p">)</span>
            <span class="n">should</span> <span class="n">include_class</span><span class="p">(</span><span class="s1">&#39;nginx::install&#39;</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">describe</span> <span class="s1">&#39;nginx::common&#39;</span> <span class="k">do</span>
        <span class="c1"># 使用let定义变量</span>
        <span class="n">let</span><span class="p">(</span><span class="ss">:node</span><span class="p">)</span> <span class="p">{</span> <span class="s1">&#39;common-nginx-2.domain.com&#39;</span> <span class="p">}</span>
        <span class="c1"># 不定义的话，测试中只有从前面:node 生成的 hostname,domain,fqdn 三个</span>
        <span class="n">let</span><span class="p">(</span><span class="ss">:facts</span><span class="p">)</span> <span class="p">{</span> <span class="p">{</span>
            <span class="ss">:ipaddress_eth0</span> <span class="o">=&gt;</span> <span class="s1">&#39;192.168.1.2&#39;</span><span class="p">,</span>
            <span class="ss">:processorcount</span> <span class="o">=&gt;</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span>
        <span class="p">}</span> <span class="p">}</span>
        <span class="n">it</span> <span class="k">do</span>
            <span class="n">should</span> <span class="n">include_class</span><span class="p">(</span><span class="s1">&#39;nginx::common&#39;</span><span class="p">)</span>
            <span class="c1"># 注意这里要写 Resource 的名字，而不是 file 的 path</span>
            <span class="c1"># 这个是下面 .with 检查的 :param</span>
            <span class="n">should</span> <span class="n">contain_file</span><span class="p">(</span><span class="s1">&#39;proxy.conf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with</span><span class="p">({</span>
                <span class="s1">&#39;ensure&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;file&#39;</span><span class="p">,</span>
                <span class="s1">&#39;mode&#39;</span>   <span class="o">=&gt;</span> <span class="s1">&#39;0644&#39;</span><span class="p">,</span>
                <span class="s1">&#39;path&#39;</span>   <span class="o">=&gt;</span> <span class="s1">&#39;/etc/nginx/conf.d/proxy.conf&#39;</span>
            <span class="p">})</span>
        <span class="k">end</span>
        <span class="n">context</span> <span class="s1">&#39;access_log&#39;</span> <span class="k">do</span>
            <span class="n">expect_line</span> <span class="o">=</span> <span class="s1">&#39;access_log /data/nginx/logs/access.log main buffer=16k;&#39;</span>
            <span class="n">it</span> <span class="k">do</span>
                <span class="c1"># 注意这里是把整个 content 作为 String 对象传递</span>
                <span class="n">should</span> <span class="n">contain_file</span><span class="p">(</span><span class="s1">&#39;nginx.conf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_content</span><span class="p">(</span><span class="sr">/</span><span class="si">#{</span><span class="n">expect_line</span><span class="si">}</span><span class="sr">/</span><span class="p">)</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="n">context</span> <span class="s1">&#39;upstream&#39;</span> <span class="k">do</span>
            <span class="n">expect_line</span> <span class="o">=</span> <span class="s1">&#39;192.168.1.2:80;&#39;</span>
            <span class="n">it</span> <span class="k">do</span>
                <span class="n">should</span> <span class="n">contain_file</span><span class="p">(</span><span class="s1">&#39;upstream.conf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_content</span><span class="p">(</span><span class="sr">/</span><span class="si">#{</span><span class="n">expect_line</span><span class="si">}</span><span class="sr">/</span><span class="p">)</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="n">context</span> <span class="s1">&#39;conf.d&#39;</span> <span class="k">do</span>
            <span class="n">it</span> <span class="k">do</span>
                <span class="n">dir</span> <span class="o">=</span> <span class="s1">&#39;/etc/puppet/modules/nginx/files/conf.d&#39;</span>
                <span class="c1"># eq 是 rspec 本身的方法</span>
                <span class="no">Dir</span><span class="o">.</span><span class="n">entries</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">should</span> <span class="n">eq</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
            <span class="k">end</span>
        <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>然后你就可以运行测试了：</p>
<div class="highlight"><pre><code class="bash">    <span class="nb">cd</span> /etc/puppet/modules/nginx
    rake spec
</code></pre></div>
<p>如果测试用例有失败，会在终端看到错误信息。</p>
<p>注意到，rspec 是以 <code>do ... end</code> 来计算 examples 个数的。在一个 <code>do ... end</code> 里写多个 should 或者 expect，也算一个 example。</p>
      <a href="/2013/01/10/rspec-puppet-intro" class="read_more span2 pull-right">继续阅读……</a>
      <div class="clear"></div>
    </div>
    <div class="clear"></div>
  </div>
  <div class="rule"><hr/></div>
  <div id="post-pagination" class="pagination pagination-centered">
  <ul class="pages nav nav-pills">
    <li>
      <a href="/">Previous</a>
    </li>
    <li class="page">
      <a href="/">1</a>
    </li>
    <li class="page active">
      <a href="#">2</a>
    </li>
    <li class="page">
      <a href="/page3">3</a>
    </li>
    <li class="page">
      <a href="/page4">4</a>
    </li>
    <li class="page">
      <a href="/page5">5</a>
    </li>
    <li class="page">
      <a href="/page6">6</a>
    </li>
    <li class="page">
      <a href="/page7">7</a>
    </li>
    <li class="page">
      <a href="/page8">8</a>
    </li>
    <li class="page">
      <a href="/page9">9</a>
    </li>
    <li class="page">
      <a href="/page10">10</a>
    </li>
    <li class="page">
      <a href="/page11">11</a>
    </li>
    <li class="page">
      <a href="/page12">12</a>
    </li>
    <li class="page">
      <a href="/page13">13</a>
    </li>
    <li class="page">
      <a href="/page14">14</a>
    </li>
    <li class="page">
      <a href="/page15">15</a>
    </li>
    <li class="page">
      <a href="/page16">16</a>
    </li>
    <li>
      <a href="/page3">Next</a>
    </li>
  </ul>
</div>
</div>
      </div>
      <div class="span4">
          <div class="well sidebar-nav">
             <ul id="relate_blog" class="nav nav-list">
               <li class="nav-header">最近文章</li>
            </ul>
          </div>
        <div class="well sidebar-nav">
          <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=0&skin=2&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1035836154&verifier=a26926d5&dpc=1"></iframe>
        </div>
        <div class="well sidebar-nav">
            <!--以下是QQ邮件列表订阅嵌入代码-->
            <script >var nId = "86cca8e03c1002936e00aaa28bd933c15c4a437a5e63cafd",nWidth="auto",sColor="light",sText="填写您的邮件地址，订阅logstash/ElasticSearch相关讨论：" ;</script><script src="http://list.qq.com/zh_CN/htmledition/js/qf/page/qfcode.js" charset="gb18030"></script>
        </div>
        <div class="well sidebar-nav">
            <div id="uyan_list_time_frame"></div>
            <script type="text/javascript" id="UYScriptTime" src="http://v1.uyan.cc/js/iframe_time_list.js?UYUserId=1589850&rankType=time" async=""></script>
        </div>
        <div class="well sidebar-nav">
          <ul id="linklists" class="nav nav-list">
            <li class="nav-header">友情链接(英文)</li>
              <li><a href="http://codeascraft.com/" title="Etsy 运维团队博客">Code as Craft</a></li>
              <li><a href="http://blog.dotcloud.com/" title="dotCloud 官方博客">dotCloud-Blog</a></li>
              <li><a href="http://devopsanywhere.blogspot.jp/" title="">devopsanywhere</a></li>
              <li><a href="http://www.jedi.be/blog/" title="">Jong En Dynamische Informatica</a></li>
              <li><a href="http://www.planetdevops.net/" title="">planetdevops</a></li>
              <li><a href="http://www.kitchensoap.com/" title="《网站运维》作者，Etsy 运维">Kitchen Soap</a></li>
              <li><a href="http://blog.johngoulah.com" title="Musings of linux, open source, cloud computing and systems">John Goulah</a></li>
              <li><a href="http://serverfault.com/" title="stackexchange下属的系统工程师问答网站">serverfault</a></li>
              <li><a href="http://www.thegeekstuff.com/" title="各种超酷Linux命令用法">TheGeekStuff</a></li>
              <li><a href="http://neilb.org/" title="The good,the bad,and the beautiful">neilb</a></li>
              <li><a href="http://blog.aka-cool.net/" title="">Aka.Why</a></li>
              <li><a href="http://www.reddit.com/r/perl/" title="">reddit perl 频道</a></li>
              <li><a href="http://jpetazzo.github.io/" title="">~jpetazzo</a></li>
              <li><a href="http://www.perfplanet.com/" title="News and views from the web performance blogosphere">Performance Planet</a></li>
              <li><a href="http://cuddletech.com/blog/" title="Use UNIX or die">Cuddle Tech</a></li>
          </ul>
        </div>
        <div class="well sidebar-nav">
          <ul id="linklists" class="nav nav-list">
            <li class="nav-header">友情链接(中文)</li>
              <li><a href="http://www.icylife.net/blog/" title="">心路</a></li>
              <li><a href="http://dbahacker.com/" title="TB 杨德华">DBA Hacker</a></li>
              <li><a href="http://www.nginxs.com/" title="">eric</a></li>
              <li><a href="http://www.hellodb.net/" title="Ali DBA 张瑞">Hello DBA</a></li>
              <li><a href="http://blog.laird-sa.com/" title="">Laird-SA</a></li>
              <li><a href="http://www.linuxsee.com/" title="">LinuxSEE</a></li>
              <li><a href="http://blog.nosqlfan.com/" title="not only sql信息集散地">NoSQLfan</a></li>
              <li><a href="http://ourmysql.com/" title="">OurMySQL</a></li>
              <li><a href="http://www.puppeter.cn/" title="">piol</a></li>
              <li><a href="http://www.ducea.com/" title="">MDLog:/sysadmin</a></li>
              <li><a href="http://www.sanote.org/" title="">sa note</a></li>
              <li><a href="http://zauc.wordpress.com/" title="">Timo</a></li>
              <li><a href="http://julyclyde.org/" title="新浪系统工程师">七月的夏天</a></li>
              <li><a href="http://www.liurongxing.com/" title="">刘荣星</a></li>
              <li><a href="http://blog.s135.com/" title="金山·张宴">回忆未来</a></li>
              <li><a href="http://blog.ops.tudou.com/wp/" title="">土豆运营团队</a></li>
              <li><a href="http://www.91tuanfang.com/" title="安居客运维">家欣的天空</a></li>
              <li><a href="http://www.cnadn.net/" title="F5工程师">应用交付学习之路</a></li>
              <li><a href="http://scmbob.org/" title="杭州NSN工程师，shell高人~">扛一肩记忆</a></li>
              <li><a href="http://www.php-oa.com/" title="音悦台技术经理">扶凯</a></li>
              <li><a href="http://www.wenzizone.cn/" title="">蚊子世界</a></li>
              <li><a href="http://www.opboy.com" title="">运维小子</a></li>
              <li><a href="http://blog.liuts.com/" title="前天涯SA 刘天斯">运维进行时</a></li>
              <li><a href="http://www.lark.net.cn/" title="lark's cloud">lark's cloud</a></li>
              <li><a href="http://log.heartoutside.com/" title="HeartOutSide">HeartOutside</a></li>
              <li><a href="http://blog.liulantao.com/" title="刘兰涛">Lax</a></li>
              <li><a href="http://l09.me/" title="风声">风声</a></li>
              <li><a href="http://niubie.me/" title="莫言">莫言</a></li>
              <li><a href="http://mooser.me/" title="牛氓">牛氓</a></li>
              <li><a href="http://http://www.yinwang.org/" title="当然我在扯淡">当然我在扯淡</a></li>
              <li><a href="http://noops.me/" title="小米运维部">NoOps</a></li>
              <li><a href="http://www.searchtech.pro/" title="">云端分布式搜索技术</a></li>
              <li><a href="http://www.thegeekstuff.com/" title="各种超酷Linux命令用法">TheGeekStuff</a></li>
              <li><a href="http://muxueqz.laou.me" title="muxueqz">聊逍遥兮容与</a></li>
              <li><a href="http://www.usefulshare.com" title="当当网安全运维">UsefulShare</a></li>
              <li><a href="http://paperplane.ruhoh.com/" title="深入研究puppet">纸飞机</a></li>
              <li><a href="http://www.chinaxing.org/" title="">ChinaXing</a></li>
              <li><a href="http://blog.sectop.org/" title="">kindle</a></li>
              <li><a href="http://bubbyroom.com/" title="守住每一天">Liuyu's blog</a></li>
          </ul>
        </div>
      </div>
    </div> <!-- row -->
      <footer>
        <p>&copy; 陈子 2012 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>
    </div> <!-- /container -->
    <!-- JiaThis Button BEGIN -->
    <script type="text/javascript">var jiathis_config = {data_track_clickback:true};</script>
    <script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=1589850" charset="utf-8"></script>
    <!-- JiaThis Button END -->
    <!-- UJian Button BEGIN -->
    <script type="text/javascript" src="http://v1.ujian.cc/code/ujian.js?type=slide&uid=1589850"></script>
    <!-- UJian Button END -->
  </body>
</html>
